#+BRAIN_PARENTS: system
#+TITLE: Supermemo configuration
#+auto_tangle: t

This is my literate config detailing the installation and management of Supermemo under Wine - interfaced via Emacs.

Features:

- Automated installation of SM18 under Wine (mostly via ~supermemo-wine~)
- Emacs integration by the following means:
  + Emacs and EXWM X-window/buffer management
    - Reliable named buffers navigate-able through EXWM
    - =display-buffer-alist= rules for SM windows; allowing for declarative window arrangement
    - ~Burly~ bookmarking of SM views
  + Text-streams via =exwm-input--fake-key= (utilizing ~Autohotkey~ as a backend) allowing for
    - vIM-style modal bindings with NORMAL and Insert modes (EXWM).
    - Access to SM interface options as hydra-menus.
    - Item element editing in org buffers, with all markup converted back to HTML.

- Bridging functions between SMA, SM, and Emacs creating possibilities for:
  + Helm fuzzy lookup of elements based on their element-id
  + Org-mode card building, much like [[https://github.com/louietan/anki-editor][anki-editor]]
  + *Incremental video via mpv*, allowing for ~lua~ script based generation of gifs, extractions of subs.
  + *Incremental writing of email with ~mu4e~!*
  + *Incremental literate programming* with org-mode and SM's algorithm!


* Installation
:PROPERTIES:
:CREATED:  [2020-11-19 Thu 22:48]
:ID:       c5e3d6cf-81c6-47cf-9bf3-eff77b6a5270
:END:
This guide is meant as a 0-to-working playbook. Parts of it tangle to scripts and Elisp config files that may be opinionated and platform specific. One day it might exist as a Melpa package but for now should be treated as a walk-through.

The first hurdle is getting a working installation of SM18.
We'll be using allesivs [[https://github.com/alessivs/supermemo-wine][supermemo-wine]] .verb for the installation of SM18.

Cloning in the verbs:
#+begin_src sh
cd ~/Templates/sm
git clone https://github.com/alessivs/supermemo-wine.git
#+end_src

Make sure we have the correct wine version: https://dl.winehq.org/wine/source/5.x/

#+begin_src sh
wine --version
#+end_src

#+RESULTS:
: wine-5.2

#+begin_src sh :mkdirp yes :results silent
cd ~/Templates/sm/
curl -O https://dl.winehq.org/wine/source/5.x/wine-5.2.tar.xz
#+end_src

After installation of (the [[https://github.com/Winetricks/winetricks/issues/1593][correct]] version) Wine and Winetricks we can setup the =wineprefix= and install.
Something about the ~:dir sudo~ syntax isn't working
#+begin_src sh :dir /sudo::/vrika
cd ~/Templates/sm/
tar -xf wine-5.2.tar.xz
cd /wine-5.2
./configure
make
sudo make install
#+end_src

#+begin_src sh
env WINEARCH=win32 sh winetricks arch=32 prefix=supermemo18
sh winetricks prefix=supermemo18 ~/Templates/sm/supermemo-wine/verbs/supermemo18.verb
#+end_src

#+RESULTS:

* Setup SM window management
:PROPERTIES:
:CREATED:  [2020-10-09 Fri 18:15]
:ID:       5f96c370-eb26-4117-a7d8-43793e465c9d
:END:
By identifying and naming different SuperMemo window buffers, we can have a reliable way to target those buffers with text streams. Specifically, we can target a buffer with a simulated keypress, affording us a kind of poor-man's API by way of scripting window movement and key-chords in an orchistrated way.

** Capturing buffers
:PROPERTIES:
:CREATED:  [2020-11-20 Fri 10:39]
:ID:       8cf89b9a-bdb4-41a4-a3a9-4343be5c0ee6
:END:

A quirk of using SM under Wine is that a virtual desktop steals management of SM's windows and X naming scheme. In order to use text-streaming and window/buffer management with ~EXWM~ we want to be able to target named instances of the windows which will means we'll need to capture the buffer via =WM_TITLE= of individual windows.

We want to capture the following buffer titles with a regex so that we can move:
a. The Knowledge tree to the left of the screen.
b. The tray to the bottom, but not spanning the whole width of the screen.
c. Have the review buffer as the main window.
d. Have all other SM related windows as floating frames centered on the screen.

We'll use [[info:elisp#Rx][rx]] to handle the notation.

Example of the kinds of text we'll need to capture:
#+begin_example:
Topic #10:
Element #9:
OR
Element
sm18.exe/Second Language
#+end_example:

We can test if our regex captures a given buffer:

#+begin_src elisp :noweb yes
;;TODO use `cl-loop' here instead with its buffer spec
(seq-filter (lambda (buf)
              (string-match-p
               <<element-window-rx>>
               (buffer-name buf)))
            (buffer-list))
#+end_src

** Key SuperMemo windows
:PROPERTIES:
:CREATED:  [2021-09-23 Thu 13:15]
:ID:       523441d5-46f3-45e4-9900-c9ce786dd9f7
:END:
We'll start with the outlier first as its the most important window. Normally, SuperMemo will start with the first scheduled item of the day loaded into the elements window. The element name bleeds into the =WM_TITLE= variable and since we can't predict which element would be presented first on any given day, we will have to use a work around to get a stable title.

The following makes use of Supermemo's ability to set a constant element via the bla bla menu. While this was originally intended to display quotes or the like it works nicely for us as the same text will be shown via =WM_TITLE= and by extension by in the =exwm-title= variable.
Besides, Emacs can be rigged to have this kind of functionality at startup and perform it even better.

Here I use =home= as the only text in the element body, but you can use whatever you like. I've written the hooks in such a way that the buffer-name will remain constant even after progressing past this initial home element.

#+name: element-window-rx
#+begin_src elisp
(rx bol "home" eol)
#+end_src

#+RESULTS: element-window-rx
: ^home$

#+NAME: element-data-rx
#+begin_src elisp
(rx
 (|
  (seq (or "Topic" "Element") space "#" (one-or-more digit) ":")
  (seq "Element data")))
#+end_src

Next capture the knowledge tree:
"X:sm18.exe/neuron"
#+NAME: knowledge-tree-rx
#+begin_src elisp
(rx bol "neuron" eol)
#+end_src

#+RESULTS: knowledge-tree-rx
: ^neuron$

We'll also attempt to suppress the empty(?) buffer created by Supermemo.
This seems to be a frame made for SM.
#+NAME: empty-sm-frame-rx
#+begin_src elisp
(regexp-quote "z:\\home\\nanjigen\\documents\\sm")
#+end_src

#+RESULTS: empty-sm-frame-rx
: z:\\home\\vrika\\documents\\sm

Now we'll throw this together as a set of buffer rules:

** Creating the =sm18.exe= class
:PROPERTIES:
:CREATED:  [2020-11-20 Fri 10:39]
:ID:       c0a59157-a741-4824-b25e-4b8cab63a2d9
:END:

The catch-all [[file:~/.doom.d/modules/desktop/exwm/+funcs.el::defun exwm/rename-buffer (][exwm/rename-buffer]] function captures the sm buffers on each update of the =title-hook=. We need to exclude members of the =sm18.exe= class from this over-general hook:

Exclusion from the generic =exwm/rename-buffer= function based on =exwm-class=:
#+begin_src elisp :noweb yes :noweb-ref exwm-title-hook
(add-hook 'exwm-update-title-hook
          (defun my-exwm-update-title-hook ()
            (unless (or (string-prefix-p "sm18.exe" exwm-class-name))
              (exwm/rename-buffer))))

#+end_src

However, currently the [[file:~/.local/share/applications/supermemo18.supermemo18.desktop::StartupWMClass=sm18.exe][StartupWMClass]] for sm18 is not propagating out to the actuall WM_CLASS as =sm18.exe=, possibly as a limitation of =wine-5.2= (actually, the =.desktop= entry doesn't work for me at all).

The below now works by hooking into the stable =exwm-instance-name=

#+begin_src elisp :noweb yes :noweb-ref exwm-class-hook
(add-hook 'exwm-update-class-hook
          (defun rename-sm-class ()
            "Rename sm18.exe class"
            (when (string-match (rx "sm18.exe") exwm-instance-name)
              (setq exwm-class-name exwm-instance-name))))

(add-hook 'exwm-update-class-hook
          (defun my-exwm-update-class-hook ()
            (unless (or (string-prefix-p "sm18.exe" exwm-class-name))
              (exwm/rename-buffer))))

#+end_src

** Regex and buffer alists
:PROPERTIES:
:CREATED:  [2021-10-02 Sat 11:25]
:ID:       fe2492e4-5d72-481b-8c9b-2b8358055ea7
:END:
A cleaner approach than multiple ~when~ statements is to store the target =buffer-name= and =exwm-title= regex's as key . value pairs, respectively [fn:1].

I should probably be writing this as =cons= and not using backquotes.
#+begin_src elisp :noweb yes :noweb-ref sm-window hooks
(setq exwm-sm-core-buffer-alist
      (list `("sm-element-window" . ,<<element-window-rx>>)
            `("sm-knowledge-tree" . ,<<knowledge-tree-rx>>)
            '("sm-template-registry" . "Template Registry")
            `("sm-element-data" . ,
               <<element-data-rx>>)
            `("sm-frame" . ,<<empty-sm-frame-rx>>)))

#+end_src

#+begin_src elisp :noweb yes :noweb-ref sm-window hooks
(add-hook 'exwm-update-title-hook
          (defun sm-core-window-title-hook ()
            "Manage the core names"
            (cl-loop for (key . value) in exwm-sm-core-buffer-alist
                     if (string-match value exwm-title)
                     do (exwm-workspace-rename-buffer key)
                        (setq exwm-title key))))

#+end_src

#+begin_src elisp :noweb yes :noweb-ref sm-window hooks
(setq exwm-sm-floating-buffer-alist
      '(("sm-images" . "Images")
        ("sm-sorting-criteria" . "Repetition sorting criteria")
        ("sm-concepts" . "Concepts")
        ("sm-new-concept" . "New Concept")
        ("sm-subset" . "Subset")
        ("sm-repair-options" . "Repair Options")
        ("sm-statistics" . "Analysis")
        ("sm-modify-priority" . "Element Priority")
        ("sm-backup-copy" . "Copying")
        ("sm-info-window" . "Information")
        ("sm-algo-choice" . "Choices")
        ("sm-options-window" . "Options")
        ("sm-fonts-window" . "Fonts")
        ("sm-outstanding" . "Outstanding")
        ("sm-commander" . "SuperMemo Commander")
        ;; ("sm-template-registry" . "Template Registry")
        ("sm-element-finder" . "Find elements")))

#+end_src

#+begin_src elisp :noweb yes :noweb-ref sm-window hooks
(add-hook 'exwm-update-title-hook
          (defun sm-window-title-hook ()
            "Iterate over naming alist and rename `exwm-title' to key"
            (cl-loop for (key . value) in exwm-sm-floating-buffer-alist
                     if (string-match (regexp-quote value) exwm-title)
                     do (exwm-workspace-rename-buffer key)
                        (setq exwm-title key))))

#+end_src

[fn:1] I can't find a reason to avoid the small amount of hardcoding done here. The fine-grained control outweighs any convenience automating naming would bring (as it would introduce unpredicability in the buffer naming).

Here we loop over the predefined buffer names in =exwm-sm-window-names=, adding them iteratively to =exwm-manage-configurations=. The two different loops are to differentiate floating vs non-floating windows:

#+begin_src elisp :noweb yes :noweb-ref sm managed configurations
;; (setq exwm-manage-configurations nil)
;; (add-to-list 'exwm-manage-configurations '((string= exwm-instance-name "sm18-core") managed t floating nil))
(add-to-list 'exwm-manage-configurations '((string= exwm-class-name "sm18.exe") managed t floating nil))

(cl-loop for (key . value) in exwm-sm-core-buffer-alist
         do (push `((string= exwm-title ,key) managed t floating nil) exwm-manage-configurations))

(cl-loop for (key . value) in exwm-sm-floating-buffer-alist
         do (push `((string= exwm-title ,key) managed t floating t) exwm-manage-configurations))

(add-to-list 'exwm-manage-configurations '((string= exwm-class-name "notepad.exe") managed t floating nil))
#+end_src

#+begin_src elisp :noweb yes :noweb-ref window assignments :results silent
(require 'subr-x)  ;; Because of when-let

(defvar exwm-workspace-window-assignments
  '(("sm-element-window" . 3)
    ("sm-knowledge-tree" . 3)
    ("sm-element-data" . 3))
  "An alist of window classes and which workspace to put them on.")

(add-hook 'exwm-manage-finish-hook
          (lambda ()
            (when-let ((target (cdr (assoc exwm-class-name exwm-workspace-window-assignments))))
              (exwm-workspace-move-window target))))
#+end_src

#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+sm-window-rules.el
;;; desktop/exwm/+sm-window-rules.el -*- lexical-binding: t; -*-

<<exwm-class-hook>>

<<sm-window hooks>>

<<sm managed configurations>>

<<dbc rules>>
#+end_src

** display-buffer-alist
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:31]
:ID:       6b6b8247-b27b-4771-bd30-74ec4653f123
:header-args: :noweb-ref buffer alist hooks
:END:
Once have these tested and working, theoretically as x-windows under EXWM are just emacs buffers, they could be controlled with the built-in ~display-buffer~ tooling via ~display-buffer-alist~:

#+begin_src elisp :tangle no :noweb no
;; (add-to-list 'display-buffer-alist
;;              `((,<<empty-sm>>
;;                 (display-buffer-no-window))
;;                (,<<tree-rx>>
;;                 (display-buffer-reuse-window display-buffer-in-side-window)
;;                 (side . left)
;;                 (slot . 0)
;;                 (window-width . 0.22))
;;                (,<<element-data-rx>>
;;                 (display-buffer-at-bottom)
;;                 ;; (side . bottom)
;;                 ;; (slot . 0)
;;                 (window-height . 0.19))))
#+end_src

However, this doesn't work as expected an we have to wrap this rules in an exwm hook:
#+begin_src elisp :noweb yes :results silent
(add-hook 'exwm-manage-finish-hook
          (lambda ()
            (when (string-match-p "sm-frame" (buffer-name))
              (display-buffer
               (get-buffer-create "sm-frame")
               '((display-buffer-no-window)
                 (allow-no-window . t))))
            (when (string-match-p "sm-element-window" (buffer-name))
              (display-buffer
               (get-buffer-create "sm-element-window")
               (doom-modeline-mode 1)
               '((display-buffer-same-window))))
            (when (string-match-p "sm-knowledge-tree" (buffer-name))
              (display-buffer
               (get-buffer-create "sm-knowledge-tree")
               '((display-buffer-in-side-window)
                 ;; (inhibit-same-window . t)
                 (side . left)
                 (slot . 0)
                 (window-width . 0.21))))
            (when (string-match-p "sm-element-data" (buffer-name))
              (progn (exwm-layout-hide-mode-line)
                     (display-buffer
                      (get-buffer-create "sm-element-data")
                      '((display-buffer-in-side-window)
                        ;; (inhibit-same-window . t)
                        (side . bottom)
                        (slot . 1)
                        (window-height . 0.21)))))))
#+end_src



#+begin_src elisp :tangle no :noweb yes :results silent
;; (remove-hook 'exwm-manage-finish-hook
;;           (lambda ()
;;             (when (string-match-p
;;                    <<element-data-rx>>
;;                    (buffer-name))
;;               (display-buffer-in-side-window (current-buffer)
;;                                              '((side . bottom)
;;                                                (slot . 0)
;;                                                (window-width . 0.23))))))
#+end_src

** Final buffer tangle
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:36]
:ID:       bef0674e-a594-442b-a959-c7005f24a4d4
:header-args: :noweb-ref dbc rules
:END:
#+begin_src elisp :noweb yes


<<exwm-title-hook>>

<<buffer alist hooks>>
;; <<element window rule>>

;; <<left rule>>

;; <<element tray rule>>

;; )
#+end_src

* sm-core
:PROPERTIES:
:CREATED:  [2020-11-20 Fri 15:55]
:ID:       b98cd336-e48d-4a92-9998-bd88a20b1d12
:END:
Here we'll define the core keypress events we'd want to send to Supermemo.

** TODO xdotool keypress faking
:PROPERTIES:
:CREATED:  [2021-04-20 Tue 15:53]
:ID:       ace7c6f8-9504-4596-a159-a4436e5d1147
:END:

#+begin_src elisp
(defun exwm-sm-xdotool-send-key (keypress)
  "Send a reload event to Firefox."
  (interactive)
  (let ((key keypress)
        (window-id exwm--id))
        (shell-command
         (format "xdotool key --window %s --delay 220 %s" window-id key))))
#+end_src

#+begin_src elisp :noweb yes :noweb-ref xdotool-send
(defun exwm-sm-xdotool-send-key (mod-key keypress)
  "Send a reload event to Firefox."
  (interactive)
  (let ((key keypress)
        ;; (window-id exwm--id)
        (modifier mod-key))
    (shell-command
     (format "xdotool keydown %s sleep 0.1" modifier))
    (exwm-input--fake-key key)
    (shell-command
     (format "xdotool keyup %s"  modifier))))
#+end_src

#+begin_src elisp
(defun exwm-sm-core-word ()
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'right))
#+end_src

#+begin_src elisp
(defun exwm-sm-xdotool-send-key (keypress)
  "Send a reload event to Firefox."
  (interactive)
  (let ((key keypress)
        (window-id exwm--id))
    (start-process-shell-command
     "xdotool"
     "*xdotool*"
     (format "xdotool key --window %s --delay 220 %s" window-id key))))
#+end_src

Using ~shell-command-to-string~
The delay here is quiet noticeable
#+begin_src elisp :noweb yes :noweb-ref shell-command xdo
(defun exwm-sm-xdotool-send-key (keypress)
  "Send a reload event to Firefox."
  (interactive)
  (let ((key keypress))
        (exwm/enter-char-mode)
        (exwm/enter-char-mode)
        ;; (while exwm-input-line-mode-passthrough
        ;;   (exwm/enter-char-mode))
        (shell-command-to-string (format "xdotool key --delay 220 %s" key))
        (exwm/enter-normal-state)))
#+end_src

Using ~make-process~
#+begin_src elisp :noweb yes :noweb-ref make-proc xdo
(defun exwm-sm-xdotool-send-key (keypress)
  "Send a reload event to Firefox."
  (interactive)
  (let ((key keypress))
        (exwm/enter-char-mode)
        ;; (while exwm-input-line-mode-passthrough
        ;;   (exwm/enter-char-mode))
        (make-process
         :name "xdotool"
         ;; :buffer (current-buffer)
         :command '("xdotool" "key --delay 200 %s" key)
        (exwm/enter-normal-state))))
#+end_src

#+begin_src elisp
(defun exwm-sm-xdotool-send-string (string-text)
  "Send text-string to buffer via xdotool."
  (interactive)
  (let ((text string-text)
        (window-id exwm--id))
        (shell-command
         (format "xdotool type --window %s --delay 220 %s" window-id text))))
#+end_src

** HACK Emulating mouse events
:PROPERTIES:
:CREATED:  [2021-10-02 Sat 11:25]
:ID:       f95049ad-539c-47d0-9b7e-b185593ff9eb
:END:

Before moving on to the rest of core, we need to emulate mouse button presses when in ~line-mode~
#+begin_src elisp :noweb yes :noweb-ref mouse input simulation
(defun exwm-input--on-ButtonPress-line-mode (buffer button-event)
  "Handle button events in line mode.
BUFFER is the `exwm-mode' buffer the event was generated
on. BUTTON-EVENT is the X event converted into an Emacs event.

The return value is used as event_mode to release the original
button event."
  (with-current-buffer buffer
    (let ((read-event (exwm-input--mimic-read-event button-event)))
      (exwm--log "%s" read-event)
      (if (and read-event
               (exwm-input--event-passthrough-p read-event))
          ;; The event should be forwarded to emacs
          (progn
            (exwm-input--cache-event read-event)
            (exwm-input--unread-event button-event)

            xcb:Allow:ReplayPointer)
        ;; The event should be replayed
        xcb:Allow:ReplayPointer))))
#+end_src

** Basic movement functions
:PROPERTIES:
:CREATED:  [2021-04-20 Tue 15:53]
:ID:       08f4795c-fb26-4b13-8a48-99a03d67cb53
:END:
#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;; desktop/exwm/+exwm-sm-evil.el -*- lexical-binding: t; -*-

(require 'exwm)
(require 'exwm-input)

<<xdotool-send>>

<<mouse input simulation>>

;;; Basic navigation
;;;###autoload
(defun exwm-sm-core-up ()
  "Move up."
  (interactive)
  (exwm-input--fake-key 'up))

;;;###autoload
(defun exwm-sm-core-down ()
  "Move down."
  (interactive)
  (exwm-input--fake-key 'down))

;;;###autoload
(defun exwm-sm-core-left ()
  "Move down."
  (interactive)
  (exwm-input--fake-key 'left))

;;;###autoload
(defun exwm-sm-core-right ()
  "Move down."
  (interactive)
  (exwm-input--fake-key 'right))

;;;###autoload
(defun exwm-sm-core-word ()
  "Word noun"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'right))

;;;###autoload
(defun exwm-sm-core-word-back ()
  "Back word"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'left))

;;;###autoload
(defun exwm-sm-core-beginning-of-line ()
  "Go to line start"
  (interactive)
  (exwm-input--fake-key 'home))

;;;###autoload
(defun exwm-sm-core-end-of-line ()
  "Go to line end"
  (interactive)
  (exwm-input--fake-key 'end))

;;;###autoload
(defun exwm-sm-core-goto-parent ()
  "Go to parent of current element"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'up))

;;;###autoload
(defun exwm-sm-core-goto-child ()
  "Go to the first child of current element"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'down))

;;;###autoload
(defun exwm-sm-core-forward ()
  "Go forward element"
  (interactive)
  (exwm-sm-xdotool-send-key "alt" 'right))

;;;###autoload
(defun exwm-sm-core-back ()
  "Go back element"
  (interactive)
  (exwm-sm-xdotool-send-key "alt" 'left))

;;;###autoload
(defun exwm-sm-core-goto-first-line ()
  "Go to top of component page"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'home))

;;;###autoload
(defun exwm-sm-core-goto-last-line ()
  "Go to bottom of component page
Note that this goes past the references"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'end))

;;;###autoload
(defun exwm-sm-core-scroll-up ()
  "Scroll up"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl+End"))

;;;###autoload
(defun exwm-sm-core-scroll-down ()
  "Scroll Down"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl+End"))

;;;###autoload
(defun exwm-sm-core-scroll-page-up ()
  "Scroll up by page length"
  (interactive)
  (exwm-sm-xdotool-send-key "Page_Up"))

;;;###autoload
(defun exwm-sm-core-scroll-line-down ()
  "Scroll one visual line down"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl+End"))

;;;###autoload
(defun exwm-sm-core-scroll-page-down ()
  "Scroll down by page length"
  (interactive)
  (exwm-sm-xdotool-send-key "Page_Down"))

;;;###autoload
(defun exwm-sm-core-scroll-line-up ()
  "Scroll one visual line up"
  (interactive)
  (exwm-sm-xdotool-send-key "Page_Down"))
#+end_src

#+begin_src elisp :tangle no
(add-to-list
 'display-buffer-alist
  '("\\*Async Shell Command\\*"
     (display-buffer-no-window)
     (allow-no-window . t)))

(add-to-list
 'display-buffer-alist
  '("\\*EXWM\\*"
     (display-buffer-no-window)
     (allow-no-window . t)))
#+end_src

** Selection
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:45]
:ID:       468001dc-ec7e-454c-aef6-5559c240f146
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;;; Selection

;;;###autoload
(defun exwm-sm-core-visual-char ()
  "Start visual char selection."
  (interactive)
  (exwm-sm-xdotool-send-key "Shift" 'right))

;;;###autoload
(defun exwm-sm-core-visual-line ()
"Start visual line selection."
  (interactive)
  (exwm-input--fake-key 'home)
  (exwm-sm-xdotool-send-key "Shift+End")
  (evil-visual-state))

;;;###autoload
(defun exwm-sm-core-select-all ()
  "Select whole page."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl+a"))

#+end_src

** Find and search operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:22]
:ID:       daa8e452-7e02-4b2f-a081-45f97eeaeedf
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;; Find/Search

;;;###autoload
(defun exwm-sm-core-find ()
  "Find general."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'f))

;;;###autoload
(defun exwm-sm-core-search ()
  "Search for texts containing a given string."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'r))

;;;###autoload
(defun exwm-sm-core-find-elements ()
  "Find elements."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'f))

;;;###autoload
(defun exwm-sm-core-search-phrase ()
  "Search currently selected phrase."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'f3))

;;;###autoload
(defun exwm-sm-core-search-element-id ()
  "Goto element with a given element-id"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'g))

;;;###autoload
(defun exwm-sm-core-find-next ()
  "Find next."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'g))

;;;###autoload
(defun exwm-sm-core-find-previous ()
  "Find previous."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl Shift" 'g))

#+end_src

** Editing
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:25]
:ID:       1d576d49-e772-40ec-a57c-2160d44fd808
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;; Editing

;;;###autoload
(defun exwm-sm-core-escape ()
  (interactive)
  (exwm-input--fake-key 'escape))

;;;###autoload
(defun exwm-sm-core-paste ()
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'v))

(defun exwm-sm-core-paste-html ()
  "Paste html from clipboard."
   (interactive)
   (exwm-sm-xdotool-send-key "Shift" 'f10)
   (exwm-input--fake-key 'x)
   (exwm-input--fake-key 'p))

;;;###autoload
(defun exwm-sm-core-copy ()
  "Copy to clipboard."
   (interactive)
   (exwm-sm-xdotool-send-key "ctrl" 'c))

;;;###autoload
(defun exwm-sm-core-cut ()
  "Cut text."
   (interactive)
   (exwm-sm-xdotool-send-key "ctrl" 'x))

;;;###autoload
(defun exwm-sm-core-undo ()
  "Undo."
   (interactive)
   (exwm-sm-xdotool-send-key "ctrl" 'u))

;;;###autoload
(defun exwm-sm-core-redo ()
  "Redo."
   (interactive)
   (exwm-sm-xdotool-send-key "ctrl Shift" 'z))

;;;###autoload
(defun exwm-sm-core-bold ()
  "Embolden selected text"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'b))

;;;###autoload
(defun exwm-sm-core-italic ()
  "Italicise selected text."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'i))

;;;###autoload
(defun exwm-sm-decrease-font ()
  "Decrease selected font size"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" '\[))

;;;###autoload
(defun exwm-sm-increase-font ()
  "Increase selected font size"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" '\]))

;;;###autoload
(defun exwm-sm-core-edit-question ()
  "Edit the question component"
  (interactive)
  (exwm-input--fake-key 'escape)
  (exwm-input--fake-key 'q))

;;;###autoload
(defun exwm-sm-core-edit-answer ()
  "Edit the first answer"
  (interactive)
  (exwm-input--fake-key 'escape)
  (exwm-input--fake-key 'a))

;;;###autoload
(defun exwm-sm-core-edit-file ()
  "Edit .HTM file"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'f9))

;;;###autoload
(defun exwm-sm-core-edit-next-component ()
  "Edit the next component in element window"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 't))

;;;###autoload
(defun exwm-sm-core-edit-switch-mode ()
  "Cycle presentation -> editing -> dragging modes"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'e))

#+end_src

** Element functions
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:45]
:ID:       6f4b7ba2-8c14-4a7f-a03a-06dd3f193523
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;;###autoload
(defun exwm-sm-core-elements-dismiss-element ()
"Dismiss element while in element window"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'd))

;;;###autoload
(defun exwm-sm-core-element-params ()
  "Bring up apply template menu"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'p))

;;;###autoload
(defun exwm-sm-core-insert-image ()
  "Insert image into component."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'F8))

;;;###autoload
(defun exwm-sm-core-insert-splitline ()
  "Insert splitline in the component menu"
  (interactive)
  (exwm-sm-xdotool-send-key "Shift alt" 'h))

;;;###autoload
(defun exwm-sm-core-cycle-image-stretch ()
  "Cycle stretch of image component."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'q))

;;;###autoload
(defun exwm-sm-core-apply-template ()
  "Bring up apply template menu"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl Shift" 'm))

;;;###autoload
(defun exwm-sm-core-item-picture ()
  "Apply Item Picture template to element"
  (interactive)
  (exwm-sm-core-apply-template)
  (exwm-sm-xdotool-send-string "Item Article"))

;;;###autoload
(defun exwm-sm-core-item-picture ()
  "Apply Item Picture template to element"
  (interactive)
  (exwm-sm-core-apply-template)
  (exwm-sm-xdotool-send-string "Item Picture"))

;;;###autoload
(defun exwm-sm-core-import-component ()
  "Import component in element window"
  (interactive)
  ;; TODO direct this to the `sm-element-window'
  (exwm-sm-xdotool-send-key "ctrl" 'q))

;;;###autoload
(defun exwm-sm-core-reorder-components ()
  "Bring up reorder components menu"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'o))

;;;###autoload
(defun exwm-sm-core-reference-label ()
  "Bring up references menu"
  (interactive)
  (exwm-sm-xdotool-send-key "alt" 'q))

;;;###autoload
(defun exwm-sm-core-test-rep-cycle ()
  "Emulate learning mode to test element/components"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl alt" 'l))

;;;###autoload
(defun exwm-sm-core-tile-components ()
  "Go into tiling menu for component tiling"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl alt" 't))

(defun exwm-sm-core-ancestors ()
"Bring up element ancestors menu"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl Shift" 'x))

(defun exwm-sm-core-create-hyperlink ()
"Create hyperlink over selected text"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'k))

;; (defun exwm-sm-core-get-filepath ()
;; "Get the file path of the current element"
;;   (interactive)
;;   (exwm-sm-xdotool-send-key "~/.scripts/ahk/get-filepath.exe"))
#+end_src

translate winpath
#+begin_src elisp :tangle no
(let ((unix-path (replace-regexp-in-string "\n\\'" ""
                  (shell-command-to-string
                   (shell-quote-argument "winepath -u $(xclip -sel clip -o)"))))))
(shell-command "xclip -sel clip -o")

(subst-char-in-string ?\\ ?\ (gui--selection-value-internal 'CLIPBOARD))
#+end_src


** Learn operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:46]
:ID:       88b59ad6-d7ea-4e85-b828-c147fa4bb902
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;; Learn operations

;;;###autoload
(defun exwm-sm-core-learn ()
  "Start learning."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'l))

;;;###autoload
(defun exwm-sm-core-execute-rep ()
  "Execute repition."
  (interactive)
  (exwm-input--fake-key 'enter))

;;;###autoload
(defun exwm-sm-core-replay ()
  "Replay component."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'F10))

;;;###autoload
(defun exwm-sm-core-cloze ()
  "Extract selected text."
  (interactive)
  (exwm-sm-xdotool-send-key "alt" 'z))

;;;###autoload
(defun exwm-sm-core-extract ()
  "Extract selected text."
  (interactive)
  (exwm-sm-xdotool-send-key "alt" 'x))

;;;###autoload
(defun exwm-sm-core-schedule-extract ()
  "Extract and schedule for a later time."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl alt" 'x))

;;;###autoload
(defun exwm-sm-core-prioritize ()
  "Modify priority of current element."
  (interactive)
  ;;TODO perhaps enter char-mode or create hydra on window
  (exwm-sm-xdotool-send-key "alt" 'p))

;;;###autoload
(defun exwm-sm-core-reschedule ()
  "Learning: Reschedule to another day."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'j))

;;;###autoload
(defun exwm-sm-core-postpone ()
  "Schedule review later today."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl Shift" 'j))

;;;###autoload
(defun exwm-sm-core-remember ()
  "Introduce element into learning que."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'm))

;;;###autoload
(defun exwm-sm-core-execute-rep ()
  "Execute a mid-interval rep at later date."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl Shift" 'r))

;;;###autoload
(defun exwm-sm-core-cancel-grade ()
  "Undo grading on element."
  (interactive)
  (exwm-sm-xdotool-send-key "alt" 'g))

;;;###autoload
(defun exwm-sm-core-branch-learning ()
  "Subset review of a selection of a branch in contents."
  (interactive)
;;; TODO somekind of buffer check
  (exwm-sm-xdotool-send-key "ctrl" 'l))

;;;###autoload
(defun exwm-sm-core-random-learning ()
  "Random learning."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'f11))

;;;###autoload
(defun exwm-sm-core-random-test ()
  "Random test."
  (interactive)
  ;; TODO target browser window
  (exwm-sm-xdotool-send-key "ctrl" 'f11))

;;;###autoload
(defun exwm-sm-core-set-read-point ()
  "Set the read-point."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'f7))

;;;###autoload
(defun exwm-sm-core-mercy ()
  "Activate mercy."
  (interactive)
  (exwm-sm-xdotool-send-key "Shift alt" 'm))

;;;###autoload
(defun exwm-sm-core-neural ()
  "Go neural."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'F2))

;;;###autoload
(defun exwm-sm-core-sorting-criteria ()
  "Open sorting criteria window."
  (interactive)
  (exwm-sm-xdotool-send-key "alt" 'l)
  (exwm-input--fake-key 'o)
  (exwm-input--fake-key 'c))

;;;###autoload
(defun exwm-sm-core-subset-learning ()
  "Subset learning."
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'l))

#+end_src

** Knowledge tree operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 15:27]
:ID:       a34b8b01-dc40-4ee0-be9c-fdc44715ba48
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;;###autoload
(defun exwm-sm-convert-to-concept ()
  "Convert element to concept"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl+k"))

;;;###autoload
(defun exwm-sm-new-article ()
  "Create new article"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl+n"))

#+end_src

** Misc operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 13:48]
:ID:       795a6453-5dfc-42e4-b2cf-735fdd224d0c
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;; Misc

;;;###autoload
(defun exwm-sm-core-sm-commander ()
  "Summon the SuperMemo Commander"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'return))

;;;###autoload
(defun exwm-sm-core-repair-collection ()
  "Bring up the collection repair menu"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'f12))

;;;###autoload
(defun exwm-sm-core-restore-layout ()
  "Restore the default window layout"
  (interactive)
  (exwm-sm-xdotool-send-key "ctrl" 'f5))

;;;###autoload
(defun exwm-sm-core-statistics-analysis ()
  "Open stats window"
  (interactive)
  (exwm-sm-xdotool-send-key "Shift+alt+a"))

;;;###autoload
(defun exwm-sm-core-open-file ()
  "Open file."
  (interactive)
  (exwm-input--fake-key ?\C-o))

;;;###autoload
(defun exwm-sm-core-quit ()
  "Quit sm."
  (interactive)
  (exwm-input--fake-key ?\C-q))

(provide '+exwm-sm-core)
#+end_src


** TODO Try get ~input-fake-key~ working with Wine
:PROPERTIES:
:CREATED:  [2020-12-08 Tue 15:05]
:ID:       733fbf64-129d-4b63-8b92-8fcc569c5627
:END:
Testing some elisp functions to convert Windows paths from Wine to Linux
#+begin_src elisp :tangle no
(defun my-translate-winpath ()
  "change :C\win\path to 'nix /path/path"
  (let ((path (current-kill 0 'do-not-move)))
    (shell-command-to-string (format "~/.scripts/winpath.sh %s" path))))

(defun my-translate-winpath ()
  "change :C\win\path to 'nix /path/path"
  (let ((path (current-kill 0 'do-not-move)))
    (my-translate-path)))

(defun my-translate-winpath ()
  (interactive)
  (let* ((path (s-chop-prefix "z:" (current-kill 0 'do-not-move)))
         (nixpath (s-replace "\\" "/" path))
         (path1 (s-replace "documents" "Documents" nixpath)))
    (s-replace "sm" "SM" path1)))
#+end_src

Let's test this with Xdotool. It works, but isn't reliable.
#+begin_src elisp :tangle no
(defun exwm-sm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
(progn)
(my-translate-winpath)
;; (sit-for 3)
(message sm-path-nix))

(defun exwm-sm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
  ;; (shell-command "sh ~/.scripts/xdotool/get_element_path.sh"))
  (shell-command "sh ~/.scripts/xdotool/get_element_path.sh"))

(defun exwm-sm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
(progn
  (shell-command "sh ~/.scripts/xdotool/get_element_path.sh")
  (gui--selection-value-internal 'CLIPBOARD)))

(defun exwm-sm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
  (shell-command "sh ~/.scripts/xdotool/get_element_path.sh")
(lambda ()
)
  (setq sm-path (gui--selection-value-internal 'CLIPBOARD)))
  ;; (shell-command "sh ~/.scripts/xdotool/get_element_path.sh"))
#+end_src

Testing with EXWM functionality (elisp only).
The big issue here is that control keys are not passed on to the Wine application. However, they are when using ~exwm-input-send-next-key~.
#+begin_src elisp :tangle no
(defun exwm-sm-core-test()
  "test"
  (interactive)
  ;; (exwm--log)
  ;; (let ((exwm-input-line-mode-passthrough t))
         ;; (key "?/C-v"))
         ;; (key (read-key "22")))
    (exwm-input--fake-key ("?/C-s-o")))

(exwm-input-set-key (kbd "<f9>") #'exwm-sm-core-test)


;;;###autoload
(defun exwm-sm-core-test ()
  "Move down."
  (interactive)
  (let ((exwm-input-line-mode-passthrough t))
    (exwm-input--fake-key 'left)))
#+end_src

#+RESULTS:

Try and get the right key code
#+begin_src elisp :tangle no
;; (read-key)
(vector "v")
#+end_src

#+RESULTS:
: ["? C-v"]

Trying the same but with a string.
#+begin_src elisp :tangle no
(defun my-exwm-send-string (string)
  "Send STRING to `exwm-mode' buffer or just insert it."
  (if (eq major-mode 'exwm-mode)
      (mapc #'exwm-input--fake-key (string-to-list string))
    (insert string)))

(defun exwm-sm-core-string-test ()
  (interactive)
  ;; (let ((exwm-input-line-mode-passthrough t))
    ;; (my-exwm-send-string [#o26])))
  (my-exwm-send-string [94 3]))

;; (term-send-raw-string "l")

;; (read-key-sequence-vector)

(exwm-input-set-key (kbd "<f9>") #'exwm-sm-core-string-test)
;; ###autoload
;; (defun exwm-sm-core-test ()
;;   "Send string to a given exwm buffer"
;;   (interactive)
;;   (my-exwm-send-string "sm-get-path ")
;;   (find-file (my-translate-winpath)))
#+end_src

Try with this
#+begin_src elisp :tangle no
(cl-defun exwm-input-send-sim-key (key)
  "Fake a key event according to the last input key sequence."
  (interactive)
  (exwm--log)
  (unless (derived-mode-p 'exwm-mode)
    (cl-return-from exwm-input-send-simulation-key))
  (let ((keys (gethash (this-single-command-keys)
                       exwm-input--simulation-keys)))
    (dolist (key keys)
      (exwm-input--fake-key key))))
#+end_src

#+begin_src elisp :tangle no
(cl-defun my-exwm-input-send-next-key (keys)
  "Send next key to client window.

EXWM will prompt for the key to send.  This command can be prefixed to send
multiple keys.  If END-KEY is non-nil, stop sending keys if it's pressed."
  (interactive "p")
  (exwm--log)
  (unless (derived-mode-p 'exwm-mode)
    (cl-return-from my-exwm-input-send-next-key))
  (let (key keys)
      ;; Skip events not from keyboard
      (let ((exwm-input-line-mode-passthrough t))
            ;; (setq key (read-key (format (key-description keys))
        (setq key (key-description "?\C-v")))
      (setq keys (vconcat keys (vector key)))
      (exwm-input--fake-key key)))
#+end_src

#+begin_src elisp :tangle no
(defun exwm-sm-core-test()
  "test"
  (interactive)
  (exwm/enter-char-mode)
  (exwm-input--fake-key ?\C-v))

  ;; (exwm-input-release-keyboard)
(defun exwm-sm-core-test ()
  "Copy text."
  (interactive)
  (exwm-input--invoke--m))
(exwm-input-invoke-factory "m")

;;;###autoload
(defun exwm-sm-core-copy ()
  "Copy text."
  (interactive)
  (exwm-input--fake-key ?\C-c))

#+end_src

* sm-evil
:PROPERTIES:
:CREATED:  [2020-11-21 Sat 10:31]
:ID:       c792bb4f-4d32-4eaf-a7b4-aa521e5dfcde
:END:

#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-evil.el
;;; desktop/exwm/+exwm-sm-evil.el -*- lexical-binding: t; -*-

(require 'evil)
(require 'evil-core)
(require '+exwm-sm-core)

(defvar exwm-sm-evil-sm-class-name '("sm18.exe")
  "The class name use for detecting if a SM buffer is selected.")

;; (defvar exwm-sm-evil-sm-buffer-name '(sm-element-window)
;;   "The buffer name used for detecting if a SM buffer is selected.")

;;; State transitions
(defun exwm-sm-evil-normal ()
  "Pass every key directly to Emacs."
  (interactive)
  (setq-local exwm-input-line-mode-passthrough t)
  (evil-normal-state))

(defun exwm-sm-evil-insert ()
  "Pass every key to SM."
  (interactive)
  (setq-local exwm-input-line-mode-passthrough nil)
  (evil-insert-state))

(defun exwm-sm-evil-visual ()
  "Visual mode!"
  (interactive)
  (setq-local exwm-input-line-mode-passthrough t)
  (shell-command
   (format "xdotool keydown Shift sleep 0.1"))
  (evil-visual-state))

(defun exwm-sm-evil-exit-visual ()
  "Exit visual state properly."
  (interactive)
  ;; Unmark any selection
  (shell-command
   (format "xdotool keyup Shift"))
  (exwm-sm-core-left)
  (exwm-sm-core-right)
  (exwm-sm-evil-normal))

(defun exwm-sm-evil-visual-change ()
  "Change text in visual mode."
  (interactive)
  (exwm-sm-core-cut)
  (exwm-sm-evil-insert))

;;; Keys
(defvar exwm-sm-evil-mode-map (make-sparse-keymap))

    ;;;; Transitions
;; Bind normal
(define-key exwm-sm-evil-mode-map [remap evil-exit-visual-state] 'exwm-sm-evil-exit-visual)
(define-key exwm-sm-evil-mode-map [remap evil-normal-state] 'exwm-sm-evil-normal)
(define-key exwm-sm-evil-mode-map [remap evil-force-normal-state] 'exwm-sm-evil-normal)
(define-key exwm-sm-evil-mode-map [remap evil-visual-state] 'exwm-sm-evil-visual)
;; Bind insert
(define-key exwm-sm-evil-mode-map [remap evil-insert-state] 'exwm-sm-evil-insert)
(define-key exwm-sm-evil-mode-map [remap evil-insert] 'exwm-sm-evil-insert)
(define-key exwm-sm-evil-mode-map [remap evil-substitute] 'exwm-sm-evil-insert)
(define-key exwm-sm-evil-mode-map [remap evil-append] 'exwm-sm-evil-insert)

#+end_src

** Normal mode maps
:PROPERTIES:
:CREATED:  [2021-10-02 Sat 11:25]
:ID:       fdf9c4a5-abeb-424c-97f5-8eddf3ccf5bc
:END:
#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-evil.el
;;;; Normal
;; Basic movements

(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "w") 'exwm-sm-core-forward-word-test)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "k") 'exwm-sm-core-up)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "j") 'exwm-sm-core-down)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "h") 'exwm-sm-core-left)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "l") 'exwm-sm-core-right)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "K") 'exwm-sm-core-goto-parent)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "J") 'exwm-sm-core-goto-child)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "H") 'exwm-sm-core-back)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "L") 'exwm-sm-core-forward)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "w") 'exwm-sm-core-word)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "b") 'exwm-sm-core-word-back)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "0") 'exwm-sm-core-beginning-of-line)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "$") 'exwm-sm-core-end-of-line)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "/") 'exwm-sm-core-find)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "t") 'exwm-sm-core-test)
;; (evil-define-key 'normal exwm-sm-evil-mode-map (kbd "<escape>") 'exwm-sm-core-escape)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "<return>") '(lambda () (interactive) (exwm-input--fake-key 'return)))
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "RET") '(lambda () (interactive) (exwm-input--fake-key 'return)))

;;; Motion State
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "gg") 'exwm-sm-core-goto-first-line)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "G") 'exwm-sm-core-goto-last-line)

(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "gq") 'exwm-sm-core-edit-question)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "ga") 'exwm-sm-core-edit-answer)

(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "C-u") 'exwm-sm-core-scroll-up)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "C-d") 'exwm-sm-core-scroll-up)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "C-b") 'exwm-sm-core-scroll-page-up)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "C-e") 'exwm-sm-core-scroll-line-down)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "C-f") 'exwm-sm-core-scroll-page-down)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "C-y") 'exwm-sm-core-scroll-line-up)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "RET") 'exwm-sm-core-execute-rep)
#+end_src

#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-evil.el
;;; Editing text
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "y") 'exwm-sm-core-copy)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "d") 'exwm-sm-core-cut)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "p") 'exwm-sm-core-paste)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "u") 'exwm-sm-core-undo)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "C-r") 'exwm-sm-core-redo)

#+end_src

#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-evil.el
;;; Learn operations
;; (evil-define-key 'normal exwm-sm-evil-mode-map (kbd "d") 'exwm-sm-core-contents-dismiss-element)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "x") 'exwm-sm-core-extract)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "X") 'exwm-sm-core-schedule-extract)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "SPC") 'exwm-sm-core-learn)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd ",") 'nanjigen/sm-hydra/body)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "P") 'exwm-sm-core-prioritize)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "s") 'exwm-sm-core-reschedule)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "o") 'exwm-sm-core-get-filepath)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "r") 'exwm-sm-core-replay)

(map! :map exwm-sm-evil-mode-map
      :n "SPC" #'exwm-sm-core-learn)

#+end_src

** Visual maps
:PROPERTIES:
:CREATED:  [2021-10-02 Sat 11:25]
:ID:       f291281f-7415-4251-9ee2-263263661236
:END:
#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-evil.el
;; Selection
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "V") '(lambda
                                                             ()
                                                             (interactive)
                                                             (exwm-input--fake-key 'end)
                                                             (exwm-sm-evil-visual)
                                                             (exwm-input--fake-key 'up)))
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "v") '(lambda
                                                             ()
                                                             (interactive)
                                                             (exwm-sm-evil-visual)
                                                             (exwm-input--fake-key 'right)))

#+end_src


#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-evil.el
;;;; Visual
;; Basic movements
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "k") 'exwm-sm-core-up)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "j") 'exwm-sm-core-down)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "h") 'exwm-sm-core-left)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "l") 'exwm-sm-core-right)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "K") 'exwm-sm-core-goto-parent)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "J") 'exwm-sm-core-goto-child)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "H") 'exwm-sm-core-back)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "L") 'exwm-sm-core-forward)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "w") 'exwm-sm-core-word)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "b") 'exwm-sm-core-word-back)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "{") 'exwm-sm-core-visual-backward-paragraph)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "}") 'exwm-sm-core-visual-forward-paragraph)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "b") 'exwm-sm-core-word-back)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "/") 'exwm-sm-core-find)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "t") 'exwm-sm-core-test)
;; (evil-define-key 'normal exwm-sm-evil-mode-map (kbd "<escape>") 'exwm-sm-core-escape)
(evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "<return>") '(lambda () (interactive) (exwm-input--fake-key 'return)))
(evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "RET") '(lambda () (interactive) (exwm-input--fake-key 'return)))

;;; Motion State
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "gg") 'exwm-sm-core-goto-first-line)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "G") 'exwm-sm-core-goto-last-line)

(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "gq") 'exwm-sm-core-edit-question)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "ga") 'exwm-sm-core-edit-answer)

(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "C-u") 'exwm-sm-core-scroll-up)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "C-d") 'exwm-sm-core-scroll-up)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "C-b") 'exwm-sm-core-scroll-page-up)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "C-e") 'exwm-sm-core-scroll-line-down)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "C-f") 'exwm-sm-core-scroll-page-down)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "C-y") 'exwm-sm-core-scroll-line-up)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "RET") 'exwm-sm-core-execute-rep)
#+end_src

#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-evil.el
;; Selection
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "y") 'exwm-sm-core-copy)
#+end_src

#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-evil.el
;;; Editing text
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "y") 'exwm-sm-core-copy)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "d") 'exwm-sm-core-cut)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "p") 'exwm-sm-core-paste)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "u") 'exwm-sm-core-undo)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "C-r") 'exwm-sm-core-redo)

#+end_src

#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-evil.el
;;; Learn operations
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "x") 'exwm-sm-core-extract)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "X") 'exwm-sm-core-schedule-extract)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "SPC") 'exwm-sm-core-learn)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd ",") 'nanjigen/sm-hydra/body)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "P") 'exwm-sm-core-prioritize)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "s") 'exwm-sm-core-reschedule)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "o") 'exwm-sm-core-get-filepath)
(evil-define-key 'visual exwm-sm-evil-mode-map (kbd "r") 'exwm-sm-core-replay)

(map! :map exwm-sm-evil-mode-map
      :n "SPC" #'exwm-sm-core-learn)

#+end_src
** End
:PROPERTIES:
:CREATED:  [2021-10-02 Sat 11:25]
:ID:       ca5c53de-2eb7-4445-9b25-6641ac7f6733
:END:
#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-evil.el
;;; Mode
;;;###autoload
(define-minor-mode exwm-sm-evil-mode nil nil nil exwm-sm-evil-mode-map
  (if exwm-sm-evil-mode
      (progn
        (exwm-sm-evil-normal))))

;;;###autoload
(defun exwm-sm-evil-activate-if-sm ()
  "Activates exwm-sm mode when buffer is SM.
SM variant can be assigned in 'exwm-sm-evil-sm-name`"
  (interactive)
  (if (member exwm-class-name exwm-sm-evil-sm-class-name)
      (exwm-sm-evil-mode 1)))

(provide '+exwm-sm-evil)

;;; +exwm-sm-evil.el ends here
#+end_src

#+RESULTS:
: +exwm-sm-evil
* sm-hydra
:PROPERTIES:
:CREATED:  [2021-04-20 Tue 15:49]
:ID:       70ea4d74-e725-4448-b1fe-10c10eaa5a9a
:END:

By using a =hydra-title= like [[file:~/.emacs.d/.local/straight/repos/org-media-note/org-media-note.el::defun org-media-note--hydra-title (][here]], I can have commands run in the background to influence the names of hydra commands.
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+sm-hydra.el
;;; desktop/exwm/+sm-hydra.el -*- lexical-binding: t; -*-
(pretty-hydra-define nanjigen/sm-hydra
  (:color red
   ;; :title (--hydra-title)
   :hint nil)
  ("Learn"
   (("rr" (exwm-sm-core-remember) "Remember")
    ("c" (exwm-sm-core-cancel-grade) "Undo grading")
    ("s" (nanjigen/sm-subset-hydra/body) "Subset operations")
    ("rs" (exwm-sm-core-set-read-point) "Set read point")
    ("m" (exwm-sm-core-mercy) "Mercy")
    ("S" (exwm-sm-core-sorting-criteria) "Sorting Criteria"))
  "Editing"
   (("i" (exwm-sm-core-italic) "italics")
    ("b" (exwm-sm-core-bold) "bold")
    ("q" (exwm-sm-core-edit-question) "Edit Question")
    ("a" (exwm-sm-core-edit-answer) "Edit Answer")
    ("n" (exwm-sm-core-edit-answer) "Edit Next Component")
    ("f" (exwm-sm-core-edit-file) "Edit File"))
  "Misc"
   (("SPC" (exwm-sm-core-sm-commander) "SuperMemo Commander")
    ("rc" (exwm-sm-core-repair-collection) "Repair Collection")
    ("rl" (exwm-sm-core-restore-layout) "Restore layout")
    ("A" (exwm-sm-core-statistics-analysis) "Stats window"))))

#+end_src

#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+sm-hydra.el
;;; desktop/exwm/+sm-hydra.el -*- lexical-binding: t; -*-
(pretty-hydra-define nanjigen/sm-subset-hydra
  (:color red
   ;; :title (--hydra-title)
   :hint nil)
  ("Learn"
   (("b" (exwm-sm-core-branch-learning) "Branch learning")
    ("r" (exwm-sm-core-random-learning) "Random learning")
    ("t" (exwm-sm-core-random-test) "Random test")
    ("n" (exwm-sm-core-neural) "Go neural")
    ("s" (exwm-sm-core-subset-learning) "Subset learning"))))

#+end_src

* sm desktop
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:36]
:ID:       c5515f7e-a0c6-40d8-8b60-36b4334874ad
:END:
.desktop file:
#+begin_src conf
[Desktop Entry]
Name=SuperMemo 18 (ms-office)
Exec=env WINEPREFIX="/home/volk/.local/share/wineprefixes/ms-office" wine "/home/volk/.local/share/wineprefixes/ms-office/drive_c/SuperMemo/sm18.exe"
Type=Application
Categories=Education;
StartupNotify=true
Comment=Organize your knowledge and learn at the maximum possible speed
Path=/home/volk/.local/share/wineprefixes/ms-office/drive_c/SuperMemo
Icon=/home/volk/.local/share/wineprefixes/ms-office/drive_c/SuperMemo/smicon.png
StartupWMClass=sm18.exe
#+end_src

* SM with Emacs
:PROPERTIES:
:CREATED:  [2021-01-04 Mon 15:52]
:ID:       a04ab1f5-a77b-4dec-8c59-3276246dfb88
:END:
** fs monitoring
:PROPERTIES:
:CREATED:  [2021-09-19 Sun 17:46]
:ID:       503009e6-6543-471d-b7a7-0bcfdf90aa94
:END:

Using =inotifywait= from the ~inotif-tools~ program we can watch the =$SM-COLLECTION/elements= folder recursively for file open events made by SuperMemo:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+sm-sentinel.el
;;; desktop/exwm/+sm-sentinel.el -*- lexical-binding: t; -*-

(defun sm-element-inotify-process ()
  "Watch for reads of element files in the collection dir"
  (interactive)
  (start-process
   "inotifywait"
   "*inotifywait*"
   "inotifywait" "-mrq" "-e" "open" "/home/nanjigen/Documents/SM/neuron/elements" "--include" ".HTM"))

#+end_src

And to watch image access:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+sm-sentinel.el
(defun sm-image-inotify-process ()
  "Watch for reads of image files in the collection dir"
  (interactive)
  (start-process
   "inotifywait-image"
   "*inotifywait-image*"
   "inotifywait" "-mrq" "-e" "open" "/home/nanjigen/Documents/SM/neuron/elements" "--include" "\.(jpg|gif|png|svg)"))
#+end_src

#+RESULTS:
: #<process inotifywait>

Setup a sentinel to watch for changes to the process buffer =*inotifywait*=
This is mostly for testing purposes
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+sm-sentinel.el
(defun msg-me (process event)
  (princ
   (format "Process: %s had the event '%s'" process event)))
(set-process-sentinel (get-process "inotifywait") 'msg-me)

#+end_src

The function below captures all the paths outputted from the ~inotifywait~ process as seperate symbols in a single list. This is then transferred to a holding variable of the same make-up, and the original list is emptied. This way, on every file read when an element is accessed by SuperMemo, only those file paths are kept in the variable, instead of appending each new file found to the list.
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+sm-sentinel.el
(defun keep-output (process output)
  "Store the paths of elements caught by inotify"
  (progn
    (setq captured-path (cons output captured-path))
    (sleep-for 0.1)
    (list-sm-element-paths)
    (setq captured-path nil)))

(defun keep-image-path (process output)
  "Store the paths of elements caught by inotify"
  (progn
    (setq captured-image-path (cons output captured-image-path))
    (sleep-for 0.1)
    (setq image-file-list (s-lines (s-replace " OPEN " "" (car captured-image-path))))
    (setq captured-image-path nil)))

#+end_src

#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+sm-sentinel.el
(defvar captured-image-path nil
  "The path captured by the inotify sentinel")

(defvar captured-path nil
  "The path captured by the inotify sentinel")

#+end_src

The below is some logic for determining if what was captured is a Topic or an element pair such as Q/A or a cloze. It then stores the path values as such.

#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+sm-sentinel.el
(defun list-sm-element-paths ()
  "Text munge captured paths"
  (setq sm-file-list (s-lines (s-replace " OPEN " "" (car captured-path))))
  (interactive)
  (if (> (length sm-file-list) 1)
      (progn
        (setq sm-element-item-p t)
        (setq sm-element-article-p nil))
    (progn
      (setq sm-element-item-p nil)
      (setq sm-element-article-p t))))

#+end_src

#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+sm-sentinel.el
(defvar sm-element-item-p nil
  "Whether currently viewed element is an item.")

(defvar sm-element-article-p nil
  "Whether currently viewed element is an article")

#+end_src

Get process and set sentinels:
#+begin_src elisp

(set-process-filter (get-process "inotifywait") 'keep-output)
(set-process-filter (get-process "inotifywait-image") 'keep-image-path)

#+end_src

#+begin_src elisp
(process-sentinel (get-process "inotifywait"))
#+end_src

Edit files:
#+begin_src elisp
(defun edit-component-as-org ()
  (interactive)
  (if sm-element-item-p t
    (let ((question (nth 0 file-list))
          (answer (nth 1 file-list)))
      (find-file question))))

#+end_src

Then we can parse these file read through to various =setq's= to be read in the background.
** sm launcher
:PROPERTIES:
:CREATED:  [2021-09-20 Mon 07:42]
:ID:       eec68fe9-9dc3-4591-9047-af0e4ea196b4
:END:

The wineprefix and drive_c should be named ~$PATHS~
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+sm-emacs-protocol.el
(defun nanjigen/launch-sm-process ()
  "Launch SM as a process with 'start-process-shell-command'"
  (interactive)
  (start-process-shell-command
   "SuperMemo18"
   "*Supermemo18*"
   (combine-and-quote-strings '("env WINEPREFIX="
                                "/home/nanjigen/.local/share/wineprefixes/supermemo18"
                                " wine "
                                "/home/nanjigen/.local/share/wineprefixes/supermemo18/drive_c/SuperMemo/sm18.exe"
                                "") "\"")))

#+end_src

#+RESULTS:
: nanjigen/launch-sm-process

#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+sm-emacs-protocol.el
(defun nanjigen/launch-notepad-process ()
  "Launch SM as a process with 'start-process-shell-command'"
  (interactive)
  (start-process-shell-command
   "Notepad"
   "*notepad.exe*"
   (combine-and-quote-strings '("env WINEPREFIX="
                                "/home/nanjigen/.local/share/wineprefixes/supermemo18"
                                " wine "
                                "notepad.exe"
                                "") "\"")))

#+end_src

#+RESULTS:
: nanjigen/launch-notepad-process

#+begin_src elisp
(process-list)
#+end_src

#+RESULTS:
| SuperMemo18 | *Guix Internal REPL* | Guile REPL | vterm | *bash-completion* | XELB | epdfinfo | server |

#+begin_src elisp
;; (process-command (get-process "SuperMemo18"))
;; (alist-get 'comm (process-attributes
;;                   (process-id (get-process "SuperMemo18"))))
;; (process-id (get-process "SuperMemo18"))
;; (get-process "SuperMemo18")
;; (process-name (get-process "SuperMemo18"))
;; (let* ((child-procs (alist-get 'comm (process-attributes 3335)))
;;        ()))
(process-attributes (process-id (get-process "SuperMemo18")))

;; (exwm--update-class 3335)
;; (exwm--id->buffer 8178896)
#+end_src

#+RESULTS:
: ((args . /home/nanjigen/.local/share/wineprefixes/supermemo18/drive_c/SuperMemo/sm18.exe) (pmem . 0.9888432805055687) (pcpu . 0.5553476355470778) (etime 0 828 310000 0) (rss . 97864) (vsize . 2725560) (start 24910 33423 939463 133000) (thcount . 4) (nice . 0) (pri . 20) (ctime 0 0 0 0) (cstime 0 0 0 0) (cutime 0 0 0 0) (time 0 4 600000 0) (stime 0 1 450000 0) (utime 0 3 150000 0) (cmajflt . 0) (cminflt . 228) (majflt . 16202) (minflt . 68015) (tpgid . 3806) (ttname . /dev/pts0) (sess . 3806) (pgrp . 3806) (ppid . 22545) (state . S) (comm . sm18.exe) (group . users) (egid . 998) (user . nanjigen) (euid . 1000))

#+begin_src sh
guix install dotnet@3
#+end_src

#+RESULTS:

#+begin_src sh
# xprop -id 3806
# pgrep sm18.exe
# xdotool search --pid 3806
# xdotool search --pid 3335 -- set_window --class sm18
xdotool search --name home

#+end_src
#+RESULTS:

81788961
** sm yasnippet
:PROPERTIES:
:CREATED:  [2021-01-04 Mon 15:52]
:ID:       9fd2197d-3730-458d-ad94-c90d7309d355
:END:

#+begin_src yasnippet
# -*- mode: snippet -*-
# name: org-pdftools-sm-reference
# key: pdf-ref
# --

#SuperMemoReference
#Title:
#Author:
#Date: Imported on Dec 28, 2020, 00:00:00
#Source: (org-ref) bibtex?
#Link: pdf:
#Comment:
#Article: 40:
#Concept group: Root: neruon (1: neuron)
#+end_src

* org-protocol
:PROPERTIES:
:CREATED:  [2021-02-19 Fri 13:42]
:ID:       4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b
:END:
By using ~org-protocol~, we can call =emacsclient= from other applications by specifying a link recognised by the OS (whether is be Linux or Windows).

First we declare a regedit for WINE, in which we allow Windows to recognise the ~org-protocol:~ scheme handler:
https://github.com/nobiot/Zero-to-Emacs-and-Org-roam/blob/main/90.org-protocol.md
#+begin_src conf
Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\org-protocol]
@="URL:Org Protocol"
"URL Protocol"=""
[HKEY_CLASSES_ROOT\org-protocol\shell]
[HKEY_CLASSES_ROOT\org-protocol\shell\open]
[HKEY_CLASSES_ROOT\org-protocol\shell\open\command]
@="C:\\windows\\system32\\winebrowser.exe -nohome \"%1\""
#+end_src

#+begin_src sh
wine regedit
#+end_src

#+begin_src conf :tangle ~/.local/share/applications/org-protocol.desktop
[Desktop Entry]
Name=org-protocol
Exec=emacsclient -n %u
Type=Application
Terminal=false
Categories=System;
MimeType=x-scheme-handler/org-protocol;
#+end_src

#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/lang/org-private/+org-protocol.el
;;; lang/org-private/+org-protocol.el -*- lexical-binding: t; -*-

(use-package! org-protocol
  :after org
  :config
  <<org-protocol handlers>>
  )

<<org-export backend>>

#+end_src

The whole protocol system can be fairly complex in terms of flow. Let's draw a diagram to better explain our intention:



** Custom org-protocol handlers
:PROPERTIES:
:CREATED:  [2021-03-01 Mon 15:07]
:ID:       c342cd1d-25eb-499f-9bf5-d1b4dbf1e470
:header-args: :noweb-ref org-protocol handlers
:END:
Then we can write a custom org-id [[https://emacs.stackexchange.com/questions/47986/jump-to-org-mode-heading-from-external-application][protocol handler]]:
#+begin_src elisp

(add-to-list 'org-protocol-protocol-alist
             '("org-id" :protocol "org-id"
               :function org-id-protocol-goto-org-id))

(defun org-id-protocol-goto-org-id (info)
  "This handler simply goes to the org heading with given id using emacsclient.

    INFO is an alist containing additional information passed by the protocol URL.
    It should contain the id key, pointing to the path of the org id.

      Example protocol string:
      org-protocol://org-id?id=309A0509-81BE-4D51-87F4-D3F61B79EBA4"
  (when-let ((id (plist-get info :id)))
    (org-id-goto id))
  nil)

(defun org-id-protocol-link-copy ()
  (interactive)
  (org-kill-new (concat "org-protocol://org-id?id="
                        (org-id-copy))))

#+end_src

#+begin_src elisp
(add-to-list 'org-protocol-protocol-alist
             '("brain-id" :protocol "brain-id"
               :function brain-id-protocol-visualize-brain-id))

(defun brain-id-protocol-visualize-brain-id (info)
  "This handler visualizes the org heading with given id using emacsclient.

    INFO is an alist containing additional information passed by the protocol URL.
    It should contain the id key, pointing to the path of the org id.

      Example protocol string:
      org-protocol://brain-id?id=309A0509-81BE-4D51-87F4-D3F61B79EBA4"
  (when-let ((id (plist-get info :id)))
    (org-brain-visualize (or (org-brain-entry-from-id id))))
  nil)

(defun brain-id-protocol-link-copy ()
  (interactive)
  (org-kill-new (concat "org-protocol://brain-id?id="
                        (org-id-copy))))

#+end_src

#+begin_src elisp
(add-to-list 'org-protocol-protocol-alist
             '("pdf-tools" :protocol "pdf-tools"
               :function pdftools-protocol-pop-pdf))

(defun pdftools-protocol-pop-pdf (info)
  "This opens the highlight location of the given extract

    INFO is an alist containing additional information passed by the protocol URL.
    It should contain the org-pdf-tools link, pointing to the path of the org id.

      Example protocol string:
      org-protocol://brain-id?id=309A0509-81BE-4D51-87F4-D3F61B79EBA4"
  (when-let ((link (plist-get info :pdf)))
    (org-link-open-from-string (format "[[pdf:%s]]" link)))
  nil)

(defun pdf-tools-protocol-link-copy ()
  (interactive)
  (org-kill-new (concat "org-protocol://pdf-tools?pdf="
                        (org-entry-get nil "NOTER_PAGE"))))

(defun pdft-tools-protocol-htmlfier ()
  (interactive)
  (let ((pdf-link (org-entry-get nil "ID")))
    (format "<a href=\"org-protocol://pdf-tools?pdf=%s\"></a>" pdf-link)))

(defun pdf-tools-protocol-html-link-copy ()
  (interactive)
  (org-kill-new (concat "<a href=\"org-protocol://pdf-tools?pdf="
                        (org-entry-get nil "NOTER_PAGE") "</a>")))

#+end_src
"<a href=\"org-protocol://brain-id?id=%s\">%s</a>"

We also want the ability to store an ~org-id~ UUID translated /back/ from the =attach-dir=. This will allow us to act upon the source file if we choose to take notes on the video file.

#+begin_src elisp
(defun org-attach-id-from-dir (id)
  "Translate a org-attach dir folder-path back into an UUID ID"
  (format "%s%s"
  (substring id 0 2)
  (substring id 3)))

#+end_src

Do some simple string splitting. This hopefully conforms to the way this kind of information is normally handled in =org-mode/org-media-note=.
#+begin_src elisp
(add-to-list 'org-protocol-protocol-alist
             '("media-link" :protocol "media-link"
               :function media-link-protocol-play-mpv-video))

(defun media-link-protocol-play-mpv-video (info)
  "This handler visualizes the org heading with given id using emacsclient.

    INFO is an alist containing additional information passed by the protocol URL.
    It should contain the id key, pointing to the path of the org id.

      Example protocol string:
      org-protocol://media-link?video=~/org/.attach/27/e2318b-7353-4004-943a-2f1d69b32209/doge_vid420.mpg#0:00:13"
  (when-let ((link (plist-get info :video)))
    (let* ((org-style-link (format "[[video:%s]]" link))
           (splitted (split-string org-style-link "/"))
           (id (format "%s%s"
                       (nth 3 splitted)
                       (nth 4 splitted))))
        ;; (org-link-open-from-string (format "[[video:%s]]" link))
        (setq org-protocol-uuid-from-media-link id)
        (setq org-protocol-last-visited-link org-style-link)
        (org-link-open-from-string org-style-link))
        nil))

  (defun nanjigen/org-media-note-jump-to-note ()
    (interactive)
    (let* ((buffer (org-id-find org-protocol-uuid-from-media-link))
          (link-text (nth 5
                          (split-string org-protocol-last-visited-link "/")))
          (link-text-clean (substring link-text 0 -2)))
      (progn
        (org-id-open org-protocol-uuid-from-media-link t)
        (org-narrow-to-subtree)
        (search-forward link-text-clean)
        (recenter nil))))

(defun media-link-protocol-link-copy ()
  (interactive)
  (org-kill-new (concat "org-protocol://media-link?video="
                        (org-id-copy))))

#+end_src

Now we can use the stored variables and on request open the location of the link in a buffer for note-taking.

See =org-noter--create-session= for inspiration
#+begin_src elisp
(defun nanjigen/org-media-note--create-session ()
  (let* ((notes-buffer
          (make-indirect-buffer)))))
#+end_src

#+begin_src elisp
(defun media-link-protocol-play-cite-video (info)
"This handler visualizes the org heading with given id using emacsclient.

  INFO is an alist containing additional information passed by the protocol URL.
  It should contain the id key, pointing to the path of the org id.

    Example protocol string:
    org-protocol://media-link?videocite=~/org/.attach/27/e2318b-7353-4004-943a-2f1d69b32209/doge_vid420.mpg#0:00:13"
(when-let ((link (plist-get info :videocite)))
  (org-link-open-from-string (format "[[videocite:%s]]" link)))
nil)

(defun media-link-protocol-cite-link-copy ()
  (interactive)
  (org-kill-new (concat "org-protocol://media-link?videocite="
                        (org-media-note--current-org-ref-key))))
#+end_src
org-protocol://media-link?video=https://www.youtube.com/watch?v=lW3eWIj3Q04#0:03:28-0:03:39
org-protocol://org-id?id=4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b
[[org-protocol://org-id/?id=4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b]]
[[org-protocol://org-id?id=4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b]] ;; doesn't work

Because we have defined a regedit, with the right formatting, html links will redirect to the org-protocol handler as well:
#+begin_example html :tangle no
<A href="org-protocol://org-id?id=4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b">Link text here</A>
<A href="org-protocol://org-id?id=4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b">** org-protocol</A>
#+end_example

This can be directly pasted into an element with either =e= (for Questions) or =a= (for Answers) and then =M-<F10>-x-p= (Element pane -> Text -> Paste Html)

Now we can write a key script to automate this process, and bind it to a contextual hydra:

** org-export backend
:PROPERTIES:
:CREATED:  [2021-03-01 Mon 15:07]
:ID:       d2942d96-207d-4061-bcea-116f8a437b8d
:header-args: :noweb-ref org-export backend
:END:
To automate the process, we can write extend the =org-export= backend with [[https://kitchingroup.cheme.cmu.edu/blog/2018/05/09/Making-it-easier-to-extend-the-export-of-org-mode-links-with-generic-functions/][org-link-set-parameters]] to introduce the above protocol link into header text automatically
#+begin_src elisp
(cl-defgeneric brain-link-export (path desc backend)
 "Generic function to export a brain link."
 path)

;; this one runs when the backend is equal to html
(cl-defmethod brain-link-export ((path t) (desc t) (backend (eql html)))
 (format "<a href=\"org-protocol://brain-id?id=%s\">%s</a>" path desc))

(org-link-set-parameters "brain" :export 'brain-link-export)
#+end_src

=video:= link exporter
#+begin_src elisp
(cl-defgeneric media-link-export (path desc backend)
 "Generic function to export a brain link."
 path)

;; this one runs when the backend is equal to html
(cl-defmethod media-link-export ((path t) (desc t) (backend (eql html)))
 (format "<a href=\"org-protocol://media-link?video=%s\">%s</a>" path desc))

(org-link-set-parameters "video" :export 'media-link-export)
#+end_src

=videocite:= link exporter
#+begin_src elisp

;; this one runs when the backend is equal to html
(cl-defmethod media-link-export ((path t) (desc t) (backend (eql html)))
 (format "<a href=\"org-protocol://media-link?video=%s\">%s</a>" path desc))

(org-link-set-parameters "video" :export 'media-link-export)

;; for videocite links
(cl-defgeneric videocite-link-export (path desc backend)
 "Generic function to export a brain link."
 path)

;; this one runs when the backend is equal to html
(cl-defmethod videocite-link-export ((path t) (desc t) (backend (eql html)))
 (format "<a href=\"org-protocol://media-link?videocite=%s\">%s</a>" path desc))

(org-link-set-parameters "videocite" :export 'videocite-link-export)
#+end_src

cite:key reference exporter
#+begin_src elisp
(cl-defgeneric cite-link-export (path desc backend)
 "Generic function to export a brain link."
 path)

;; this one runs when the backend is equal to html
(cl-defmethod cite-link-export ((path t) (desc t) (backend (eql html)))
  (format "<a href=\"%s\">%s:%s</a>" path path desc))

(org-link-set-parameters "cite" :export 'cite-link-export)
#+end_src

Ideally targeting the ~:ID:~ property, extracting the =org-id= and generating the org-protocol link:
https://emacs.stackexchange.com/questions/156/emacs-function-to-convert-an-arbitrary-org-property-into-an-arbitrary-string-na

Modified =org-html-headline= from [[file:~/.emacs.d/.local/straight/repos/org-mode/lisp/ox-html.el::defun org-html-headline (headline contents info][ox-html.el]] :
#+begin_src elisp
(after! org
  (setq org-html-self-link-headlines t)

  (defun org-html-headline (headline contents info)
    "Transcode a HEADLINE element from Org to HTML.
    CONTENTS holds the contents of the headline.  INFO is a plist
    holding contextual information."
    (unless (org-element-property :footnote-section-p headline)
      (let* ((numberedp (org-export-numbered-headline-p headline info))
             (numbers (org-export-get-headline-number headline info))
             (level (+ (org-export-get-relative-level headline info)
                       (1- (plist-get info :html-toplevel-hlevel))))
             (todo (and (plist-get info :with-todo-keywords)
                        (let ((todo (org-element-property :todo-keyword headline)))
                          (and todo (org-export-data todo info)))))
             (todo-type (and todo (org-element-property :todo-type headline)))
             (priority (and (plist-get info :with-priority)
                            (org-element-property :priority headline)))
             (text (org-export-data (org-element-property :title headline) info))
             (tags (and (plist-get info :with-tags)
                        (org-export-get-tags headline info)))
             (full-text (funcall (plist-get info :html-format-headline-function)
                                 todo todo-type priority text tags info))
             (contents (or contents ""))
             (id (org-html--reference headline info))
             (brain-id (org-element-property :ID headline))
             (formatted-text
              ;; (if (plist-get info :html-self-link-headlines)
              ;;     (format "<a href=\"#%s\">%s</a>" id full-text)
              ;;   full-text)))
              (if (plist-get info :html-self-link-headlines)
                  (format "<a href=\"org-protocol://brain-id?id=%s\">%s</a>" brain-id full-text)
                full-text)))
        (if (org-export-low-level-p headline info)
            ;; This is a deep sub-tree: export it as a list item.
            (let* ((html-type (if numberedp "ol" "ul")))
              (concat
               (and (org-export-first-sibling-p headline info)
                    (apply #'format "<%s class=\"org-%s\">\n"
                           (make-list 2 html-type)))
               (org-html-format-list-item
                contents (if numberedp 'ordered 'unordered)
                nil info nil
                (concat (org-html--anchor id nil nil info) formatted-text)) "\n"
               (and (org-export-last-sibling-p headline info)
                    (format "</%s>\n" html-type))))
          ;; Standard headline.  Export it as a section.
          (let ((extra-class
                 (org-element-property :HTML_CONTAINER_CLASS headline))
                (headline-class
                 (org-element-property :HTML_HEADLINE_CLASS headline))
                (first-content (car (org-element-contents headline))))
            (format "<%s id=\"%s\" class=\"%s\">%s%s</%s>\n"
                    (org-html--container headline info)
                    (format "outline-container-%s" id)
                    (concat (format "outline-%d" level)
                            (and extra-class " ")
                            extra-class)
                    (format "\n<h%d id=\"%s\"%s>%s</h%d>\n"
                            level
                            id
                            (if (not headline-class) ""
                              (format " class=\"%s\"" headline-class))
                            (concat
                             (and numberedp
                                  (format
                                   "<span class=\"section-number-%d\">%s</span> "
                                   level
                                   (mapconcat #'number-to-string numbers ".")))
                             formatted-text)
                            level)
                    ;; When there is no section, pretend there is an
                    ;; empty one to get the correct <div
                    ;; class="outline-...> which is needed by
                    ;; `org-info.js'.
                    (if (eq (org-element-type first-content) 'section) contents
                      (concat (org-html-section first-content "" info) contents))
                    (org-html--container headline info)))))))
  )

#+end_src

* SM (linux) mpv prototyping                                           :ATTACH:
:PROPERTIES:
:CREATED:  [2021-01-14 Thu 20:03]
:ID:       d3b44770-6bb2-4675-b451-3f388e0cb6da
:END:

An alternative to scripting with =lua= would be using the =fennel= language.

** TODO Embed fennel in mpv lua module
:PROPERTIES:
:CREATED:  [2021-08-14 Sat 12:34]
:ID:       34ae3659-6881-476b-a132-0a3863ad8064
:END:

https://gitlab.com/technomancy/fennel-mode/-/blob/master/Readme.md
https://fennel-lang.org/setup#embedding-fennel

** mpv input.conf
:PROPERTIES:
:CREATED:  [2021-01-31 Sun 11:17]
:ID:       8c4df6c5-9b2b-4352-a1bc-31a11e4fd1b9
:END:
#+begin_src lua :tangle ~/.config/mpv/input.conf
# mpv keybindings
#
# Location of user-defined bindings: ~/.config/mpv/input.conf
#
# Lines starting with # are comments. Use SHARP to assign the # key.
# Copy this file and uncomment and edit the bindings you want to change.
#
# List of commands and further details: DOCS/man/input.rst
# List of special keys: --input-keylist
# Keybindings testing mode: mpv --input-test --force-window --idle
#
# Use 'ignore' to unbind a key fully (e.g. 'ctrl+a ignore').
#
# Strings need to be quoted and escaped:
#   KEY show-text "This is a single backslash: \\ and a quote: \" !"
#
# You can use modifier-key combinations like Shift+Left or Ctrl+Alt+x with
# the modifiers Shift, Ctrl, Alt and Meta (may not work on the terminal).
#
# The default keybindings are hardcoded into the mpv binary.
# You can disable them completely with: --no-input-default-bindings

# Developer note:
# On compilation, this file is baked into the mpv binary, and all lines are
# uncommented (unless '#' is followed by a space) - thus this file defines the
# default key bindings.

# If this is enabled, treat all the following bindings as default.
#default-bindings start

#MBTN_LEFT     ignore              # don't do anything
#MBTN_LEFT_DBL cycle fullscreen    # toggle fullscreen on/off
#MBTN_RIGHT    cycle pause         # toggle pause on/off
#MBTN_BACK     playlist-prev
#MBTN_FORWARD  playlist-next

# Mouse wheels, touchpad or other input devices that have axes
# if the input devices supports precise scrolling it will also scale the
# numeric value accordingly
#WHEEL_UP      seek 10
#WHEEL_DOWN    seek -10
#WHEEL_LEFT    add volume -2
#WHEEL_RIGHT   add volume 2

## Seek units are in seconds, but note that these are limited by keyframes
RIGHT seek  5
LEFT  seek -5
UP    seek  60
DOWN  seek -60
# Do smaller, always exact (non-keyframe-limited), seeks with Shift.
# Don't show them on the OSD (no-osd).
Shift+RIGHT no-osd seek  1 exact
Shift+LEFT  no-osd seek -1 exact
Shift+UP    no-osd seek  5 exact
Shift+DOWN  no-osd seek -5 exact
# Skip to previous/next subtitle (subject to some restrictions; see manpage)
Ctrl+LEFT   no-osd sub-seek -1
Ctrl+RIGHT  no-osd sub-seek  1
# Adjust timing to previous/next subtitle
Ctrl+Shift+LEFT sub-step -1
Ctrl+Shift+RIGHT sub-step 1
# Move video rectangle
Alt+left  add video-pan-x  0.1
Alt+right add video-pan-x -0.1
Alt+up    add video-pan-y  0.1
Alt+down  add video-pan-y -0.1
# Zoom/unzoom video
Alt++     add video-zoom   0.1
Alt+-     add video-zoom  -0.1
# Reset video zoom/pan settings
#Alt+BS set video-zoom 0 ; set video-pan-x 0 ; set video-pan-y 0
PGUP add chapter 1                     # skip to next chapter
PGDWN add chapter -1                   # skip to previous chapter
#Shift+PGUP seek 600
#Shift+PGDWN seek -600
[ multiply speed 1/1.1                 # scale playback speed
] multiply speed 1.1
{ multiply speed 0.5
} multiply speed 2.0
BS set speed 1.0                       # reset speed to normal
Shift+BS revert-seek                   # undo previous (or marked) seek
Shift+Ctrl+BS revert-seek mark         # mark position for revert-seek
q quit
#Q quit-watch-later
#q {encode} quit 4
ESC set fullscreen no
#ESC {encode} quit 4
#p cycle pause                          # toggle pause/playback mode
. frame-step                           # advance one frame and pause
, frame-back-step                      # go back by one frame and pause
SPACE cycle pause
#> playlist-next                        # skip to next file
#ENTER playlist-next                    # skip to next file
#< playlist-prev                        # skip to previous file
O no-osd cycle-values osd-level 3 1    # cycle through OSD mode
o show-progress
P show-progress
i script-binding stats/display-stats
I script-binding stats/display-stats-toggle
` script-binding console/enable
z add sub-delay -0.1                   # subtract 100 ms delay from subs
Z add sub-delay +0.1                   # add
x add sub-delay +0.1                   # same as previous binding (discouraged)
#ctrl++ add audio-delay 0.100           # this changes audio/video sync
#ctrl+- add audio-delay -0.100
m cycle mute
1 add contrast -1
2 add contrast 1
3 add brightness -1
4 add brightness 1
5 add gamma -1
6 add gamma 1
7 add saturation -1
8 add saturation 1
Alt+0 set window-scale 0.5
Alt+1 set window-scale 1.0
Alt+2 set window-scale 2.0
# toggle deinterlacer (automatically inserts or removes required filter)
d cycle deinterlace
r add sub-pos -1                       # move subtitles up
R add sub-pos +1                       #                down
t add sub-pos +1                       # same as previous binding (discouraged)
v cycle sub-visibility
# stretch SSA/ASS subtitles with anamorphic videos to match historical
V cycle sub-ass-vsfilter-aspect-compat
# switch between applying no style overrides to SSA/ASS subtitles, and
# overriding them almost completely with the normal subtitle style
u cycle-values sub-ass-override "force" "no"
j cycle sub                            # cycle through subtitles
J cycle sub down                       # ...backwards
#SHARP cycle audio                      # switch audio streams
#_ cycle video
#T cycle ontop                          # toggle video window ontop of other windows
f cycle fullscreen                     # toggle fullscreen
s screenshot                           # take a screenshot
S screenshot video                     # ...without subtitles
Ctrl+s screenshot window               # ...with subtitles and OSD, and scaled
Alt+s screenshot each-frame            # automatically screenshot every frame
w add panscan -0.1                     # zoom out with -panscan 0 -fs
W add panscan +0.1                     #      in
e add panscan +0.1                     # same as previous binding (discouraged)
# cycle video aspect ratios; "-1" is the container aspect
A cycle-values video-aspect-override "16:9" "4:3" "2.35:1" "-1"
#POWER quit
#PLAY cycle pause
#PAUSE cycle pause
#PLAYPAUSE cycle pause
#PLAYONLY set pause no
#PAUSEONLY set pause yes
#STOP quit
#FORWARD seek 60
#REWIND seek -60
#NEXT playlist-next
#PREV playlist-prev
#VOLUME_UP add volume 2
#VOLUME_DOWN add volume -2
#MUTE cycle mute
#CLOSE_WIN quit
#CLOSE_WIN {encode} quit 4
#E cycle edition                        # next edition
l ab-loop                              # Set/clear A-B loop points
L cycle-values loop-file "inf" "no"    # toggle infinite looping
#ctrl+c quit 4
DEL script-binding osc/visibility      # cycle OSC display
#ctrl+h cycle-values hwdec "auto" "no"  # cycle hardware decoding
F8 show_text ${playlist}               # show playlist
F9 show_text ${track-list}             # show list of audio/sub streams

#
# Legacy bindings (may or may not be removed in the future)
#
#! add chapter -1                       # skip to previous chapter
#@ add chapter 1                        #         next

#
# Not assigned by default
# (not an exhaustive list of unbound commands)
#

# ? add sub-scale +0.1                  # increase subtitle font size
# ? add sub-scale -0.1                  # decrease subtitle font size
# ? cycle angle                         # switch DVD/Bluray angle
# ? cycle sub-forced-only               # toggle DVD forced subs
# ? cycle program                       # cycle transport stream programs
# ? stop                                # stop playback (quit or enter idle mode)

CTRL+SHIFT+p script-message chapterlist

# g run "home/volk/.config/mpv/scripts/giffer" "${path}" "/home/volk/Videos/${filename/no-ext} ${=ab-loop-a}.gif" "${=ab-loop-a}" "${=ab-loop-b}"
# h run "home/volk/.config/mpv/scripts/giffer" "${path}" "/home/volk/Videos" "${=ab-loop-a}" "${=ab-loop-b}"

#+end_src

* org-brain integration
:PROPERTIES:
:CREATED:  [2021-01-15 Fri 19:51]
:ID:       c53811c9-1ada-4958-9389-5b823a811479
:END:

#+begin_src elisp
(org-brain-open-resource (org-brain-entry-at-pt t))
#+end_src

* org-noter integration
:PROPERTIES:
:CREATED:  [2021-01-19 Tue 16:27]
:ID:       6f30757e-e54b-4e7b-a43f-1443c1090730
:END:

#+begin_src elisp
;;; lang/org-private/+ir.el -*- lexical-binding: t; -*-
#+end_src

This should be a minor mode as is done with [[file:~/.emacs.d/.local/straight/repos/org-noter/org-noter.el::(define-minor-mode org-noter-notes-mode][org-noter]] (note that there are /2/ minor modes).
#+begin_src elisp
;; Key binds etc
(use-package! major-mode-hydra
  :config
  (major-mode-hydra-define pdf-view-mode
    (:title "Incremental Reading Options")
    ("Reading qeue"
     ;; There should a hydra that moves to the next item in the reading que
     (("n" evil-collection-pdf-view-next-line-or-next-page "next")
      ("p" evil-collection-pdf-view-previous-line-or-previous-page "previous"))
     "Test"
     (("s" isearch-forward "search"))
     ;; "Priority"
     ;; Priority setting options
     ;;TODO Should define some functions
     "Drill"
     (("d" nanjigen/org-drill-in-ir-dir "org-drill items")
      ("D" org-drill-resume "Resume last org-drill"))
     )))

  (pretty-hydra-define ir-hydra
    (:color blue :title "Incremental Reading")
    ("Reading que"
     ;; There should a hydra that moves to the next item in the reading que
     (("n" evil-collection-pdf-view-next-line-or-next-page "next")
      ("p" evil-collection-pdf-view-previous-line-or-previous-page "previous"))
     "org-noter"
     (("o" follow-noter-page-link "follow org-pdftools link")
      ;; Should this be a function in a specific workspace?
      ("N" org-noter "Start org-noter session")
      ("S" org-noter-pdftools-create-skeleton "Create org-noter outline"))
     ;; "Priority"
     ;; Priority setting options
     ;;TODO Should define some functions
     "Drill"
     (("d" nanjigen/org-drill-in-ir-dir "org-drill items")
      ("D" org-drill-resume "Resume last org-drill"))
     ))


(map! :localleader
      :map pdf-view-mode-map
          :desc "Insert to Org" "h" 'nanjigen/org-noter-highlight-drill)

#+end_src

The below function is an addition to [[file:~/.emacs.d/.local/straight/repos/org-noter/org-noter.el::defun org-noter-insert-note-toggle-no-questions (][org-noter-insert-note-no-questions]], possibly to insure that the ~org-pdftools~ link gets inserted correctly.
#+begin_src elisp
  ;; Add a function to ensure precise note is inserted
  (defun org-noter-pdftools-insert-precise-note (&optional toggle-no-questions)
    (interactive "P")
    (org-noter--with-valid-session
     (let ((org-noter-insert-note-no-questions (if toggle-no-questions
                                                   (not org-noter-insert-note-no-questions)
                                                 org-noter-insert-note-no-questions))
           (org-pdftools-use-isearch-link t)
           (org-pdftools-use-freestyle-annot t))
       (org-noter-insert-note (org-noter--get-precise-info)))))

#+end_src

We want items inserted with the following syntax:
#+begin_example org-mode
,** [[cite:laufer2001][10]] annot-2-0 | descriptive text                  :extract:
#+end_example

The =:extract:= tag will allow us to target those inserted headers with ~elisp~ code, and differentiate extraction headers from skeleton entries. The =cite:= syntax activates ~org-ref~ functions which may be used programmatically down the line. The "annot-2-0" is a reference to the ~org-pdftools~ link syntax -
(:NOTER_PAGE: [[pdf:~/Documents/PDF/laufer2001.pdf::2++0.00;;annot-2-0]] in this case).
The first numeral, 2, is a reference to the internal page number of the source pdf. With some text-munging we can procure the page number of the pdf for the given extract and potentially insert that into an org-buffer when writing to aid with citing: [[cite:laufer2001][2]].

#+begin_src elisp
(org-ref-insert-link nil)
(funcall org-ref-insert-cite-function)
(defun nanjigen/org-pdftools-annot-id ()
  "get 'annot' id from 'NOTER_PAGE' property"
  (interactive)
  (let* ((id (car (last (s-split ";;" (org-entry-get nil "NOTER_PAGE")))))
         (id-clean (s-chop-suffix "]]" id)))
    (insert (format "%s" id-clean))))

(org-toggle-tag "extract")
#+end_src

#+begin_src elisp
(when (and org-noter-insert-selected-text-inside-note selected-text) (insert (concat "#+begin_quote\n" selected-text "\n#+end_quote")))

(defun org-noter-insert-note-content ()
  (interactive)
  (progn (setq currenb (buffer-name))
         (set-buffer currenb)
         (org-noter-insert-note)
         ;; (org-noter-quote)
))

(fset 'org-noter-quote
      (kmacro-lambda-form [?  ?: ?j ?o ?i ?n ?e ?  backspace backspace return ?V ?  ?i ?s ?q ?u ?o ?t ?e return escape ?\{ ?\{ ?d ?d] 0 "%d"))

(setq org-noter-default-heading-title )
#+end_src

#+begin_src elisp
(defun org-noter-insert-selected-text-as-content (&optional precise-info)
  "Insert note associated with the current location.

This command will prompt for a title of the note and then insert
it in the notes buffer. When the input is empty, a title based on
`org-noter-default-heading-title' will be generated.

If there are other notes related to the current location, the
prompt will also suggest them. Depending on the value of the
variable `org-noter-closest-tipping-point', it may also
suggest the closest previous note.

PRECISE-INFO makes the new note associated with a more
specific location (see `org-noter-insert-precise-note' for more
info).

When you insert into an existing note and have text selected on
the document buffer, the variable `org-noter-insert-selected-text-inside-note'
defines if the text should be inserted inside the note."
  (interactive)
  (org-noter--with-valid-session
   (let* ((ast (org-noter--parse-root)) (contents (org-element-contents ast))
          (window (org-noter--get-notes-window 'force))
          (selected-text
           (cond
            ((eq (org-noter--session-doc-mode session) 'pdf-view-mode)
             (when (pdf-view-active-region-p)
               (mapconcat 'identity (pdf-view-active-region-text) ? )))

            ((eq (org-noter--session-doc-mode session) 'nov-mode)
             (when (region-active-p)
               (buffer-substring-no-properties (mark) (point))))))
          force-new
          (location (org-noter--doc-approx-location (or precise-info 'interactive) (gv-ref force-new)))
          (view-info (org-noter--get-view-info (org-noter--get-current-view) location)))

     (let ((inhibit-quit t))
       (with-local-quit
         (select-frame-set-input-focus (window-frame window))
         (select-window window)

         ;; IMPORTANT(nox): Need to be careful changing the next part, it is a bit
         ;; complicated to get it right...

         (let ((point (point))
               (minibuffer-local-completion-map org-noter--completing-read-keymap)
               collection default default-begin title selection
               (empty-lines-number (if org-noter-separate-notes-from-heading 2 1)))

           (cond
            ;; NOTE(nox): Both precise and without questions will create new notes
            ((or precise-info force-new)
             (setq default (and selected-text (replace-regexp-in-string "\n" " " selected-text))))
            (org-noter-insert-note-no-questions)
            (t
             (dolist (note-cons (org-noter--view-info-notes view-info))
               (let ((display (org-element-property :raw-value (car note-cons)))
                     (begin (org-element-property :begin (car note-cons))))
                 (push (cons display note-cons) collection)
                 (when (and (>= point begin) (> begin (or default-begin 0)))
                   (setq default display
                         default-begin begin))))))

           (setq collection (nreverse collection)
                 title (if org-noter-insert-note-no-questions
                           default
                         (completing-read "Note: " collection nil nil nil nil default))
                 selection (unless org-noter-insert-note-no-questions (cdr (assoc title collection))))


             ;; NOTE(nox): Inserting a new note
             (let ((reference-element-cons (org-noter--view-info-reference-for-insertion view-info))
                   level)
                 (setq title "test")
                 ;; (setq title (replace-regexp-in-string (regexp-quote "$p$") (number-to-string (car location))
                 ;;                                       org-noter-default-heading-title))

           (org-show-set-visibility t)
           (org-cycle-hide-drawers 'all)
           (org-cycle-show-empty-lines t)))
       (when quit-flag
         ;; NOTE(nox): If this runs, it means the user quitted while creating a note, so
         ;; revert to the previous window.
         (select-frame-set-input-focus (org-noter--session-frame session))
         (select-window (get-buffer-window (org-noter--session-doc-buffer session)))))))))
#+end_src

#+name: selected text to content
#+begin_src elisp
(defun org-noter-insert-selected-text-as-content (&optional precise-info)
  "Insert note associated with the current location.

This command will prompt for a title of the note and then insert
it in the notes buffer. When the input is empty, a title based on
`org-noter-default-heading-title' will be generated.

If there are other notes related to the current location, the
prompt will also suggest them. Depending on the value of the
variable `org-noter-closest-tipping-point', it may also
suggest the closest previous note.

PRECISE-INFO makes the new note associated with a more
specific location (see `org-noter-insert-precise-note' for more
info).

When you insert into an existing note and have text selected on
the document buffer, the variable `org-noter-insert-selected-text-inside-note'
defines if the text should be inserted inside the note."
  (interactive)
  (org-noter--with-valid-session
   (let* ((ast (org-noter--parse-root)) (contents (org-element-contents ast))
          (window (org-noter--get-notes-window 'force))
          (selected-text
           (cond
            ((eq (org-noter--session-doc-mode session) 'pdf-view-mode)
             (when (pdf-view-active-region-p)
               (mapconcat 'identity (pdf-view-active-region-text) ? )))

            ((eq (org-noter--session-doc-mode session) 'nov-mode)
             (when (region-active-p)
               (buffer-substring-no-properties (mark) (point))))))
          force-new
          (location (org-noter--doc-approx-location (or precise-info 'interactive) (gv-ref force-new)))
          (view-info (org-noter--get-view-info (org-noter--get-current-view) location)))

     (let ((inhibit-quit t))
       (with-local-quit
         (select-frame-set-input-focus (window-frame window))
         (select-window window)

         ;; IMPORTANT(nox): Need to be careful changing the next part, it is a bit
         ;; complicated to get it right...

         (let ((point (point))
               (minibuffer-local-completion-map org-noter--completing-read-keymap)
               collection default default-begin title selection
               (empty-lines-number (if org-noter-separate-notes-from-heading 2 1)))

           (cond
            ;; NOTE(nox): Both precise and without questions will create new notes
            ((or precise-info force-new)
             (setq default (and selected-text (replace-regexp-in-string "\n" " " selected-text))))
            (org-noter-insert-note-no-questions)
            (t
             (dolist (note-cons (org-noter--view-info-notes view-info))
               (let ((display (org-element-property :raw-value (car note-cons)))
                     (begin (org-element-property :begin (car note-cons))))
                 (push (cons display note-cons) collection)
                 (when (and (>= point begin) (> begin (or default-begin 0)))
                   (setq default display
                         default-begin begin))))))

           (setq collection (nreverse collection)
                 title (if org-noter-insert-note-no-questions
                           default
                         (completing-read "Note: " collection nil nil nil nil default))
                 selection (unless org-noter-insert-note-no-questions (cdr (assoc title collection))))

           (if selection
               ;; NOTE(nox): Inserting on an existing note

               (let* ((note (car selection))
                      (insert-before-element (cdr selection))
                      (has-content
                       (eq (org-element-map (org-element-contents note) org-element-all-elements
                             (lambda (element)
                               (if (org-noter--check-location-property element)
                                   'stop
                                 (not (memq (org-element-type element) '(section property-drawer)))))
                             nil t)
                           t)))
                 (when has-content (setq empty-lines-number 2))
                 (if insert-before-element
                     (goto-char (org-element-property :begin insert-before-element))
                   (goto-char (org-element-property :end note)))


                 (if (org-at-heading-p)
                     (progn
                       (org-N-empty-lines-before-current empty-lines-number)
                       (forward-line -1))
                   (unless (bolp) (insert "\n"))
                   (org-N-empty-lines-before-current (1- empty-lines-number)))

                 (when (and org-noter-insert-selected-text-inside-note selected-text) (insert selected-text)))
                 ;; (insert selected-text))

             ;; NOTE(nox): Inserting a new note
             (let ((reference-element-cons (org-noter--view-info-reference-for-insertion view-info))
                   level)
               (when (zerop (length title))
                 (setq title (replace-regexp-in-string (regexp-quote "$p$") (number-to-string (car location))
                                                       org-noter-default-heading-title)))

               (if reference-element-cons
                   (progn
                     (cond
                      ((eq (car reference-element-cons) 'before)
                       (goto-char (org-element-property :begin (cdr reference-element-cons))))
                      ((eq (car reference-element-cons) 'after)
                       (goto-char (org-element-property :end (cdr reference-element-cons)))))

                     ;; NOTE(nox): This is here to make the automatic "should insert blank" work better.
                     (when (org-at-heading-p) (backward-char))

                     (setq level (org-element-property :level (cdr reference-element-cons))))

                 (goto-char (org-element-map contents 'section
                              (lambda (section) (org-element-property :end section))
                              nil t org-element-all-elements))
                 (setq level (1+ (org-element-property :level ast))))

               ;; NOTE(nox): This is needed to insert in the right place
               (outline-show-entry)
               (org-noter--insert-heading level title empty-lines-number location)
               (when (org-noter--session-hide-other session) (org-overview))

               (setf (org-noter--session-num-notes-in-view session)
                     (1+ (org-noter--session-num-notes-in-view session)))))

           (org-show-set-visibility t)
           (org-cycle-hide-drawers 'all)
           (org-cycle-show-empty-lines t)))
       (when quit-flag
         ;; NOTE(nox): If this runs, it means the user quitted while creating a note, so
         ;; revert to the previous windo.
         (select-frame-set-input-focus (org-noter--session-frame session))
         (select-window (get-buffer-window (org-noter--session-doc-buffer session))))))))
#+end_src

** old org-noter code                                                :extract:
:PROPERTIES:
:CREATED:  [2021-01-19 Tue 17:18]
:ID:       52a04c78-0f21-46af-80af-18a43cbea9f4
:header-args: :tangle ~/.doom.d/modules/lang/org-private/+ir.el :noweb yes
:END:

#+begin_src elisp
;;; lang/org-private/+ir.el -*- lexical-binding: t; -*-
#+end_src

The actual function to extract to point
#+begin_src elisp
(defun nanjigen/org-noter-extract ()
  "Extract highlighted text into org-noter buffer as org-drill item"
  (interactive)
  ;; (org-back-to-heading)
  (save-window-excursion
  ;; Now I need to move the header text (which is the extracted pdf text) into the body
    (progn
      (nanjigen/move-headline-to-contents)
      (org-toggle-tag "extract"))))
#+end_src

#+begin_src elisp
(defun nanjigen/open-link-clipboard ()
  (interactive)
  (let ((link (substring-no-properties (x-get-selection 'CLIPBOARD 'STRING))))
    (org-link-open-from-string link)))

;; (org-noter "[[pdf:/home/vrika/Documents/PDF/books/wickedcoolshellscripts.pdf::1]]")
;; (org-brain-open-org-noter "3f0bea0e-07dd-4e48-9df7-aaeb8f1d3b8d")
#+end_src

#+RESULTS:
: nanjigen/open-link-clipboard

This is a fairly ugly hack. My ultimate intention is to use modified org-noter code.
#+begin_src elisp
(defun nanjigen/move-headline-to-contents ()
  "Move extracted PDF text to body of subtree"
  (interactive)
  ;; (let ((origin-element-type (org-element-type (org-element-at-point))))
  ;;   (if (string-equal "property-drawer" origin-element-type)
  ;;       (evil-insert-newline-below)))
  (progn
    ;; (with-selected-window (org-noter--get-notes-window)
    ;;   (evil-insert-newline-below))
    (org-noter-insert-note-toggle-no-questions)
    (org-back-to-heading)
    (org-toggle-tag "extract")
    (let* ((parent
            (save-excursion
              (org-backward-element)
              (org-element-property :title (org-element-at-point))))
           (headline (org-element-at-point))
           (title (org-element-property :title headline))
           (property-end (org-element-property :contents-end headline))
           ;; (property (org-element-at-point (goto-char property-pos)))
           (indent (org-element-property :level headline))
           (title-start (+ indent (org-element-property :begin headline)))
           (title-end (- (org-element-property :contents-begin headline) 1))
           (annot-id (car (last (s-split ";;" (org-entry-get nil "NOTER_PAGE")))))
           (annot-id-clean (s-chop-suffix "]]" annot-id))
           (org-uuid (org-entry-get nil "ID"))
           (annot-link (format "[[brain:%s][%s]]" org-uuid annot-id-clean))
           (cite-page (with-selected-window (org-noter--get-doc-window)
                        (format "%s"
                                (eval '(nth (1- (pdf-view-current-page))
                                            (pdf-cache-pagelabels))))))
           (cite (file-name-sans-extension (file-name-nondirectory (buffer-file-name)))))
      ;; (when (eq 'property-drawer (car property))
      ;; (goto-char (org-element-property :end property)))
      (goto-char property-end)
      (insert title)
      (delete-region title-start title-end)
      (goto-char title-start)
      ;;HACK use logic to identify if parent is an org-noter-outline headline
      ;; and then indent with org-mode code, not a hacky *!
      (insert (format " [[cite:%s][p%s]] %s" cite cite-page annot-link))
      ;; (save-excursion
        ;; (if (not (string-prefix-p "cite" parent))
        ;;     ;; (nanjigen/org-move-to-sibling)
        ;;     (nanjigen/org-move-to-extreme)
        ;;   )
      ;;
      ;;     (insert (format " cite:%s %s" cite id-clean))
      ;;   (insert (format "* cite:%s %s" cite id-clean)))
      (org-back-to-heading))))
#+end_src

#+RESULTS:
: nanjigen/move-headline-to-contents

Attempting to move to max point in tree from https://emacs.stackexchange.com/questions/43651/moving-a-subtree-to-the-top-or-bottom-of-its-parent/43662#43662
#+begin_src elisp
(defun nanjigen/org-move-to-extreme ()
  "Move current org subtree to the start of its parent."
  (interactive)
  (condition-case err
      (while t
        (funcall 'org-move-subtree-up)))
    (user-error
     (let ((err-msg (cadr err)))
       (unless (string-match "Cannot move past superior level or buffer limit" err-msg)
         (signal 'user-error (list err-msg))))))
#+end_src

#+begin_src elisp
(defun nanjigen/org-move-to-sibling ()
  "Move extracted org subtree under its 'cite:' sibling."
  (interactive)
  (setq parent (nanjigen/org-get-above-headline))
  (while (not (string-prefix-p "cite" parent))
     (funcall 'org-move-subtree-up)
     (setq parent (nanjigen/org-get-above-headline))))
#+end_src

#+begin_src elisp
(defun nanjigen/org-get-above-headline ()
"Get the headline entry of above parent/sibling as text"
(save-excursion
  (org-backward-element)
  (org-element-property :title (org-element-at-point))))
#+end_src

#+RESULTS:
: JK-org-move-to-extreme

#+begin_src elisp
(defun nanjigen/chopper ()
  "get 'annot' id from 'NOTER_PAGE' property"
  (interactive)
  (let* ((id (car (last (s-split ";;" (org-entry-get nil "NOTER_PAGE")))))
         (id-clean (s-chop-suffix "]]" id)))
    (insert (format "%s" id-clean))))

(defun nanjigen/delete-headline ()
  "delete the original title of text extracted with
(org-noter-insert-note-toggle-no-questions)"
  (interactive)
  (let* ((headline (org-element-at-point))
         (title-start (org-element-property :contents-begin headline))
         (title-end (org-element-property :end headline)))
    (delete-region title-start title-end)))

;; Functions for capturing from org noter
  (defun nanjigen/get-noter-link ()
    "return PROPERTY value of pdftools link"
    (interactive)
    (let ((linkStr (org-entry-get nil "NOTER_PAGE")))
      (insert linkStr)))

  ;;https://emacs.stackexchange.com/questions/32283/how-to-capture-and-link-code-comments-as-org-agenda-items
  (defun capture-noter-link ()
    "insert PROPERTY value of pdftools link"
    (interactive)
    (let ((linkStr
            (save-excursion
              (save-window-excursion
                (switch-to-buffer (plist-get org-capture-plist :original-buffer))
                (car (org-get-outline-path)))
              )))
      ))


  (defun insert-key (&optional p)
    "insert header as key value of org-brain header"
    ;; (unless p (setq p "NOTER_PAGE"))
    ;; (message "property passed is: %s" p)
    (interactive)
    (let ((pvalue
            (save-window-excursion
              (message "%s" (org-capture-get :original-buffer))
              (switch-to-buffer (org-capture-get :original-buffer))
              (message "retrieved header (key) is: %s" (car (org-get-outline-path (point) p)))
              (car (org-get-outline-path (point) p))
              )))
      pvalue))


  (defun key-to-header (&optional p)
    "insert header in org-capture target file as key value of org-brain header"
    ;; (unless p (setq p "NOTER_PAGE"))
    ;; (message "property passed is: %s" p)
    (interactive)
    (let ((heading
            (save-window-excursion
              (message "%s" (org-capture-get :original-buffer))
              (switch-to-buffer (org-capture-get :original-buffer))
              (message "retrieved header (key) is: %s" (car (org-get-outline-path (point) p)))
              (car (org-get-outline-path (point) p))
              )))
      (goto-char (org-find-exact-headline-in-buffer "IR Cards"))
      (unless (search-forward (format "** %s" heading) nil t)
        (org-end-of-subtree)
        (insert (format "\n** %s" heading))
        )))

  (defun insert-property (&optional p)
    "insert PROPERTY value of pdftools link"
    (interactive)
    (unless p (setq p "NOTER_PAGE"))
    (message "property passed is: %s" p)
    (let ((pvalue
            (save-window-excursion
              (message "%s" (org-capture-get :original-buffer))
              (switch-to-buffer (org-capture-get :original-buffer))
              (message "retrieved property is: %s" (org-entry-get (point) p))
              (org-entry-get (point) p)
              )))
      pvalue))

  (defun follow-noter-page-link ()
    "return PROPERTY value of pdftools link and follow in other-window"
    (interactive)
    ;; (run-with-timer 3 nil (lambda ()
      ;; TODO switch-to-buffer?
    (let ((linkStr (org-entry-get nil "NOTER_PAGE")))
      (if (> (length (window-list)) 1)
          (other-window 1)
        ;; (balance-windows)
          ;; (switch-to-buffer-other-window)
        (split-window-right))
      (org-link-open-from-string linkStr)))
;;
#+end_src

** TODO Automatic screenshots in org-noter with Flameshot
:PROPERTIES:
:CREATED:  [2021-06-02 Wed 17:04]
:ID:       1b6ec7b5-1957-4b53-ad71-1f58f2b99fac
:END:

#+begin_src elisp
(use-package! org-download
  :config
  (setq org-download-method 'attach))

(defun org-noter-insert-image-slice-note ()
  (interactive)
  (async-start (shell-command "flameshot gui")
               (progn
                 (switch-to-buffer-other-window
                  (window-buffer (org-noter--get-notes-window)))
                 ;; (defmacro org-noter--with-selected-notes-window ...)
                 (async-start (org-noter-insert-note)
                              (org-download-clipboard)))))

(define-key org-noter-doc-mode-map (kbd "Y") 'org-noter-insert-image-slice-note)
#+end_src

** old org-drill code
:PROPERTIES:
:CREATED:  [2021-01-20 Wed 13:58]
:ID:       7a12e649-f742-443e-bf42-6de953eb9752
:END:
#+begin_src elisp
;; This is to initiate drill from anywhere
;; Have next PDF fire off instead if all done?
(defun nanjigen/org-drill-in-ir-dir ()
  (interactive)
  (with-current-buffer (find-file-noselect "~/org/article-notes/article-index.org")
    (org-drill)))


;; (advice-add 'org-drill-reschedule :after-until #'follow-noter-page-link)
;; (advice-add 'org-drill-entry-p :after #'follow-noter-page-link)
;; (advice-add '(org-drill-entries (session-done)) :after #'follow-noter-page-link)
;; (advice-add 'org-drill-goto-entry :after #'follow-noter-page-link)
;; (advice-add 'org-drill-present-simple-card :after #'follow-noter-page-link)
;; (advice-add 'org-drill-present-default-answer :after #'follow-noter-page-link)
;; (advice-add 'org-drill-present-two-sided-card :after #'follow-noter-page-link)
;; (advice-add 'org-drill--edit-key :after #'follow-noter-page-link)
;; (advice-add 'org-drill-response-complete-rtn :after #'follow-noter-page-link)
;; (advice-add 'org-drill-response-complete :after #'follow-noter-page-link)
;; (advice-add 'org-drill-response-quit  :after #'follow-noter-page-link)
;; (add-function :after ('org-drill-response-edit) #'follow-noter-page-link)
;; (advice-add 'org-drill-response-complete :after #'follow-noter-page-link)
(advice-add 'org-drill-response-edit :after #'follow-noter-page-link)
(advice-add 'org-drill-response-edit :after-while #'follow-noter-page-link)
(advice-add 'org-drill-response-quit  :after #'follow-noter-page-link)
;; (advice-add 'org-drill--edit-key :after #'follow-noter-page-link)


;; This triggers the function but not at the right time
;; (add-hook 'org-drill-display-answer-hook #'follow-noter-page-link)
#+end_src
* SM in a VM and RPC
:PROPERTIES:
:CREATED:  [2020-12-11 Fri 21:15]
:ID:       fafd87f0-c7c8-467d-861c-d0fc634d9893
:END:

* AHK
:PROPERTIES:
:CREATED:  [2020-11-30 Mon 17:08]
:ID:       8d766356-bb00-4536-8974-6906b6c2837f
:END:

A good guide for ahk under linux https://code.google.com/archive/p/winetricks/wikis/AutoHotkey.wiki
#+begin_src ahk :tangle ~/.scripts/ahk/activate.verb :mkdirp yes
w_metadata activate apps \
title="Hello, Autohotkey"

load_activate()
{
w_ahk_do "
;WinActivate, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
run, notepad.exe
WinWait, Untitled - Notepad
;ControlSend, lol, Test, ahk_class TElWind
;ControlSend, Test2, {v}, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
;j::
;WinActivate, ahk_exe sm18.exe
;WinGetActiveTitle, Title
;WinGetClass, Var, A
;MsgBox ahk_class %Var%
;MsgBox, The active window is "%Title%".
send, l
;return
"
}
#+end_src

Finding the class of a window
#+begin_src ahk :tangle ~/.scripts/ahk/class.verb :mkdirp yes
w_metadata class apps \
title="Hello, Autohotkey"

load_class()
{
w_ahk_do "
j::
;WinActivate, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
;WinActivate, ahk_class sm18.exe
WinGetActiveTitle, Var
;WinGetClass, Var, A
;ControlGet, Var, A
;MsgBox ahk_class %Var%
MsgBox, The active window is "%Var%".
;send, l
return
"
}
#+end_src

Testing some sending code
#+begin_src ahk :tangle ~/.scripts/ahk/send.verb :mkdirp yes
w_metadata send apps \
title="Hello, Autohotkey"

load_send()
{
w_ahk_do "
;j::
;WinActivate, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
;#IfWinActive, ahk_class, Notepad
;ControlSend, Edit1, Test, WinTitle, Untitled - Notepad
;ControlSend, Edit1, Test, Untitled - Notepad
ControlSend, Edit1, Test, home
;WinGetActiveTitle, Var
;WinGetClass, Var, A
;MsgBox ahk_class %Var%
;MsgBox, The active window is "%Var%".
;send, l
;return
"
}
#+end_src

This works well for copying the element path
#+begin_src ahk :tangle ~/.scripts/ahk/senda.verb :mkdirp yes
w_metadata senda apps \
title="Hello, Autohotkey"

load_senda()
{
w_ahk_do "
#NoEnv  ; Recommended for performance and compatibility with future AutoHotkey releases.
; #Warn  ; Enable warnings to assist with detecting common errors.
SendMode Input  ; Recommended for new scripts due to its superior speed and reliability.
;SetWorkingDir %A_ScriptDir%  ; Ensures a consistent starting directory.
SetTitleMatchMode,2
;WinActivate, ahk_exe sm18.exe
;WinWaitActive, ahk_exe sm18.exe
;WinActivate, ahk_class TElWind
;WinWaitActive, WinTitle Untitled - Notepad
#IfWinActive, ahk_class TElWind

::sm-get-path::
send, +{F10}
;sleep,5
send, f
;sleep,5
send, c
;send, ^a
"
}
#+end_src
z:\\home\\vrika\\documents\\sm\\neuron\\elements\\16\\168.HTM
z:\home\vrika\documents\sm\neuron\elements\16\168.HTM
file:/home/vrika/Documents/SM/neuron/elements/16/167.HTM

Change windows path to unix:

#+begin_src elisp
;; (defun my-translate-winpath ()
  ;; (interactive)
  ;; "change :C\win\path to 'nix /path/path"
  (let ((path (current-kill 0 'do-not-move)))
    (shell-command-to-string (format "~/.scripts/winpath.sh %s" path)))
#+end_src

#+begin_src elisp
(defun my-translate-winpath ()
  (interactive)
  (progn
  ;; (shell-command "sh ~/.scripts/xdotool/get_element_path.sh")
  (shell-command "xclip -sel clip -o")
  (shell-command "xdotool sleep 0.2 key --delay 50 Shift+F10+f+c")
;; (gui--selection-value-internal 'CLIPBOARD)
  (setq sm-path (gui--selection-value-internal 'CLIPBOARD))
    (let* ((path1 (s-chop-prefix "z:" sm-path))
           (nixpath (s-replace "\\" "/" path1))
           (docpath (s-replace "documents" "Documents" nixpath))
           (finpath (s-replace "sm" "SM" docpath)))
      (setq sm-path-nix finpath))))
;; (list path path2)
;; (shell-command-to-string (format "~/.scripts/winpath.sh" ))
#+end_src

#+RESULTS:
: my-translate-winpath

#+begin_src elisp
(defun exwm-sm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
  (my-exwm-send-string "sm-get-path ")
  (sit-for 0.3)
  (let ((path (my-translate-winpath)))
    (find-file path)))
#+end_src

#+RESULTS:
: my-translate-winpath

#+begin_src elisp
(defun my-exwm-send-string (string)
  "Send STRING to `exwm-mode' buffer or just insert it."
  (if (eq major-mode 'exwm-mode)
      (mapc #'exwm-input--fake-key (string-to-list string))
    (insert string)))
#+end_src
z:\home\vrika\documents\sm\neuron\elements\5.HTM
#+RESULTS:
: my-exwm-send-string

#+begin_src elisp
;; (subst-char-in-string ?\ ?/ (regexp-quote "\home"))
;; (regexp-quote "^home")
;; (convert-standard-filename "z:\home\vrika\documents\sm\neuron\elements\16\168.HTM")
;; (setq windows-path (unescape-windows-path "\home\vrika"))

;; (setq windows-path1 "\home\vrika")
;; (wsl-path-convert-file-name "\home\vrika")
;; (s-replace "\\" "/" "\home")
;; (s-replace "\\" "/" windows-path)
;; (replace-regexp-in-string "\\\\" "\\\\\\\\" "\home\vrika")
;; (message windows-path1)
;; (defun unescape-windows-path (pth)
;;   ;; (interactive "*sWindows path:")
;;    (replace-regexp-in-string "\\\\" "\\\\\\\\" pth))

;; (defun paste-windows-path (pth)
;;   (interactive "*sWindows path:")
;;   (insert
;;    (replace-regexp-in-string "\\\\" "\\\\\\\\" pth)))
;; (message (current-kill 0 'do-not-move))
;; (shell-command-to-string "sed -e 's#^J:##' -e 's#\\#/#g' <<< 'test'")

(convert-standard-filename "~/Documents")
#+end_src

#+RESULTS:
: ~/Documents

#+begin_src sh :tangle ~/.scripts/winpath.sh
function winpath(){
    line=$(sed -e 's#^J:##' -e 's#\\#/#g' <<< "$1")
    echo "$line"
}
#+end_src

#+begin_src sh
#!/bin/bash
clip=$(xclip -selection c -o)
line=$(sed -e 's#^z:##' -e 's#\\#/#g' <<< "$clip")
echo "$line"
#+end_src

#+RESULTS:

#+begin_src ahk :tangle ~/.scripts/ahk/hotstring.verb :mkdirp yes
w_metadata hotstring apps \
title="Hello, Autohotkey"

load_hotstring()
{
w_ahk_do "
:*:get::get it boi
"
}
#+end_src

#+begin_src sh :dir ~/.scripts/ahk/ :session test
env WINEPREFIX=/home/vrika/.local/share/wineprefixes/supermemo18 winetricks activate.verb
#+end_src

#+RESULTS:
|                                              |               |                       |                                     |            |                                                                  |        |          |     |                |
| Executing                                    | mkdir         | -p                    | /home/vrika/.local/share/wineprefixes |            |                                                                  |        |          |     |                |
| Using                                        | winetricks    | 20200412              | -                                   | sha256sum: | 40ff4c67804584b73d4d36153e1f64ca426d739f1790bd748f5ded0865e8cc7f | with   | wine-5.2 | and | WINEARCH=win32 |
| Executing                                    | w_do_call     | activate              |                                     |            |                                                                  |        |          |     |                |
| Executing                                    | mkdir         | -p                    | /home/vrika/.local/share/wineprefixes |            |                                                                  |        |          |     |                |
| Executing                                    | load_activate |                       |                                     |            |                                                                  |        |          |     |                |
| Executing                                    | wine          | x:\ahk\AutoHotkey.exe | C:\windows\Temp\activate.ahk        |            |                                                                  |        |          |     |                |
| 00b9:fixme:keyboard:X11DRV_GetKeyboardLayout | couldn't      | return                | keyboard                            | layout     | for                                                              | thread |       81 |     |                |

** Snippet
:PROPERTIES:
:CREATED:  [2020-12-01 Tue 22:38]
:ID:       e177ba0d-cfc1-41d7-bc09-4b2e3a1edef9
:END:

#+begin_src yas
# -*- mode: snippet -*-
# name: SuperMemo Ref
# key: sm-ref
# --

#SuperMemo Reference:
#Title: (org-web-tools--html-title (org-web-tools--get-first-url))
#Date: Imported on Oct 15, 2020, 18:50:29
#Source: Wikipedia
#Link: (org-web-tools--get-first-url)
#Comment: Lisp (programming language)
#Parent: 17: Programming
#Concept group: Root: neuron (1: neuron)
#+end_src
