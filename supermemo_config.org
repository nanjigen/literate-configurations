#+BRAIN_PARENTS: system
#+TITLE: Supermemo configuration
#+auto_tangle: t

This is my literate config detailing the installation and management of Supermemo under Wine - interfaced via Emacs.

Features:

- Automated installation of SM18 under Wine (mostly via supermemo-wine)
- Emacs integration by the following means:
  + Emacs and EXWM x-window/buffer management
    - Reliable named buffers navigateable through EXWM
    - =display-buffer-alist= rules for SM windows; allows for window arrangement
    - Burly bookmarking of SM views
  + Text-streams via =exwm-input--fake-key= (utilizing ~Autohotkey~ as a backend) allowing for
    - vIM-style modal bindings with NORMAL and INPUT modes (EXWM).
    - Access to SM interface options as hydra-menus.
    - Item element editing in org buffers, with all markup converted back to HTML.

- Bridging functions between SMA, SM, and Emacs creating possibilities for:
  + Helm fuzzy lookup of elements based on their element-id
  + Org-mode card building, much like [[https://github.com/louietan/anki-editor][anki-editor]]
  + *Incremental video via mpv*, allowing for ~lua~ script based generation of gifs, extractions of subs.
  + *Incremental writing of email with ~mu4e~!*
  + *Incremental literate programming* with org-mode and SM's algorithm!


* Installation
:PROPERTIES:
:CREATED:  [2020-11-19 Thu 22:48]
:ID:       c5e3d6cf-81c6-47cf-9bf3-eff77b6a5270
:END:
This guide is meant as a 0-to-working playbook. Parts of it tangle to scripts and Elisp config files that may be opinionated and platform specific. One day it might exist as a Melpa package but for now should be treated as a walk-through.

The first hurdle is getting a working installation of SM18.
We'll be using allesivs [[https://github.com/alessivs/supermemo-wine][supermemo-wine]] .verb for the installation of SM18.

Cloning in the verbs:
#+begin_src sh
cd ~/Templates/sm
git clone https://github.com/alessivs/supermemo-wine.git
#+end_src

Make sure we have the correct wine version: https://dl.winehq.org/wine/source/5.x/

#+begin_src sh
wine --version
#+end_src

#+RESULTS:
: wine-5.2

#+begin_src sh :mkdirp yes :results silent
cd ~/Templates/sm/
curl -O https://dl.winehq.org/wine/source/5.x/wine-5.2.tar.xz
#+end_src

After installation of (the [[https://github.com/Winetricks/winetricks/issues/1593][correct]] version) Wine and Winetricks we can setup the =wineprefix= and install.
Something about the ~:dir sudo~ syntax isn't working
#+begin_src sh :dir /sudo::/vrika
cd ~/Templates/sm/
tar -xf wine-5.2.tar.xz
cd /wine-5.2
./configure
make
sudo make install
#+end_src

#+begin_src sh
env WINEARCH=win32 sh winetricks arch=32 prefix=supermemo18
sh winetricks prefix=supermemo18 ~/Templates/sm/supermemo-wine/verbs/supermemo18.verb
#+end_src

#+RESULTS:

* Setup SM window management
:PROPERTIES:
:CREATED:  [2020-10-09 Fri 18:15]
:ID:       5f96c370-eb26-4117-a7d8-43793e465c9d
:END:
By identifying and naming different SuperMemo window buffers, we can have a reliable way to target those buffers with text streams. Specifically, we can target a buffer with a simulated keypress, affording us a kind of poor-man's API by way of scripting window movement and key-chords in an orchistrated way.

** Capturing buffers
:PROPERTIES:
:CREATED:  [2020-11-20 Fri 10:39]
:ID:       8cf89b9a-bdb4-41a4-a3a9-4343be5c0ee6
:END:

A quirk of using SM under Wine is that a virtual desktop

We want to capture the following buffer titles with a regex so that we can move:
a. The Knowledge tree to the left of the screen.
b. The tray to the bottom, but not spanning the whole width of the screen.
c. Have the review buffer as the main window.
d. Have all other SM related windows as floating frames centered on the screen.

We'll use [[info:elisp#Rx][rx]] to handle the notation.

Example of the kinds of text we'll need to capture:
#+begin_example:
Topic #10:
Element #9:
OR
Element
sm18.exe/Second Language
#+end_example:

We can test if our regex captures this

#+name: element-window-rx
#+begin_src elisp
(rx bol "home" eol)
#+end_src

#+RESULTS: element-window-rx
: ^home$

#+begin_src elisp :noweb yes
(seq-filter (lambda (buf)
              (string-match-p
               <<element-window-rx>>
               (buffer-name buf)))
            (buffer-list))
#+end_src

#+RESULTS:

lol
#+begin_src elisp :noweb yes
(add-hook 'exwm-update-title-hook
          (defun sm-element-test-class-hook ()
            (when (string-match "Mousepad" exwm-class-name)
              (exwm-workspace-rename-buffer exwm-title))))
#+end_src

#+RESULTS:
| sm-element-test-class-hook | my-exwm-update-title-hook |

#+NAME: element-data-rx
#+begin_src elisp
(rx (| (seq (or "Topic" "Element") space "#" (one-or-more digit) ":") (seq "Element data")))
#+end_src

#+RESULTS: element-data-rx
: \(?:Element\|Topic\)[[:space:]]#[[:digit:]]+:\|Element data

#+begin_src elisp :noweb yes
(seq-filter (lambda (buf)
              (string-match-p
               <<element-data-rx>>
               (buffer-name buf)))
            (buffer-list))
#+end_src

#+RESULTS:

Next capture the knowledge tree:
"X:sm18.exe/neuron"
#+NAME: knowledge-tree-rx
#+begin_src elisp
(rx bol "neuron" eol)
#+end_src

#+RESULTS: knowledge-tree-rx
: ^neuron$

#+begin_src elisp :noweb yes
(seq-filter (lambda (buf)
              (string-match-p
               <<knowledge-tree-rx>>
               (buffer-name buf)))
            (buffer-list))
#+end_src

#+RESULTS:

We'll also attempt to suppress the empty(?) buffer created by Supermemo.
#+NAME: empty-sm-rx
#+begin_src elisp
(rx "z:\\home\\vrika\\documents\\sm")
#+end_src

#+RESULTS: empty-sm-rx
: z:\\home\\vrika\\documents\\sm

#+begin_src elisp :noweb yes :noweb-ref empty-sm-window
(seq-filter (lambda (buf)
              (string-match-p
              <<empty-sm-rx>>
               (buffer-name buf)))
            (buffer-list))
#+end_src

#+NAME: concepts-rx
#+begin_src elisp
(rx "Concepts")
#+end_src

#+RESULTS: concepts-rx
: Concepts

#+begin_src elisp :noweb yes
(seq-filter (lambda (buf)
              (string-match-p
               <<concepts-rx>>
               (buffer-name buf)))
            (buffer-list))
#+end_src

Now we'll throw this together as a set of buffer rules:

** hooking sm-buffers
:PROPERTIES:
:CREATED:  [2020-11-20 Fri 10:39]
:ID:       c0a59157-a741-4824-b25e-4b8cab63a2d9
:END:

Currently the catch-all [[file:~/.doom.d/modules/desktop/exwm/+funcs.el::defun exwm/rename-buffer (][exwm/rename-buffer]] function captures the sm buffers on each update of the
=title-hook=. We'll cook up some rules to leave handling these buffers to another custom hooked function.

Currently the [[file:~/.local/share/applications/supermemo18.supermemo18.desktop::StartupWMClass=sm18.exe][StartupWMClass]] for sm18 is not propagating out to the actuall WM_CLASS as =sm18.exe=, possibly as a limitation of =wine-5.2= We'll have to clobber all ~Wine~ applications for now.

Excluding based on =class=. (this doesn't seem to do it though)
#+begin_src elisp :noweb yes :noweb-ref exwm-class-hook
(add-hook 'exwm-update-class-hook
          (defun my-exwm-update-class-hook ()
            (unless (or (string-prefix-p "Wine" exwm-class-name))
                        (string-prefix-p "Internet Explorer" exwm-class-name)
                        (string-prefix-p "sm18.exe" exwm-class-name)
                        ;; (string-prefix-p "SuperMemo" exwm-class-name)
                        ;; (string-prefix-p "Explorer" exwm-class-name))
              (exwm/rename-buffer))))
#+end_src

#+RESULTS:
| my-exwm-update-class-hook |

Exclusion based on =exwm-title=:
#+begin_src elisp :noweb yes :noweb-ref exwm-title-hook
(add-hook 'exwm-update-title-hook
          (defun my-exwm-update-title-hook ()
            (unless (or (string-prefix-p <<element-window-rx>> exwm-title)
                        (string-prefix-p <<knowledge-tree-rx>> exwm-title)
                        (string-prefix-p <<element-data-rx>> exwm-title)
                        (string-prefix-p <<concepts-rx>> exwm-title)
                        (string-prefix-p <<empty-sm-rx>> exwm-title)
                        ;; (string-prefix-p (rx "z:\\home\\vrika\\documents\\sm") exwm-title)
                        ;; The below may be necessary
                        ;; (string-prefix-p (rx (seq "Mousepad")) exwm-title))
                        (string-prefix-p "Internet Explorer" exwm-class-name)
                        (string-prefix-p "Choose Collection" exwm-class-name)
                        (string-prefix-p "RAIL" exwm-class-name)
                        (string-prefix-p "sm18.exe" exwm-class-name)
                        (string-prefix-p "Wine" exwm-class-name))
              (exwm/rename-buffer))))
#+end_src

#+RESULTS:
| my-exwm-update-title-hook |

#+begin_src elisp :noweb yes :noweb-ref element-window-hook :results silent
(add-hook 'exwm-update-title-hook
          (defun sm-element-test-title-hook ()
            (when (string-match <<element-window-rx>> exwm-title)
              (exwm-workspace-rename-buffer "sm-element-window"))))
#+end_src

#+begin_src elisp :noweb yes :noweb-ref knowledge-tree-hook :results silent
(add-hook 'exwm-update-title-hook
          (defun sm-knowledge-tree-title-hook ()
            (when (string-match <<knowledge-tree-rx>> exwm-title)
              (exwm-workspace-rename-buffer "sm-knowledge-tree"))))
#+end_src

#+begin_src elisp :noweb yes :noweb-ref element-data-hook :results silent
(add-hook 'exwm-update-title-hook
          (defun sm-element-data-title-hook ()
            (when (string-match <<element-data-rx>> exwm-title)
              (exwm-workspace-rename-buffer "sm-element-data"))))
#+end_src

#+begin_src elisp :noweb yes :noweb-ref empty-sm-hook :results silent
(add-hook 'exwm-update-title-hook
          (defun sm-element-frame-title-hook ()
            (if (string-match (rx "z:\\home\\vrika\\documents\\sm") exwm-title)
              (exwm-workspace-rename-buffer "sm-frame"))))
#+end_src

#+begin_src elisp :noweb yes :noweb-ref empty-sm-hook2 :results silent
(add-hook 'exwm-update-title-hook
          (defun sm-frame-title-hook ()
            (if (string-match (rx "c:\\users\\dan\\documents\\sm") exwm-title)
              (exwm-workspace-rename-buffer "sm-frame"))))
#+end_src

Instead of having several seperate hooks we can define one function with several conditions:
Could I write a list for this section?

I think that I could write a macro for this

#+begin_src elisp :noweb yes :noweb-ref sm-window hooks
(add-hook 'exwm-update-title-hook
          (defun sm-element-frame-title-hook ()
            (when (string-match (rx "z:\\home\\vrika\\documents\\sm") exwm-title)
                (exwm-workspace-rename-buffer "sm-frame"))
            (when (string-match (rx bol "home" eol) exwm-title)
              (exwm-workspace-rename-buffer "sm-element-window"))
            (when (string-match (rx bol "neuron" eol) exwm-title)
              (exwm-workspace-rename-buffer "sm-knowledge-tree"))
            (when (string-match (rx (| (seq (or "Topic" "Element") space "#" (one-or-more digit) ":") (seq "Element data"))) exwm-title)
              (exwm-workspace-rename-buffer "sm-element-data"))
            (when (string-match (rx bol "Images") exwm-title)
              (exwm-workspace-rename-buffer "sm-images"))
            (when (string-match (rx bol "Repetition sorting criteria") exwm-title)
              (exwm-workspace-rename-buffer "sm-sorting"))
            (when (string-match (rx bol "Subset") exwm-title)
              (exwm-workspace-rename-buffer "Subset"))
            (when (string-match (rx bol "Repair Options") exwm-title)
              (exwm-workspace-rename-buffer "sm-repair-collection"))
            (when (string-match (rx bol "Analysis") exwm-title)
              (exwm-workspace-rename-buffer "sm-statistics-analysis"))
            (when (string-match (rx bol "Question") exwm-title)
              (exwm-workspace-rename-buffer "sm-question-window"))
            (when (string-match (rx bol "Modify Priorities") exwm-title)
              (exwm-workspace-rename-buffer "sm-modify-priority"))
            (when (string-match (rx bol "Element Priority") exwm-title)
              (exwm-workspace-rename-buffer "sm-priority"))
            (when (string-match (rx bol "Copying") exwm-title)
              (exwm-workspace-rename-buffer "sm-backup-copy"))
            (when (string-match (rx bol "Information") exwm-title)
              (exwm-workspace-rename-buffer "sm-info-window"))
            (when (string-match (rx bol "Options") exwm-title)
              (exwm-workspace-rename-buffer "sm-options-window"))
            (when (string-match (rx bol "Find elements") exwm-title)
              (exwm-workspace-rename-buffer "sm-element-finder"))
            ))
#+end_src

Then we add manually all the potential windows SM might spawn to =exwm-manage-configurations= so they can float over the main windows:

#+begin_src elisp :noweb yes :noweb-ref sm managed configurations
(add-to-list 'exwm-manage-configurations '((string-match (rx bol "Images") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Concepts") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Choices") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Template") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Subset") exwm-title) managed t floating nil))
(add-to-list 'exwm-manage-configurations '((string-match (rx "SuperMemo Commander") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Repetition sorting criteria") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Repair Options") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Analysis") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Question") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Element Priority") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Modify Priorities") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Element Priority") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Options") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Information") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Find elements") exwm-title) managed t floating t))

#+end_src

#+begin_src elisp :noweb yes :noweb-ref window assignments :results silent
(require 'subr-x)  ;; Because of when-let

(defvar exwm-workspace-window-assignments
  '(("sm-element-window" . 3)
    ("sm-knowledge-tree" . 3)
    ("sm-element-data" . 3))
  "An alist of window classes and which workspace to put them on.")

(add-hook 'exwm-manage-finish-hook
          (lambda ()
            (when-let ((target (cdr (assoc exwm-class-name exwm-workspace-window-assignments))))
              (exwm-workspace-move-window target))))
#+end_src

Was this for "New Concepts"?
#+begin_src elisp :noweb yes :noweb-ref concepts-hook :results silent
(add-to-list 'exwm-manage-configurations '((string= exwm-title <<concepts-rx>>) managed t floating t))

(add-hook 'exwm-update-title-hook
          (defun sm-element-concepts-title-hook ()
            (when (string-match <<concepts-rx>> exwm-title)
              (exwm-workspace-rename-buffer "concepts"))))

(add-to-list 'exwm-manage-configurations '((string= exwm-title (rx (seq "New Concept"))) managed t floating t))

(add-hook 'exwm-update-title-hook
          (defun sm-element-concepts1-title-hook ()
            (when (string-match (rx (seq "New Concept")) exwm-title)
              (exwm-workspace-rename-buffer "New Concept"))))

(add-hook 'exwm-update-title-hook
          (defun iexplorer-title-hook ()
            (when (string-match (rx (seq "Internet Explorer")) exwm-title)
              (exwm-workspace-rename-buffer "iexplorer"))))

(add-hook 'exwm-update-title-hook
          (defun sma-title-hook ()
            (when (string-match (rx (seq "Choose Collection")) exwm-title)
              (exwm-workspace-rename-buffer "supermemoassistant"))))

;; (add-to-list 'exwm-manage-configurations
;;    '((string= (buffer-name) "sm-element-window")
;;      (string= (buffer-name) "sm-knowledge-tree")
;;      (string= (buffer-name) "sm-element-data")
;;       workspace 3))

;; (add-to-list 'exwm-manage-configurations
;;    '((string= (buffer-name) "sm-element-window")
;;      workspace 3))

(add-to-list 'exwm-manage-configurations
   '((string= exwm-instance-name "sm18.exe")
     workspace 3 managed t floating nil))

(add-to-list 'exwm-manage-configurations
   '((string= exwm-instance-name "SuperMemo 18")
     workspace 3 managed t floating nil))
#+end_src

#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+sm-window-rules.el
;;; desktop/exwm/+sm-window-rules.el -*- lexical-binding: t; -*-
;; <<empty-sm-hook>>

;; <<element-window-hook>>

;; <<knowledge-tree-hook>>

;; <<element-data-hook>>

;; <<concepts-hook>>

<<sm-window hooks>>

<<sm managed configurations>>

<<dbc rules>>
#+end_src

** display-buffer-alist
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:31]
:ID:       6b6b8247-b27b-4771-bd30-74ec4653f123
:header-args: :noweb-ref buffer alist hooks
:END:
Once have these tested and working, theoretically as x-windows under EXWM are just emacs buffers, they could be controlled with the built-in ~display-buffer~ tooling via ~display-buffer-alist~:

#+begin_src elisp :tangle no :noweb no
;; (add-to-list 'display-buffer-alist
;;              `((,<<empty-sm>>
;;                 (display-buffer-no-window))
;;                (,<<tree-rx>>
;;                 (display-buffer-reuse-window display-buffer-in-side-window)
;;                 (side . left)
;;                 (slot . 0)
;;                 (window-width . 0.22))
;;                (,<<element-data-rx>>
;;                 (display-buffer-at-bottom)
;;                 ;; (side . bottom)
;;                 ;; (slot . 0)
;;                 (window-height . 0.19))))
#+end_src

However, this doesn't work as expected an we have to wrap this rules in an exwm hook:
#+begin_src elisp :noweb yes :results silent
(add-hook 'exwm-manage-finish-hook
          (lambda ()
            (when (string-match-p "sm-frame" (buffer-name))
              (display-buffer
               (get-buffer-create "sm-frame")
               '((display-buffer-no-window)
                 ;; (allow-no-window . t)
                 )))
            (when (string-match-p "sm-element-window" (buffer-name))
              (display-buffer
               (get-buffer-create "sm-element-window")
               '((display-buffer-same-window))))
            (when (string-match-p "sm-knowledge-tree" (buffer-name))
              (display-buffer
               (get-buffer-create "sm-knowledge-tree")
               '((display-buffer-in-side-window)
                 ;; (inhibit-same-window . t)
                 (side . left)
                 (slot . 0)
                 (window-width . 0.21))))
            (when (string-match-p "sm-element-data" (buffer-name))
              (progn (exwm-layout-hide-mode-line)
                     (display-buffer
                      (get-buffer-create "sm-element-data")
                      '((display-buffer-in-side-window)
                        ;; (inhibit-same-window . t)
                        (side . bottom)
                        (slot . 1)
                        (window-height . 0.21)))))
            ))
#+end_src

#+begin_src elisp :noweb yes :results silent
  ;; (add-hook 'exwm-manage-finish-hook
  ;;           (lambda ()
  ;;             (when (string-match-p "sm-knowledge-tree" (buffer-name))
  ;;               (display-buffer-in-side-window (current-buffer)
  ;;                                              '((side . left)
  ;;                                                (slot . 0)
  ;;                                                (window-height . 0.16))))))
#+end_src

#+begin_src elisp :noweb yes :results silent
  ;; (add-hook 'exwm-manage-finish-hook
  ;;           (lambda ()
  ;;             (when (string-match-p "sm-element-data" (buffer-name))
  ;;               (display-buffer-in-side-window (current-buffer)
  ;;                                              '((side . bottom)
  ;;                                                (slot . 0)
  ;;                                                (window-height . 0.20))))))
#+end_src

#+begin_src elisp :tangle no :noweb yes :results silent
;; (remove-hook 'exwm-manage-finish-hook
;;           (lambda ()
;;             (when (string-match-p
;;                    <<element-data-rx>>
;;                    (buffer-name))
;;               (display-buffer-in-side-window (current-buffer)
;;                                              '((side . bottom)
;;                                                (slot . 0)
;;                                                (window-width . 0.23))))))
#+end_src

** dbc
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:31]
:ID:       bbd768ea-8399-40f1-a256-9af276fa9796
:END:

An alternative would be to use the [[https://gitlab.com/matsievskiysv/display-buffer-control][dbc]] package, a wrapper around ~display-buffer~ which makes configuration a little easier:

*** Element window window
:PROPERTIES:
:CREATED:  [2020-11-30 Mon 17:08]
:ID:       aeb600d7-3e63-46d0-a536-656885c5d139
:END:

#+begin_src elisp :noweb yes :results silent :noweb-ref element window rule
(dbc-add-ruleset "expose" '((display-buffer-reuse-window display-buffer-pop-up-frame) .
                            ((reusable-frames . 0))))

(dbc-add-rule "expose" "main" :newname "sm-element-window")
#+end_src

*** Knowledge tree window
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:36]
:ID:       f413ac69-a518-4fae-9228-6c298771a214
:END:

dbc ruleset for the knowledge tree

#+begin_src elisp :results silent :noweb-ref left rule
(dbc-add-ruleset "left" '((display-buffer-reuse-window display-buffer-in-side-window) .
                          ((side . left) (slot . -1) (window-width . 0.22))) 5)

(dbc-add-rule "left" "tree" :newname "sm-knowledge-tree")
#+end_src

Remove the rule for testing purposes
#+begin_src elisp :noweb yes :results silent
(dbc-remove-rule "left" "tree")
#+end_src

#+begin_src elisp :noweb yes
(dbc-add-rule "bottom" "bar" :newname <<lower-bar-rx>>)
#+end_src

*** Element data window
:PROPERTIES:
:CREATED:  [2020-11-30 Mon 17:08]
:ID:       e9c424ac-738f-4688-ad9c-8cdbbfd5d568
:END:

#+begin_src elisp :results silent :noweb-ref element tray rule
(dbc-add-ruleset "bottom" '((display-buffer-reuse-window display-buffer-in-side-window) .
                            ((side . bottom) (slot . 0) (window-height . 0.23))) 10)

(dbc-add-rule "bottom" "tray" :newname "sm-element-data")
#+end_src

#+begin_src elisp :results silent
(dbc-remove-ruleset "bottom")
#+end_src

#+begin_src elisp
(dbc-remove-rule "bottom" "tray")
#+end_src

*** Empty frame
:PROPERTIES:
:CREATED:  [2020-11-30 Mon 17:08]
:ID:       549b81e7-1902-4bd5-bb1c-4a82268a6a71
:END:

There seems to be somekind of empty frame that Supermemo produces. When inside this frame/window it can cause all the other SM related windows to freak out and rapidly cylce through them hanging the system temporarily.

#+begin_src elisp :noweb yes :results silent
;; (dbc-add-rule "left" "test" :newname (rx (seq "Mousepad")))
(dbc-add-rule "left" "test123" :newname "Mousepad")
#+end_src

#+begin_src elisp :results silent
(dbc-add-ruleset "supress" '((display-buffer-no-window)) 1)
#+end_src

#+begin_src elisp :noweb yes
(dbc-add-rule "supress" "empty" :newname <<empty-sm>>)
#+end_src

#+begin_src elisp :noweb yes
(use-package! dbc
  :after exwm
  :config
  ;; (dbc-remove-ruleset "expose" '((display-buffer-reuse-window display-buffer-pop-up-frame) .
  ;;                             ((reusable-frames . 0))))

  (dbc-add-ruleset "top" dbc-same-window-action 100)

  (dbc-add-ruleset "left" '((display-buffer-reuse-window display-buffer-in-side-window) .
                            ((side . left) (slot . -1) (window-width . 0.22))) 5)


  (dbc-add-ruleset "bottom" '((display-buffer-reuse-window display-buffer-in-side-window) .
                              ((side . bottom) (slot . 0) (window-height . 0.23))) 10)

  (add-hook 'exwm-manage-finish-hook
            (lambda ()
              (dbc-add-rule "top" "main" :newname "sm-element-window")))

  (add-hook 'exwm-manage-finish-hook
            (lambda ()
              (dbc-add-rule "left" "tree" :newname "sm-knowledge-tree")))

  (add-hook 'exwm-manage-finish-hook
            (lambda ()
              (dbc-add-rule "bottom" "tray" :newname "sm-element-data")))
  )
#+end_src

** Final buffer tangle
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:36]
:ID:       bef0674e-a594-442b-a959-c7005f24a4d4
:header-args: :noweb-ref dbc rules
:END:
#+begin_src elisp :noweb yes
;; (use-package! dbc
;; :config

<<exwm-class-hook>>

<<exwm-title-hook>>

<<buffer alist hooks>>
;; <<element window rule>>

;; <<left rule>>

;; <<element tray rule>>

;; )
#+end_src

* sm-core
:PROPERTIES:
:CREATED:  [2020-11-20 Fri 15:55]
:ID:       b98cd336-e48d-4a92-9998-bd88a20b1d12
:END:
Here we'll define the core keypress events we'd want to send to Supermemo.

simulation keys
#+begin_src elisp
(setq exwm-input-simulation-keys
      '(
        ;; ([?\C-b] . [left])
        ;; ([?\C-f] . [right])
        ;; ([?\C-p] . [up])
        ;; ([?\C-n] . [down])
        ;; ([?\C-a] . [home])
        ;; ([?\C-e] . [end])
        ;; ([?\M-v] . [prior])
        ([?\C-c] . [left])
        ([?\C-v] . [?\C-v])
        ([?\C-j] . [?\C-j])
        ([?\M-x] . [?\M-x])))
#+end_src

#+RESULTS:
: (([3] . [left]) ([22] . [22]) ([10] . [10]) ([134217848] . [134217848]))

** Advanced functions with AHK
:PROPERTIES:
:CREATED:  [2021-04-20 Tue 15:53]
:ID:       ace7c6f8-9504-4596-a159-a4436e5d1147
:END:

A little function to assist with executing ahk.exe's
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;; desktop/exwm/+exwm-sm-core.el -*- lexical-binding: t; -*-

(defun ahk-run (ahk)
    "pass an AHK .exe on to start-process-shell-command in a temp buffer"
    (setq sm-current-buffer (current-buffer))
      (progn
        (when (posframe-workable-p)
          (posframe-show "*ahk-run*"
                         :height 30
                         :width 30
                         :internal-border-width 2
                         :internal-border-width 2
                         :internal-border-width "purple"))
        (switch-to-buffer-other-frame "*ahk-run*")
        ;; (switch-to-buffer "*ahk-run*"))
        (let ((process (start-process-shell-command
                        "ahk-run"
                        "*ahk-run*"
                        "env WINEPREFIX='/home/volk/.local/share/wineprefixes/supermemo18'"
                        "wine" ahk)))
          (set-process-sentinel process 'ahk-run-sentinel))))

(defun ahk-run-sentinel (p e)
"quit the popup buffer after successful run of shell process"
 (when (= 0 (process-exit-status p))
   (posframe-hide "*ahk-run*")
   (switch-to-buffer sm-current-buffer)))


  ;; (exwm-input-release-keyboard)
#+end_src

** Basic movement functions
:PROPERTIES:
:CREATED:  [2021-04-20 Tue 15:53]
:ID:       08f4795c-fb26-4b13-8a48-99a03d67cb53
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
(require 'exwm)
(require 'exwm-input)

;;; Basic navigation
;;;###autoload
(defun exwm-sm-core-up ()
  "Move up."
  (interactive)
  (exwm-input--fake-key 'up))

;;;###autoload
(defun exwm-sm-core-down ()
  "Move down."
  (interactive)
  (exwm-input--fake-key 'down))

;;;###autoload
(defun exwm-sm-core-left ()
  "Move down."
  (interactive)
  (exwm-input--fake-key 'left))

;;;###autoload
(defun exwm-sm-core-right ()
  "Move down."
  (interactive)
  (exwm-input--fake-key 'right))

;;;###autoload
(defun exwm-sm-core-goto-parent ()
  "Go to parent of current element"
  (interactive)
  (ahk-run "~/.scripts/ahk/goto-parent.exe"))

;;;###autoload
(defun exwm-sm-core-goto-child ()
  "Go to the first child of current element"
  (interactive)
  (ahk-run "~/.scripts/ahk/goto-child.exe"))

;;;###autoload
(defun exwm-sm-core-forward ()
  "Go forward element"
  (interactive)
  (ahk-run "~/.scripts/ahk/forward.exe"))

;;;###autoload
(defun exwm-sm-core-back ()
  "Go back element"
  (interactive)
  (ahk-run "~/.scripts/ahk/back.exe"))

#+end_src

** Find and search operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:22]
:ID:       daa8e452-7e02-4b2f-a081-45f97eeaeedf
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;; Find/Search

;;;###autoload
(defun exwm-sm-core-find ()
  "Find general."
  (interactive)
  (ahk-run "~/.scripts/ahk/find.exe"))

;;;###autoload
(defun exwm-sm-core-search ()
  "Search for texts containing a given string."
  (interactive)
  (ahk-run "~/.scripts/ahk/search.exe"))

;;;###autoload
(defun exwm-sm-core-find-elements ()
  "Find elements."
  (interactive)
  (ahk-run "~/.scripts/ahk/find-elements.exe"))

;;;###autoload
(defun exwm-sm-core-search-phrase ()
  "Search currently selected phrase."
  (interactive)
  (ahk-run "~/.scripts/ahk/search-phrase.exe"))

;;;###autoload
(defun exwm-sm-core-find-next ()
  "Find next."
  (interactive)
  (exwm-input--fake-key ?\C-g))

;;;###autoload
(defun exwm-sm-core-find-previous ()
  "Find previous."
  (interactive)
  (exwm-input--fake-key ?\C-\S-g))

#+end_src

** Editing
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:25]
:ID:       1d576d49-e772-40ec-a57c-2160d44fd808
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;; Editing
;;;###autoload

(defun exwm-sm-core-paste ()
  "Paste from clipboard."
   (interactive)
   (ahk-run "~/.scripts/ahk/paste.exe"))

(defun exwm-sm-core-paste-html ()
  "Paste html from clipboard."
   (interactive)
   (ahk-run "~/.scripts/ahk/paste-html.exe"))

;;;###autoload
(defun exwm-sm-core-copy ()
  "Copy to clipboard."
   (interactive)
   (ahk-run "~/.scripts/ahk/copy-clipboard.exe"))

;;;###autoload
(defun exwm-sm-core-cut ()
  "Cut text."
   (interactive)
   (ahk-run "~/.scripts/ahk/cut.exe"))

;;;###autoload
(defun exwm-sm-core-delete ()
  "Delete text."
   (interactive)
   (ahk-run "~/.scripts/ahk/delete.exe"))

;;;###autoload
(defun exwm-sm-core-undo ()
  "Undo."
   (interactive)
   (ahk-run "~/.scripts/ahk/undo.exe"))

;;;###autoload
(defun exwm-sm-core-redo ()
  "Redo."
   (interactive)
   (ahk-run "~/.scripts/ahk/redo.exe"))

;;;###autoload
(defun exwm-sm-core-forward-word ()
  "Move word forward."
  (interactive)
  (exwm-input--fake-key 'C-right))

;;;###autoload
(defun exwm-sm-core-back-word ()
  "Move word backward."
  (interactive)
  (exwm-input--fake-key 'C-left))

;;;###autoload
(defun exwm-sm-core-bold ()
  "Embolden selected text"
  (interactive)
  (ahk-run "~/.scripts/ahk/bold-font.exe"))

;;;###autoload
(defun exwm-sm-core-italic ()
  "Italicise selected text."
  (interactive)
  (ahk-run "~/.scripts/ahk/italic-font.exe"))

;;;###autoload
(defun exwm-sm-decrease-font ()
  "Decrease selected font size"
  (interactive)
  (ahk-run "~/.scripts/ahk/decrease-font-size.exe"))

;;;###autoload
(defun exwm-sm-increase-font ()
  "Increase selected font size"
  (interactive)
  (ahk-run "~/.scripts/ahk/increase-font-size.exe"))

;;;###autoload
(defun exwm-sm-core-edit-question ()
  "Edit the question component"
  (interactive)
  (ahk-run "~/.scripts/ahk/edit-question.exe"))

;;;###autoload
(defun exwm-sm-core-edit-answer ()
  "Edit the first answer"
  (interactive)
  (ahk-run "~/.scripts/ahk/edit-answer.exe"))

;;;###autoload
(defun exwm-sm-core-edit-file ()
  "Edit .HTM file"
  (interactive)
  (ahk-run "~/.scripts/ahk/edit-file.exe"))

;;;###autoload
(defun exwm-sm-core-edit-next-component ()
  "Edit the next component in element window"
  (interactive)
  (ahk-run "~/.scripts/ahk/edit-next-component.exe"))

;;;###autoload
(defun exwm-sm-core-edit-switch-mode ()
  "Cycle presentation -> editing -> dragging modes"
  (interactive)
  (ahk-run "~/.scripts/ahk/edit-next-component.exe"))

#+end_src

** Selection
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:45]
:ID:       468001dc-ec7e-454c-aef6-5559c240f146
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;;; Selection
;;;###autoload
(defun exwm-sm-core-forward-word-select ()
  "Move word forward and select."
  (interactive)
  (exwm-input--fake-key 'C-S-right))

;;;###autoload
(defun exwm-sm-core-back-word-select ()
  "Move word backward and select."
  (interactive)
  (exwm-input--fake-key 'C-S-left))

;;;###autoload
(defun exwm-sm-core-select-all ()
  "Select whole page."
  (interactive)
  (exwm-input--fake-key ?\C-a))

#+end_src

** Element functions
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:45]
:ID:       6f4b7ba2-8c14-4a7f-a03a-06dd3f193523
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;;###autoload
(defun exwm-sm-core-elements-dismiss-element ()
"Dismiss element while in element window"
  (interactive)
  (ahk-run "~/.scripts/ahk/element-dismiss-element.exe"))

;;;###autoload
(defun exwm-sm-core-contents-dismiss-element ()
"Dismiss element while in contents window"
  (interactive)
  (ahk-run "~/.scripts/ahk/contents-dismiss-element.exe"))

;;;###autoload
(defun exwm-sm-core-delete-element ()
  "Delete/dismiss currently displayed element"
  (interactive)
  (ahk-run "~/.scripts/ahk/dismiss-delete.exe"))

;;;###autoload
(defun exwm-sm-core-element-params ()
  "Bring up apply template menu"
  (interactive)
  (ahk-run "~/.scripts/ahk/element-params.exe"))

;;;###autoload
(defun exwm-sm-core-insert-image ()
  "Insert image into component."
  (interactive)
  (ahk-run "~/.scripts/ahk/insert-image.exe"))

;;;###autoload
(defun exwm-sm-core-insert-splitline ()
  "Insert image into component."
  (interactive)
  (ahk-run "~/.scripts/ahk/insert-splitline.exe"))

;;;###autoload
(defun exwm-sm-core-cycle-image-stretch ()
  "Cycle stretch of image component."
  (interactive)
  (ahk-run "~/.scripts/ahk/cycle-image-stretch.exe"))

;;;###autoload
(defun exwm-sm-core-apply-template ()
  "Bring up apply template menu"
  (interactive)
  (ahk-run "~/.scripts/ahk/element-apply-template.exe"))

;;;###autoload
(defun exwm-sm-core-item-picture ()
  "Apply Item Picture template to element"
  (interactive)
  (ahk-run "~/.scripts/ahk/item-picture.exe"))

;;;###autoload
(defun exwm-sm-core-import-component ()
  "Import component in element window"
  (interactive)
  (ahk-run "~/.scripts/ahk/import-component.exe"))

;;;###autoload
(defun exwm-sm-core-reorder-components ()
  "Bring up reorder components menu"
  (interactive)
  (ahk-run "~/.scripts/ahk/reorder-components.exe"))

;;;###autoload
(defun exwm-sm-core-reference-label ()
  "Bring up references menu"
  (interactive)
  (ahk-run "~/.scripts/ahk/reference-label-menu.exe"))

;;;###autoload
(defun exwm-sm-core-test-rep-cycle ()
  "Emulate learning mode to test element/components"
  (interactive)
  (ahk-run "~/.scripts/ahk/test-rep-cycle.exe"))

;;;###autoload
(defun exwm-sm-core-tile-components ()
  "Go into tiling menu for component tiling"
  (interactive)
  (ahk-run "~/.scripts/ahk/tile-components.exe"))

(defun exwm-sm-core-ancestors ()
"Bring up element ancestors menu"
  (interactive)
  (ahk-run "~/.scripts/ahk/ancestors.exe"))

(defun exwm-sm-core-create-hyperlink ()
"Create hyperlink over selected text"
  (interactive)
  (ahk-run "~/.scripts/ahk/create-hyperlink.exe"))

(defun exwm-sm-core-get-filepath ()
"Get the file path of the current element"
  (interactive)
  (ahk-run "~/.scripts/ahk/get-filepath.exe"))

#+end_src

** Learn operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:46]
:ID:       88b59ad6-d7ea-4e85-b828-c147fa4bb902
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;;; Learn operations

;;;###autoload
(defun exwm-sm-core-learn ()
  "Start learning"
  (interactive)
  (ahk-run "~/.scripts/ahk/learn.exe"))

;;;###autoload
(defun exwm-sm-core-replay ()
  "Replay component"
  (interactive)
  (ahk-run "~/.scripts/ahk/replay.exe"))

;;;###autoload
(defun exwm-sm-core-cloze ()
  "Extract selected text"
  (interactive)
  (ahk-run "~/.scripts/ahk/cloze.exe"))

;;;###autoload
(defun exwm-sm-core-extract ()
  "Extract selected text"
  (interactive)
  (ahk-run "~/.scripts/ahk/extract.exe"))

;;;###autoload
(defun exwm-sm-core-schedule-extract ()
  "Extract and schedule for a later time"
  (interactive)
  (ahk-run "~/.scripts/ahk/schedule-extract.exe"))

;;;###autoload
(defun exwm-sm-core-prioritize ()
  "Modify priority of current element"
  (interactive)
  (ahk-run "~/.scripts/ahk/priority.exe"))

;;;###autoload
(defun exwm-sm-core-reschedule ()
  "Learning: Reschedule to another day"
  (interactive)
  (ahk-run "~/.scripts/ahk/reschedule.exe"))

;;;###autoload
(defun exwm-sm-core-postpone ()
  "Schedule review later today"
  (interactive)
  (ahk-run "~/.scripts/ahk/later-today.exe"))

;;;###autoload
(defun exwm-sm-core-element-dismiss-element ()
  "Dismiss element from element window"
  (interactive)
  (ahk-run "~/.scripts/ahk/element-dismiss-element.exe"))

;;;###autoload
(defun exwm-sm-core-remember ()
  "Introduce element into learning que"
  (interactive)
  (ahk-run "~/.scripts/ahk/remember.exe"))

;;;###autoload
(defun exwm-sm-core-execute-rep ()
  "Execute a mid-interval rep at later date"
  (interactive)
  (ahk-run "~/.scripts/ahk/execute-rep.exe"))

;;;###autoload
(defun exwm-sm-core-cancel-grade ()
  "Undo grading on element"
  (interactive)
  (ahk-run "~/.scripts/ahk/cancel-grade.exe"))

;;;###autoload
(defun exwm-sm-core-branch-learning ()
  "Subset review of a selection of a branch in contents"
  (interactive)
  (ahk-run "~/.scripts/ahk/branch-learning.exe"))

;;;###autoload
(defun exwm-sm-core-random-learning ()
  "Random learning"
  (interactive)
  (ahk-run "~/.scripts/ahk/random-learning.exe"))

;;;###autoload
(defun exwm-sm-core-random-test ()
  "Random test"
  (interactive)
  (ahk-run "~/.scripts/ahk/random-test.exe"))

;;;###autoload
(defun exwm-sm-core-set-read-point ()
  "Set the read-point"
  (interactive)
  (ahk-run "~/.scripts/ahk/set-read-point.exe"))

;;;###autoload
(defun exwm-sm-core-mercy ()
  "Activate mercy"
  (interactive)
  (ahk-run "~/.scripts/ahk/mercy.exe"))

;;;###autoload
(defun exwm-sm-core-neural ()
  "Go neural"
  (interactive)
  (ahk-run "~/.scripts/ahk/go-neural.exe"))

;;;###autoload
(defun exwm-sm-core-sorting-criteria ()
  "Open sorting criteria window"
  (interactive)
  (ahk-run "~/.scripts/ahk/sorting-criteria.exe"))

;;;###autoload
(defun exwm-sm-core-subset-learning ()
  "Subset learning"
  (interactive)
  (ahk-run "~/.scripts/ahk/subset-learning.exe"))

#+end_src

** Knowledge tree operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 15:27]
:ID:       a34b8b01-dc40-4ee0-be9c-fdc44715ba48
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;;###autoload
(defun exwm-sm-convert-to-concept ()
  "Convert element to concept"
  (interactive)
  (ahk-run "~/.scripts/ahk/convert-to-concept.exe"))

;;;###autoload
(defun exwm-sm-new-article ()
  "Create new article"
  (interactive)
  (ahk-run "~/.scripts/ahk/new-article.exe"))

#+end_src

** Misc operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 13:48]
:ID:       795a6453-5dfc-42e4-b2cf-735fdd224d0c
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;; Misc

;;;###autoload
(defun exwm-sm-core-sm-commander ()
  "Summon the SuperMemo Commander"
  (interactive)
  (ahk-run "~/.scripts/ahk/sm-commander.exe"))

;;;###autoload
(defun exwm-sm-core-sm-repair-collection ()
  "Bring up the collection repair menu"
  (interactive)
  (ahk-run "~/.scripts/ahk/repair-collection.exe"))

;;;###autoload
(defun exwm-sm-core-restore-layout ()
  "Restore the default window layout"
  (interactive)
  (ahk-run "~/.scripts/ahk/restore-layout.exe"))

;;;###autoload
(defun exwm-sm-core-statistics-analysis ()
  "Open stats window"
  (interactive)
  (ahk-run "~/.scripts/ahk/statistics-analysis.exe"))

;;;###autoload
(defun exwm-sm-core-open-file ()
  "Open file."
  (interactive)
  (exwm-input--fake-key ?\C-o))

;;;###autoload
(defun exwm-sm-core-quit ()
  "Quit sm."
  (interactive)
  (exwm-input--fake-key ?\C-q))

(provide '+exwm-sm-core)
#+end_src
** TODO Try get ~input-fake-key~ working with Wine
:PROPERTIES:
:CREATED:  [2020-12-08 Tue 15:05]
:ID:       733fbf64-129d-4b63-8b92-8fcc569c5627
:END:
Testing some elisp functions to convert Windows paths from Wine to Linux
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
(defun my-translate-winpath ()
  "change :C\win\path to 'nix /path/path"
  (let ((path (current-kill 0 'do-not-move)))
    (shell-command-to-string (format "~/.scripts/winpath.sh %s" path))))

(defun my-translate-winpath ()
  "change :C\win\path to 'nix /path/path"
  (let ((path (current-kill 0 'do-not-move)))
    (my-translate-path)))

(defun my-translate-winpath ()
  (interactive)
  (let* ((path (s-chop-prefix "z:" (current-kill 0 'do-not-move)))
         (nixpath (s-replace "\\" "/" path))
         (path1 (s-replace "documents" "Documents" nixpath)))
    (s-replace "sm" "SM" path1)))
#+end_src

Let's test this with Xdotool. It works, but isn't reliable.
#+begin_src elisp :tangle no
(defun exwm-sm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
(progn)
(my-translate-winpath)
;; (sit-for 3)
(message sm-path-nix))

(defun exwm-sm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
  (shell-command "sh ~/.scripts/xdotool/get_element_path.sh"))
  (shell-command "sh ~/.scripts/xdotool/get_element_path.sh"))

(defun exwm-sm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
(progn
  (shell-command "sh ~/.scripts/xdotool/get_element_path.sh")
  (gui--selection-value-internal 'CLIPBOARD)))

(defun exwm-sm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
  (shell-command "sh ~/.scripts/xdotool/get_element_path.sh")
(lambda ()
)
  (setq sm-path (gui--selection-value-internal 'CLIPBOARD)))
  ;; (shell-command "sh ~/.scripts/xdotool/get_element_path.sh"))
#+end_src

Testing with EXWM functionality (elisp only).
The big issue here is that control keys are not passed on to the Wine application. However, they are when using ~exwm-input-send-next-key~.
#+begin_src elisp :tangle no
(defun exwm-sm-core-test()
  "test"
  (interactive)
  ;; (exwm--log)
  ;; (let ((exwm-input-line-mode-passthrough t))
         ;; (key "?/C-v"))
         ;; (key (read-key "22")))
    (exwm-input--fake-key ("?/C-s-o")))

(exwm-input-set-key (kbd "<f9>") #'exwm-sm-core-test)


;;;###autoload
(defun exwm-sm-core-test ()
  "Move down."
  (interactive)
  (let ((exwm-input-line-mode-passthrough t))
    (exwm-input--fake-key 'left)))
#+end_src

#+RESULTS:

Try and get the right key code
#+begin_src elisp :tangle no
;; (read-key)
(vector "v")
#+end_src

#+RESULTS:
: ["? C-v"]

Trying the same but with a string.
#+begin_src elisp :tangle no
(defun my-exwm-send-string (string)
  "Send STRING to `exwm-mode' buffer or just insert it."
  (if (eq major-mode 'exwm-mode)
      (mapc #'exwm-input--fake-key (string-to-list string))
    (insert string)))

(defun exwm-sm-core-string-test ()
  (interactive)
  ;; (let ((exwm-input-line-mode-passthrough t))
    ;; (my-exwm-send-string [#o26])))
  (my-exwm-send-string [94 3]))

;; (term-send-raw-string "l")

;; (read-key-sequence-vector)

(exwm-input-set-key (kbd "<f9>") #'exwm-sm-core-string-test)
;; ###autoload
;; (defun exwm-sm-core-test ()
;;   "Send string to a given exwm buffer"
;;   (interactive)
;;   (my-exwm-send-string "sm-get-path ")
;;   (find-file (my-translate-winpath)))
#+end_src

#+RESULTS:

Try with this
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
(cl-defun exwm-input-send-sim-key (key)
  "Fake a key event according to the last input key sequence."
  (interactive)
  (exwm--log)
  (unless (derived-mode-p 'exwm-mode)
    (cl-return-from exwm-input-send-simulation-key))
  (let ((keys (gethash (this-single-command-keys)
                       exwm-input--simulation-keys)))
    (dolist (key keys)
      (exwm-input--fake-key key))))
#+end_src

#+begin_src elisp :tangle no
(cl-defun my-exwm-input-send-next-key (keys)
  "Send next key to client window.

EXWM will prompt for the key to send.  This command can be prefixed to send
multiple keys.  If END-KEY is non-nil, stop sending keys if it's pressed."
  (interactive "p")
  (exwm--log)
  (unless (derived-mode-p 'exwm-mode)
    (cl-return-from my-exwm-input-send-next-key))
  (let (key keys)
      ;; Skip events not from keyboard
      (let ((exwm-input-line-mode-passthrough t))
            ;; (setq key (read-key (format (key-description keys))
        (setq key (key-description "?\C-v")))
      (setq keys (vconcat keys (vector key)))
      (exwm-input--fake-key key)))
#+end_src

#+RESULTS:
: my-exwm-input-send-next-key

#+begin_src elisp :tangle no
(defun exwm-sm-core-test()
  "test"
  (interactive)
  (exwm/enter-char-mode)
  (exwm-input--fake-key ?\C-v))

  ;; (exwm-input-release-keyboard)
;;; Find
;;;###autoload
(defun exwm-sm-core-find ()
  "Find."
  (interactive)
  (exwm-input--fake-key ?\C-f))

;;;###autoload
(defun exwm-sm-core-quick-find ()
  "Quick find."
  (interactive)
  (exwm-input--fake-key ?/))

;;;###autoload
(defun exwm-sm-core-find-next ()
  "Find next."
  (interactive)
  (exwm-input--fake-key ?\C-g))

;;;###autoload
(defun exwm-sm-core-find-previous ()
  "Find previous."
  (interactive)
  (exwm-input--fake-key ?\C-\S-g))


;;;###autoload
(defun exwm-sm-core-test()
  "Find previous."
  (interactive)
  (exwm-input--fake-key ?\-g))

;;; Editing
;; ;;;###autoload
(defun exwm-sm-core-test ()
  "Copy text."
  (interactive)
  (exwm-input--invoke--m))
(exwm-input-invoke-factory "m")

;; (defun exwm-sm-core-test ()
;;   "Copy text."
;;   (interactive)
;;   (with-current-buffer (window-buffer)
;;     (fhd/exwm-input-char-mode)
;;     (exwm-input--invoke--m)))

;; (exwm-input--fake-key ?\C-v)))

;; (defun invoke-ctl-v-map ()
;;   (interactive)
;;   (exwm-input--cache-event ?\C-v t)
;;   (exwm-input--unread-event ?\C-v))

;; (defun exwm-sm-core-paste ()
;;   "Paste text."
;;   (interactive)
;;   (exwm-input-send-next-key (exwm-input--fake-key ?\C-p)))

;; (defun exwm-sm-core-paste ()
;;   "Paste text."
;;   (interactive)
;;   (exwm-input-send-next-key 2 ?\C-p))

;;;###autoload
(defun exwm-sm-core-copy ()
  "Copy text."
  (interactive)
  (exwm-input--fake-key ?\C-c))

;;;###autoload
(defun exwm-sm-core-cut ()
  "Cut text."
  (interactive)
  (exwm-input--fake-key ?\C-x))

;;;###autoload
(defun exwm-sm-core-paste ()
  "Paste text."
  (interactive)
  (exwm-input--fake-key ?\C-v))

;;;###autoload
(defun exwm-sm-core-delete ()
  "Delete text."
  (interactive)
  (exwm-input--fake-key 'delete))

;;;###autoload
(defun exwm-sm-core-undo ()
  "Undo."
  (interactive)
  (exwm-input--fake-key ?\C-z))

;;;###autoload
(defun exwm-sm-core-redo ()
  "Redo."
  (interactive)
  (exwm-input--fake-key ?\C-\S-z))

;;;###autoload
(defun exwm-sm-core-redo-last ()
  "redo last undo (in html text editing)."
  (interactive)
  (exwm-input--fake-key ?\C-y))

;;;###autoload
(defun exwm-sm-core-forward-word ()
  "Move word forward."
  (interactive)
  (exwm-input--fake-key 'C-right))

;;;###autoload
(defun exwm-sm-core-back-word ()
  "Move word backward."
  (interactive)
  (exwm-input--fake-key 'C-left))

;;;###autoload
(defun exwm-sm-core-edit-answer ()
  "Edit the first answer"
  (interactive)
  (exwm-input--fake-key ?\a))

;;;###autoload
(defun exwm-sm-core-edit-texts ()
  "Edit texts"
  (interactive)
  (exwm-input--fake-key ?\e))

;;;###autoload
(defun exwm-sm-core-edit-question ()
  "Edit the first question"
  (interactive)
  (exwm-input--fake-key ?\q))

;;;###autoload
(defun exwm-sm-core-delete-element ()
  "Delete currently displayed element"
  (interactive)
  (exwm-input--fake-key 'delete))

;; ;;;###autoload
;; (defun exwm-sm-core-xxx ()
;;   "xxx"
;;   (interactive)
;;   (exwm-input--fake-key 'xxx))

;; ;;;###autoload
;; (defun exwm-sm-core-xxx ()
;;   "xxx"
;;   (interactive)
;;   (exwm-input--fake-key 'xxx))

;;;; Selection
;;;###autoload
(defun exwm-sm-core-forward-word-select ()
  "Move word forward and select."
  (interactive)
  (exwm-input--fake-key 'C-S-right))

;;;###autoload
(defun exwm-sm-core-back-word-select ()
  "Move word backward and select."
  (interactive)
  (exwm-input--fake-key 'C-S-left))

;;;###autoload
(defun exwm-sm-core-select-all ()
  "Select whole page."
  (interactive)
  (exwm-input--fake-key ?\C-a))

;;;; Learn operations

;;;###autoload
(defun exwm-sm-core-learn ()
  "Start learning"
  (interactive)
  (exwm-input--fake-key ?\C-l))

;;;###autoload
(defun exwm-sm-core-prioritize ()
  "Modify priority of current element"
  (interactive)
  (exwm-input--fake-key 'M-p))

;;;###autoload
(defun exwm-sm-core-reschedule ()
  "Learning: Reschedule to another day"
  (interactive)
  (exwm-input--fake-key ?\C-j))

;;;###autoload
(defun exwm-sm-core-postpone ()
  "Schedule review later today"
  (interactive)
  (exwm-input--fake-key ?\C-\S-j))

;; ;;;###autoload
;; (defun exwm-sm-core-xxx ()
;;   "xxx"
;;   (interactive)
;;   (exwm-input--fake-key 'xxx))

;;;###autoload
(defun exwm-sm-core-extract ()
  "Extract selected text"
  (interactive)
  (exwm-input--fake-key 'M-x))

;;;###autoload
(defun exwm-sm-core-neural ()
  "Go neural"
  (interactive)
  (exwm-input--fake-key 'C-f2))


;;; Misc
;;;###autoload
(defun exwm-sm-core-cancel ()
  "General cancel action."
  (interactive)
  ;; Needs to get user out of search bar, this is the only way i've found to do it
  (exwm-input--fake-key 'escape)
  (exwm-input--fake-key 'tab))

;;;###autoload
(defun exwm-sm-core-open-file ()
  "Open file."
  (interactive)
  (exwm-input--fake-key ?\C-o))

;;;###autoload
(defun exwm-sm-core-quit ()
  "Quit sm."
  (interactive)
  (exwm-input--fake-key ?\C-q))

(provide '+exwm-sm-core)
#+end_src

#+RESULTS:
: +exwm-sm-core

* sm-evil
:PROPERTIES:
:CREATED:  [2020-11-21 Sat 10:31]
:ID:       c792bb4f-4d32-4eaf-a7b4-aa521e5dfcde
:END:

#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-evil.el
;;; desktop/exwm/+exwm-sm-evil.el -*- lexical-binding: t; -*-

(require 'evil)
(require 'evil-core)
(require '+exwm-sm-core)

;; (defvar exwm-sm-evil-sm-class-name '("Excel" "excel.exe" "WineDesktop - Wine desktop" "explorer.exe" "Wine" "Wine desktop")
;;   "The class name use for detecting if a SM buffer is selected.")

(defvar exwm-sm-evil-sm-buffer-name '(sm-element-window)
  "The buffer name used for detecting if a SM buffer is selected.")

;;; State transitions
(defun exwm-sm-evil-normal ()
  "Pass every key directly to Emacs."
  (interactive)
  (setq-local exwm-input-line-mode-passthrough t)
  (evil-normal-state))

(defun exwm-sm-evil-insert ()
  "Pass every key to SM."
  (interactive)
  (setq-local exwm-input-line-mode-passthrough nil)
  (evil-insert-state))

(defun exwm-sm-evil-exit-visual ()
  "Exit visual state properly."
  (interactive)
  ;; Unmark any selection
  (exwm-sm-core-left)
  (exwm-sm-core-right)
  (exwm-sm-evil-normal))

(defun exwm-sm-evil-visual-change ()
  "Change text in visual mode."
  (interactive)
  (exwm-sm-core-cut)
  (exwm-sm-evil-insert))

;;; Keys
(defvar exwm-sm-evil-mode-map (make-sparse-keymap))

;; Bind normal
(define-key exwm-sm-evil-mode-map [remap evil-exit-visual-state] 'exwm-sm-evil-exit-visual)
(define-key exwm-sm-evil-mode-map [remap evil-normal-state] 'exwm-sm-evil-normal)
(define-key exwm-sm-evil-mode-map [remap evil-force-normal-state] 'exwm-sm-evil-normal)
;; Bind insert
(define-key exwm-sm-evil-mode-map [remap evil-insert-state] 'exwm-sm-evil-insert)
(define-key exwm-sm-evil-mode-map [remap evil-insert] 'exwm-sm-evil-insert)
(define-key exwm-sm-evil-mode-map [remap evil-substitute] 'exwm-sm-evil-insert)
(define-key exwm-sm-evil-mode-map [remap evil-append] 'exwm-sm-evil-insert)

        ;;;; Normal
;; Basic movements
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "k") 'exwm-sm-core-up)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "j") 'exwm-sm-core-down)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "h") 'exwm-sm-core-left)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "l") 'exwm-sm-core-right)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "K") 'exwm-sm-core-goto-parent)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "J") 'exwm-sm-core-goto-child)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "H") 'exwm-sm-core-back)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "L") 'exwm-sm-core-forward)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "/") 'exwm-sm-core-find)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "t") 'exwm-sm-core-test)

;;; Editing text
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "y") 'exwm-sm-core-copy)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "d") 'exwm-sm-core-cut)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "p") 'exwm-sm-core-paste)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "u") 'exwm-sm-core-undo)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "R") 'exwm-sm-core-redo)
;; Editing elements
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "e") 'exwm-sm-core-answer)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "E") 'exwm-sm-core-question)

;;; Learn operations
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "d") 'exwm-sm-core-contents-dismiss-element)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "x") 'exwm-sm-core-extract)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "X") 'exwm-sm-core-schedule-extract)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "SPC") 'exwm-sm-core-learn)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd ",") 'nanjigen/sm-hydra/body)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "<return>") 'exwm-sm-core-rep)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "P") 'exwm-sm-core-prioritize)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "s") 'exwm-sm-core-reschedule)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "o") 'exwm-sm-core-get-filepath)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "r") 'exwm-sm-core-replay)


(map! :map exwm-sm-evil-mode-map
      :n "SPC" #'exwm-sm-core-learn)


;;; Mode
;;;###autoload
(define-minor-mode exwm-sm-evil-mode nil nil nil exwm-sm-evil-mode-map
  (if exwm-sm-evil-mode
      (progn
        (exwm-sm-evil-normal))))

;;;###autoload
(defun exwm-sm-evil-activate-if-sm ()
  "Activates exwm-sm mode when buffer is SM.
SM variant can be assigned in 'exwm-sm-evil-sm-name`"
  (interactive)
  (if (member exwm-class-name exwm-sm-evil-sm-buffer-name)
      (exwm-sm-evil-mode 1)))

(provide '+exwm-sm-evil)

;;; +exwm-sm-evil.el ends here
#+end_src

#+RESULTS:
: +exwm-sm-evil
* sm-hydra
:PROPERTIES:
:CREATED:  [2021-04-20 Tue 15:49]
:ID:       70ea4d74-e725-4448-b1fe-10c10eaa5a9a
:END:

By using a =hydra-title= like [[file:~/.emacs.d/.local/straight/repos/org-media-note/org-media-note.el::defun org-media-note--hydra-title (][here]], I can have commands run in the background to influence the names of hydra commands.
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+sm-hydra.el
;;; desktop/exwm/+sm-hydra.el -*- lexical-binding: t; -*-
(pretty-hydra-define nanjigen/sm-hydra
  (:color red
   ;; :title (--hydra-title)
   :hint nil)
  ("Learn"
   (("rr" (exwm-sm-core-remember) "Remember")
    ("c" (exwm-sm-core-cancel-grade) "Undo grading")
    ("s" (nanjigen/sm-subset-hydra/body) "Subset operations")
    ("rs" (exwm-sm-core-set-read-point) "Set read point")
    ("m" (exwm-sm-core-mercy) "Mercy")
    ("S" (exwm-sm-core-sorting-criteria) "Sorting Criteria"))
  "Editing"
   (("i" (exwm-sm-core-italic) "italics")
    ("b" (exwm-sm-core-bold) "bold")
    ("q" (exwm-sm-core-edit-question) "Edit Question")
    ("a" (exwm-sm-core-edit-answer) "Edit Answer")
    ("n" (exwm-sm-core-edit-answer) "Edit Next Component")
    ("f" (exwm-sm-core-edit-file) "Edit File"))
  "Misc"
   (("SPC" (exwm-sm-core-sm-commander) "SuperMemo Commander")
    ("rc" (exwm-sm-core-repair-collection) "Repair Collection")
    ("rl" (exwm-sm-core-restore-layout) "Restore layout")
    ("A" (exwm-sm-core-statistics-analysis) "Stats window"))))

#+end_src

#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+sm-hydra.el
;;; desktop/exwm/+sm-hydra.el -*- lexical-binding: t; -*-
(pretty-hydra-define nanjigen/sm-subset-hydra
  (:color red
   ;; :title (--hydra-title)
   :hint nil)
  ("Learn"
   (("b" (exwm-sm-core-branch-learning) "Branch learning")
    ("r" (exwm-sm-core-random-learning) "Random learning")
    ("t" (exwm-sm-core-random-test) "Random test")
    ("n" (exwm-sm-core-neural) "Go neural")
    ("s" (exwm-sm-core-subset-learning) "Subset learning"))))

#+end_src

* AHK
:PROPERTIES:
:CREATED:  [2020-11-30 Mon 17:08]
:ID:       8d766356-bb00-4536-8974-6906b6c2837f
:END:

A good guide for ahk under linux https://code.google.com/archive/p/winetricks/wikis/AutoHotkey.wiki
#+begin_src ahk :tangle ~/.scripts/ahk/activate.verb :mkdirp yes
w_metadata activate apps \
title="Hello, Autohotkey"

load_activate()
{
w_ahk_do "
;WinActivate, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
run, notepad.exe
WinWait, Untitled - Notepad
;ControlSend, lol, Test, ahk_class TElWind
;ControlSend, Test2, {v}, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
;j::
;WinActivate, ahk_exe sm18.exe
;WinGetActiveTitle, Title
;WinGetClass, Var, A
;MsgBox ahk_class %Var%
;MsgBox, The active window is "%Title%".
send, l
;return
"
}
#+end_src

Finding the class of a window
#+begin_src ahk :tangle ~/.scripts/ahk/class.verb :mkdirp yes
w_metadata class apps \
title="Hello, Autohotkey"

load_class()
{
w_ahk_do "
j::
;WinActivate, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
;WinActivate, ahk_class sm18.exe
WinGetActiveTitle, Var
;WinGetClass, Var, A
;ControlGet, Var, A
;MsgBox ahk_class %Var%
MsgBox, The active window is "%Var%".
;send, l
return
"
}
#+end_src

Testing some sending code
#+begin_src ahk :tangle ~/.scripts/ahk/send.verb :mkdirp yes
w_metadata send apps \
title="Hello, Autohotkey"

load_send()
{
w_ahk_do "
;j::
;WinActivate, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
;#IfWinActive, ahk_class, Notepad
;ControlSend, Edit1, Test, WinTitle, Untitled - Notepad
;ControlSend, Edit1, Test, Untitled - Notepad
ControlSend, Edit1, Test, home
;WinGetActiveTitle, Var
;WinGetClass, Var, A
;MsgBox ahk_class %Var%
;MsgBox, The active window is "%Var%".
;send, l
;return
"
}
#+end_src

This works well for copying the element path
#+begin_src ahk :tangle ~/.scripts/ahk/senda.verb :mkdirp yes
w_metadata senda apps \
title="Hello, Autohotkey"

load_senda()
{
w_ahk_do "
#NoEnv  ; Recommended for performance and compatibility with future AutoHotkey releases.
; #Warn  ; Enable warnings to assist with detecting common errors.
SendMode Input  ; Recommended for new scripts due to its superior speed and reliability.
;SetWorkingDir %A_ScriptDir%  ; Ensures a consistent starting directory.
SetTitleMatchMode,2
;WinActivate, ahk_exe sm18.exe
;WinWaitActive, ahk_exe sm18.exe
;WinActivate, ahk_class TElWind
;WinWaitActive, WinTitle Untitled - Notepad
#IfWinActive, ahk_class TElWind

::sm-get-path::
send, +{F10}
;sleep,5
send, f
;sleep,5
send, c
;send, ^a
"
}
#+end_src
z:\\home\\vrika\\documents\\sm\\neuron\\elements\\16\\168.HTM
z:\home\vrika\documents\sm\neuron\elements\16\168.HTM
file:/home/vrika/Documents/SM/neuron/elements/16/167.HTM

Change windows path to unix:

#+begin_src elisp
;; (defun my-translate-winpath ()
  ;; (interactive)
  ;; "change :C\win\path to 'nix /path/path"
  (let ((path (current-kill 0 'do-not-move)))
    (shell-command-to-string (format "~/.scripts/winpath.sh %s" path)))
#+end_src

#+begin_src elisp
(defun my-translate-winpath ()
  (interactive)
  (progn
  ;; (shell-command "sh ~/.scripts/xdotool/get_element_path.sh")
  (shell-command "xclip -sel clip -o")
  (shell-command "xdotool sleep 0.2 key --delay 50 shift+F10+f+c")
;; (gui--selection-value-internal 'CLIPBOARD)
  (setq sm-path (gui--selection-value-internal 'CLIPBOARD))
    (let* ((path1 (s-chop-prefix "z:" sm-path))
           (nixpath (s-replace "\\" "/" path1))
           (docpath (s-replace "documents" "Documents" nixpath))
           (finpath (s-replace "sm" "SM" docpath)))
      (setq sm-path-nix finpath))))
;; (list path path2)
;; (shell-command-to-string (format "~/.scripts/winpath.sh" ))
#+end_src

#+RESULTS:
: my-translate-winpath

#+begin_src elisp
(defun exwm-sm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
  (my-exwm-send-string "sm-get-path ")
  (sit-for 0.3)
  (let ((path (my-translate-winpath)))
    (find-file path)))
#+end_src

#+RESULTS:
: my-translate-winpath

#+begin_src elisp
(defun my-exwm-send-string (string)
  "Send STRING to `exwm-mode' buffer or just insert it."
  (if (eq major-mode 'exwm-mode)
      (mapc #'exwm-input--fake-key (string-to-list string))
    (insert string)))
#+end_src
z:\home\vrika\documents\sm\neuron\elements\5.HTM
#+RESULTS:
: my-exwm-send-string

#+begin_src elisp
;; (subst-char-in-string ?\ ?/ (regexp-quote "\home"))
;; (regexp-quote "^home")
;; (convert-standard-filename "z:\home\vrika\documents\sm\neuron\elements\16\168.HTM")
;; (setq windows-path (unescape-windows-path "\home\vrika"))

;; (setq windows-path1 "\home\vrika")
;; (wsl-path-convert-file-name "\home\vrika")
;; (s-replace "\\" "/" "\home")
;; (s-replace "\\" "/" windows-path)
;; (replace-regexp-in-string "\\\\" "\\\\\\\\" "\home\vrika")
;; (message windows-path1)
;; (defun unescape-windows-path (pth)
;;   ;; (interactive "*sWindows path:")
;;    (replace-regexp-in-string "\\\\" "\\\\\\\\" pth))

;; (defun paste-windows-path (pth)
;;   (interactive "*sWindows path:")
;;   (insert
;;    (replace-regexp-in-string "\\\\" "\\\\\\\\" pth)))
;; (message (current-kill 0 'do-not-move))
;; (shell-command-to-string "sed -e 's#^J:##' -e 's#\\#/#g' <<< 'test'")

(convert-standard-filename "~/Documents")
#+end_src

#+RESULTS:
: ~/Documents

#+begin_src sh :tangle ~/.scripts/winpath.sh
function winpath(){
    line=$(sed -e 's#^J:##' -e 's#\\#/#g' <<< "$1")
    echo "$line"
}
#+end_src

#+begin_src sh
#!/bin/bash
clip=$(xclip -selection c -o)
line=$(sed -e 's#^z:##' -e 's#\\#/#g' <<< "$clip")
echo "$line"
#+end_src

#+RESULTS:

#+begin_src ahk :tangle ~/.scripts/ahk/hotstring.verb :mkdirp yes
w_metadata hotstring apps \
title="Hello, Autohotkey"

load_hotstring()
{
w_ahk_do "
:*:get::get it boi
"
}
#+end_src

#+begin_src sh :dir ~/.scripts/ahk/ :session test
env WINEPREFIX=/home/vrika/.local/share/wineprefixes/supermemo18 winetricks activate.verb
#+end_src

#+RESULTS:
|                                              |               |                       |                                     |            |                                                                  |        |          |     |                |
| Executing                                    | mkdir         | -p                    | /home/vrika/.local/share/wineprefixes |            |                                                                  |        |          |     |                |
| Using                                        | winetricks    | 20200412              | -                                   | sha256sum: | 40ff4c67804584b73d4d36153e1f64ca426d739f1790bd748f5ded0865e8cc7f | with   | wine-5.2 | and | WINEARCH=win32 |
| Executing                                    | w_do_call     | activate              |                                     |            |                                                                  |        |          |     |                |
| Executing                                    | mkdir         | -p                    | /home/vrika/.local/share/wineprefixes |            |                                                                  |        |          |     |                |
| Executing                                    | load_activate |                       |                                     |            |                                                                  |        |          |     |                |
| Executing                                    | wine          | x:\ahk\AutoHotkey.exe | C:\windows\Temp\activate.ahk        |            |                                                                  |        |          |     |                |
| 00b9:fixme:keyboard:X11DRV_GetKeyboardLayout | couldn't      | return                | keyboard                            | layout     | for                                                              | thread |       81 |     |                |

** Snippet
:PROPERTIES:
:CREATED:  [2020-12-01 Tue 22:38]
:ID:       e177ba0d-cfc1-41d7-bc09-4b2e3a1edef9
:END:

#+begin_src yas
# -*- mode: snippet -*-
# name: SuperMemo Ref
# key: sm-ref
# --

#SuperMemo Reference:
#Title: (org-web-tools--html-title (org-web-tools--get-first-url))
#Date: Imported on Oct 15, 2020, 18:50:29
#Source: Wikipedia
#Link: (org-web-tools--get-first-url)
#Comment: Lisp (programming language)
#Parent: 17: Programming
#Concept group: Root: neuron (1: neuron)
#+end_src

* sm desktop
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:36]
:ID:       c5515f7e-a0c6-40d8-8b60-36b4334874ad
:END:
.desktop file:
#+begin_src conf
[Desktop Entry]
Name=SuperMemo 18 (ms-office)
Exec=env WINEPREFIX="/home/volk/.local/share/wineprefixes/ms-office" wine "/home/volk/.local/share/wineprefixes/ms-office/drive_c/SuperMemo/sm18.exe"
Type=Application
Categories=Education;
StartupNotify=true
Comment=Organize your knowledge and learn at the maximum possible speed
Path=/home/volk/.local/share/wineprefixes/ms-office/drive_c/SuperMemo
Icon=/home/volk/.local/share/wineprefixes/ms-office/drive_c/SuperMemo/smicon.png
StartupWMClass=sm18.exe
#+end_src

* SM in a VM and RPC
:PROPERTIES:
:CREATED:  [2020-12-11 Fri 21:15]
:ID:       fafd87f0-c7c8-467d-861c-d0fc634d9893
:END:

* SM with Emacs
:PROPERTIES:
:CREATED:  [2021-01-04 Mon 15:52]
:ID:       a04ab1f5-a77b-4dec-8c59-3276246dfb88
:END:

** sm yasnippet
:PROPERTIES:
:CREATED:  [2021-01-04 Mon 15:52]
:ID:       9fd2197d-3730-458d-ad94-c90d7309d355
:END:

#+begin_src yasnippet
# -*- mode: snippet -*-
# name: org-pdftools-sm-reference
# key: pdf-ref
# --

#SuperMemoReference
#Title:
#Author:
#Date: Imported on Dec 28, 2020, 00:00:00
#Source: (org-ref) bibtex?
#Link: pdf:
#Comment:
#Article: 40:
#Concept group: Root: neruon (1: neuron)
#+end_src

* SM (linux) mpv prototyping                                           :ATTACH:
:PROPERTIES:
:CREATED:  [2021-01-14 Thu 20:03]
:ID:       d3b44770-6bb2-4675-b451-3f388e0cb6da
:END:

An alternative to scripting with =lua= would be using the =fennel= language.

** TODO Embed fennel in mpv lua module
:PROPERTIES:
:CREATED:  [2021-08-14 Sat 12:34]
:ID:       34ae3659-6881-476b-a132-0a3863ad8064
:END:

https://gitlab.com/technomancy/fennel-mode/-/blob/master/Readme.md
https://fennel-lang.org/setup#embedding-fennel

** mpv input.conf
:PROPERTIES:
:CREATED:  [2021-01-31 Sun 11:17]
:ID:       8c4df6c5-9b2b-4352-a1bc-31a11e4fd1b9
:END:
#+begin_src lua :tangle ~/.config/mpv/input.conf
# mpv keybindings
#
# Location of user-defined bindings: ~/.config/mpv/input.conf
#
# Lines starting with # are comments. Use SHARP to assign the # key.
# Copy this file and uncomment and edit the bindings you want to change.
#
# List of commands and further details: DOCS/man/input.rst
# List of special keys: --input-keylist
# Keybindings testing mode: mpv --input-test --force-window --idle
#
# Use 'ignore' to unbind a key fully (e.g. 'ctrl+a ignore').
#
# Strings need to be quoted and escaped:
#   KEY show-text "This is a single backslash: \\ and a quote: \" !"
#
# You can use modifier-key combinations like Shift+Left or Ctrl+Alt+x with
# the modifiers Shift, Ctrl, Alt and Meta (may not work on the terminal).
#
# The default keybindings are hardcoded into the mpv binary.
# You can disable them completely with: --no-input-default-bindings

# Developer note:
# On compilation, this file is baked into the mpv binary, and all lines are
# uncommented (unless '#' is followed by a space) - thus this file defines the
# default key bindings.

# If this is enabled, treat all the following bindings as default.
#default-bindings start

#MBTN_LEFT     ignore              # don't do anything
#MBTN_LEFT_DBL cycle fullscreen    # toggle fullscreen on/off
#MBTN_RIGHT    cycle pause         # toggle pause on/off
#MBTN_BACK     playlist-prev
#MBTN_FORWARD  playlist-next

# Mouse wheels, touchpad or other input devices that have axes
# if the input devices supports precise scrolling it will also scale the
# numeric value accordingly
#WHEEL_UP      seek 10
#WHEEL_DOWN    seek -10
#WHEEL_LEFT    add volume -2
#WHEEL_RIGHT   add volume 2

## Seek units are in seconds, but note that these are limited by keyframes
RIGHT seek  5
LEFT  seek -5
UP    seek  60
DOWN  seek -60
# Do smaller, always exact (non-keyframe-limited), seeks with shift.
# Don't show them on the OSD (no-osd).
Shift+RIGHT no-osd seek  1 exact
Shift+LEFT  no-osd seek -1 exact
Shift+UP    no-osd seek  5 exact
Shift+DOWN  no-osd seek -5 exact
# Skip to previous/next subtitle (subject to some restrictions; see manpage)
Ctrl+LEFT   no-osd sub-seek -1
Ctrl+RIGHT  no-osd sub-seek  1
# Adjust timing to previous/next subtitle
Ctrl+Shift+LEFT sub-step -1
Ctrl+Shift+RIGHT sub-step 1
# Move video rectangle
Alt+left  add video-pan-x  0.1
Alt+right add video-pan-x -0.1
Alt+up    add video-pan-y  0.1
Alt+down  add video-pan-y -0.1
# Zoom/unzoom video
Alt++     add video-zoom   0.1
Alt+-     add video-zoom  -0.1
# Reset video zoom/pan settings
#Alt+BS set video-zoom 0 ; set video-pan-x 0 ; set video-pan-y 0
PGUP add chapter 1                     # skip to next chapter
PGDWN add chapter -1                   # skip to previous chapter
#Shift+PGUP seek 600
#Shift+PGDWN seek -600
[ multiply speed 1/1.1                 # scale playback speed
] multiply speed 1.1
{ multiply speed 0.5
} multiply speed 2.0
BS set speed 1.0                       # reset speed to normal
Shift+BS revert-seek                   # undo previous (or marked) seek
Shift+Ctrl+BS revert-seek mark         # mark position for revert-seek
q quit
#Q quit-watch-later
#q {encode} quit 4
ESC set fullscreen no
#ESC {encode} quit 4
#p cycle pause                          # toggle pause/playback mode
. frame-step                           # advance one frame and pause
, frame-back-step                      # go back by one frame and pause
SPACE cycle pause
#> playlist-next                        # skip to next file
#ENTER playlist-next                    # skip to next file
#< playlist-prev                        # skip to previous file
O no-osd cycle-values osd-level 3 1    # cycle through OSD mode
o show-progress
P show-progress
i script-binding stats/display-stats
I script-binding stats/display-stats-toggle
` script-binding console/enable
z add sub-delay -0.1                   # subtract 100 ms delay from subs
Z add sub-delay +0.1                   # add
x add sub-delay +0.1                   # same as previous binding (discouraged)
#ctrl++ add audio-delay 0.100           # this changes audio/video sync
#ctrl+- add audio-delay -0.100
m cycle mute
1 add contrast -1
2 add contrast 1
3 add brightness -1
4 add brightness 1
5 add gamma -1
6 add gamma 1
7 add saturation -1
8 add saturation 1
Alt+0 set window-scale 0.5
Alt+1 set window-scale 1.0
Alt+2 set window-scale 2.0
# toggle deinterlacer (automatically inserts or removes required filter)
d cycle deinterlace
r add sub-pos -1                       # move subtitles up
R add sub-pos +1                       #                down
t add sub-pos +1                       # same as previous binding (discouraged)
v cycle sub-visibility
# stretch SSA/ASS subtitles with anamorphic videos to match historical
V cycle sub-ass-vsfilter-aspect-compat
# switch between applying no style overrides to SSA/ASS subtitles, and
# overriding them almost completely with the normal subtitle style
u cycle-values sub-ass-override "force" "no"
j cycle sub                            # cycle through subtitles
J cycle sub down                       # ...backwards
#SHARP cycle audio                      # switch audio streams
#_ cycle video
#T cycle ontop                          # toggle video window ontop of other windows
f cycle fullscreen                     # toggle fullscreen
s screenshot                           # take a screenshot
S screenshot video                     # ...without subtitles
Ctrl+s screenshot window               # ...with subtitles and OSD, and scaled
Alt+s screenshot each-frame            # automatically screenshot every frame
w add panscan -0.1                     # zoom out with -panscan 0 -fs
W add panscan +0.1                     #      in
e add panscan +0.1                     # same as previous binding (discouraged)
# cycle video aspect ratios; "-1" is the container aspect
A cycle-values video-aspect-override "16:9" "4:3" "2.35:1" "-1"
#POWER quit
#PLAY cycle pause
#PAUSE cycle pause
#PLAYPAUSE cycle pause
#PLAYONLY set pause no
#PAUSEONLY set pause yes
#STOP quit
#FORWARD seek 60
#REWIND seek -60
#NEXT playlist-next
#PREV playlist-prev
#VOLUME_UP add volume 2
#VOLUME_DOWN add volume -2
#MUTE cycle mute
#CLOSE_WIN quit
#CLOSE_WIN {encode} quit 4
#E cycle edition                        # next edition
l ab-loop                              # Set/clear A-B loop points
L cycle-values loop-file "inf" "no"    # toggle infinite looping
#ctrl+c quit 4
DEL script-binding osc/visibility      # cycle OSC display
#ctrl+h cycle-values hwdec "auto" "no"  # cycle hardware decoding
F8 show_text ${playlist}               # show playlist
F9 show_text ${track-list}             # show list of audio/sub streams

#
# Legacy bindings (may or may not be removed in the future)
#
#! add chapter -1                       # skip to previous chapter
#@ add chapter 1                        #         next

#
# Not assigned by default
# (not an exhaustive list of unbound commands)
#

# ? add sub-scale +0.1                  # increase subtitle font size
# ? add sub-scale -0.1                  # decrease subtitle font size
# ? cycle angle                         # switch DVD/Bluray angle
# ? cycle sub-forced-only               # toggle DVD forced subs
# ? cycle program                       # cycle transport stream programs
# ? stop                                # stop playback (quit or enter idle mode)

CTRL+SHIFT+p script-message chapterlist

# g run "home/volk/.config/mpv/scripts/giffer" "${path}" "/home/volk/Videos/${filename/no-ext} ${=ab-loop-a}.gif" "${=ab-loop-a}" "${=ab-loop-b}"
# h run "home/volk/.config/mpv/scripts/giffer" "${path}" "/home/volk/Videos" "${=ab-loop-a}" "${=ab-loop-b}"

#+end_src

An alternative to scripting with =lua= would be using the =fennel= language.

* elisp/subed and mpv
:PROPERTIES:
:CREATED:  [2021-01-15 Fri 23:31]
:ID:       663ed322-7c31-4970-b586-b5ea9442766d
:END:
I really like ~emms's~ implementation of functions and its single IPC socket. But [[https://github.com/rndusr/org-mpv-noter/README.org][subed-mpv]] also seems to have a pretty robust setup in part based on emms-player. The [[https://github.com/rndusr/org-mpv-noter/blob/master/org-mpv-noter/org-mpv-noter.el][sub-mpv.el]] has *389* LOC while emms-player-mpv.el has *800*, but that includes ~emms~ specific code.

We'll collect various bits of code from both projects to create a ~org-mpv-noter/org-noter~ like note taker for videos and ~org~.

My current thinking is to emulate ~org-noter~ / ~pdf-tools~ in using links in =:PROPERTIES:= drawers. This links will include time stamp data, much like ~org-emms~. Ideally, moving through the video should move point in the ~org~ buffer relative to the link, expanding the relevant header. Conversely, moving through the headlines with define chords should move the video to the linked time stamp.

An alternative to this method would be doing something like what [[https://github.com/kljohann/mpv.el/wiki][mpv.el]] does and piggyback =org-timer-item=, inserting timestamps into the buffer with comments styling:

#+begin_example
- 0:02:21 :: Finding the smallest and second smallest element.
#+end_example

A potential hurdle is that many notes may not be references to specific timestamps, but rather time ranges, with timestamps indicating start and end times:

#+begin_example
,** He kicks the guy twice
:PROPERTIES:
:NOTER_TIME: [[mpv:/attach/6c/e1fbc4-9e20-4079-ac1e-b4ecfc4da3e7/video.mpg::a=0:43;;b=1:10]]
:CREATED:  [2021-01-29 Fri 15:55]
:ID:       6ce1fbc4-9e20-4079-ac1e-b4ecfc4da3e7
:END:

#+end_example
Or,
#+begin_example
- 0:00:43 => 0:01:10 :: He kicks the guy twice
#+end_example

Consider this against the link formatting of org-noter and emms-org:
#+begin_example
,** cite:laufer2001 annot-7-1
:PROPERTIES:
:NOTER_PAGE: [[pdf:~/Documents/PDF/laufer2001.pdf::7++0.00;;annot-7-1]]
:END:

[[emms:/path/to/audio.mp3::2:43]]     Starts playback at 2 min 43 sec.
#+end_example

Perhaps we can combine the ~org-timer~ approach with ~emms-org~ style org links:

- [[mpv:~/org/.attach/f7/fe51f3-e9f3-4961-8d75-29f4e71f295d/1-201kuden\[sei_za_rei_kuden\].mpg][0:00:14]] :: fucks the guy up


#+begin_example
--ab-loop-a=<time>, --ab-loop-b=<time>

    Set loop points. If playback passes the b timestamp, it will seek to the a timestamp. Seeking past the b point doesn't loop (this is intentional).

    If a is after b, the behavior is as if the points were given in the right order, and the player will seek to b after crossing through a. This is different from old behavior, where looping was disabled (and as a bug, looped back to a on the end of the file).

    If either options are set to no (or unset), looping is disabled. This is different from old behavior, where an unset a implied the start of the file, and an unset b the end of the file.

    The loop-points can be adjusted at runtime with the corresponding properties. See also ab-loop command.

#+end_example

** org-emms
:PROPERTIES:
:CREATED:  [2021-01-29 Fri 18:02]
:ID:       6a343b44-8462-4436-8e05-6d8c7066d94d
:END:

License
#+begin_src elisp
;;; org-emms.el --- Play multimedia files from org-mode -*- lexical-binding: t; -*-

;; Copyright (C) 2016-2018 Jonathan Gregory

;; Author: Jonathan Gregory <jgrg at autistici dot org>
;; Version: 0.1
;; URL: https://gitlab.com/jagrg/org-emms
;; Keywords: multimedia
;; Package-Requires: ((emacs "24"))

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
#+end_src

#+begin_src elisp
;;; Commentary:

;; This package provides a new org link type for playing back
;; multimedia files from org-mode using EMMS, The Emacs Multimedia
;; System. If the link contains a track position, playback will start
;; at the specified position. For example:

;; [[emms:/path/to/audio.mp3::2:43]]     Starts playback at 2 min 43 sec.
;; [[emms:/path/to/audio.mp3::1:10:45]]  Starts playback at 1 hr 10 min 45 sec.
;; [[emms:/path/to/audio.mp3::49]]       Starts playback at 0 min 49 sec.

;; The two main commands are `org-emms-insert-track' and
;; `org-emms-insert-track-position'. The latter is especially useful
;; for aligning text with audio when transcribing spoken language.

;; It is also possible to make a usual org link (with `org-store-link'
;; command) from EMMS playlist and browser buffers, and then insert it
;; into an org-mode buffer (with `org-insert-link' command).

;; See also: http://orgmode.org/worg/code/elisp/org-player.el

;;; Code:

(require 'org)
(require 'emms)
(require 'emms-playing-time)

(defgroup org-emms nil
  "Connection between EMMS and `org-mode'."
  :prefix "org-emms-"
  :group 'multimedia)

(defcustom org-emms-default-directory nil
  "A directory where multimedia files are stored."
  :type 'directory
  :group 'org-emms)

(defcustom org-emms-delay 0
  "Time in seconds between starting playing and seeking to time.
If your org link has a track position, but the EMMS player does
not start playing at that position, most likely the problem is
that it starts seeking before the player starts playing.  If this
is your case, set this variable to 1 or 2 seconds."
  :type 'integer
  :group 'org-emms)

(defcustom org-emms-time-format "%.2h:%.2m:%.2s"
  "Format string for a track position in org links.
This string is passed to `format-seconds' function."
  :type 'string
  :group 'org-emms)

(defun org-emms-time-string-to-seconds (s)
  "Convert timestring S (\"HH:MM:SS\") to a number of seconds.
Hours, minutes and leading zeros are optional."
  (save-match-data
    (if (stringp s)
	(if (string-match "\\([0-9]+:\\)?\\([0-9]+\\):\\([0-9]+\\)" s)
	    (let ((hh (if (match-beginning 1) (string-to-number (match-string 1 s)) 0))
		  (mm (string-to-number (match-string 2 s)))
		  (ss (string-to-number (match-string 3 s))))
	      (+ (* hh 3600) (* mm 60) ss))
	  (string-to-number s))
      s)))

(defun org-emms-play (file)
  "Play multimedia FILE from `org-mode'.
If link contains a track position, start there.  Otherwise, playback
from the start."
  (let* ((path (split-string file "::"))
	 (file (expand-file-name (car path)))
	 (time (org-emms-time-string-to-seconds (cadr path))))
    ;; Do not start a track again (just seek to time) if we want to open
    ;; a link with the currently playing track.
    (unless (and emms-player-playing-p
                 (string= file
                          (emms-track-name
                           (emms-playlist-current-selected-track))))
      (emms-play-file file)
      (and time
           (> org-emms-delay 0)
           (sleep-for org-emms-delay)))
    (when time
      (emms-seek-to time))))

(org-link-set-parameters
 "emms"
 :follow #'org-emms-play
 :store #'org-emms-store-link)

(defun org-emms-make-link ()
  "Return org link for the the current EMMS track.
The return value is a cons cell (link . description)."
  (let ((track (emms-playlist-current-selected-track)))
    (cons (concat "emms:" (emms-track-name track)
                  (and (/= 0 emms-playing-time)
                       (concat "::"
                               (format-seconds org-emms-time-format
                                               emms-playing-time))))
          (emms-info-track-description track))))

(defun org-emms-store-link ()
  "Store org link for the current playing file in EMMS."
  (when (derived-mode-p 'emms-playlist-mode
                        'emms-browser-mode)
    (let ((link (org-emms-make-link)))
      (org-store-link-props
       :type        "emms"
       :link        (car link)
       :description (cdr link)))))

;;;###autoload
(defun org-emms-insert-link (arg)
  "Insert org link using completion.
Prompt for a file name and link description.  With a prefix ARG, prompt
for a track position."
  (interactive "P")
  (let ((file (read-file-name "File: " org-emms-default-directory)))
    (if arg
	(let ((tp (read-string "Track position (hh:mm:ss): ")))
	  (insert (format "[[emms:%s::%s][%s]]" (file-relative-name file) tp tp)))
      (let ((desc (read-string "Description: ")))
	(insert
	 (if (equal desc "")
	     (format "[[emms:%s]]" (file-relative-name file) desc)
	   (format "[[emms:%s][%s]]" (file-relative-name file) desc)))))))

;;;###autoload
(defun org-emms-insert-track ()
  "Insert current selected track as an org link."
  (interactive)
  (let* ((track (emms-playlist-current-selected-track))
	 (file (emms-track-name track))
	 (title (emms-track-get track 'info-title)))
    (when (derived-mode-p 'org-mode)
      (insert
       (format "[[emms:%s][%s]]" file title)))))

;;;###autoload
(defun org-emms-insert-track-position ()
  "Insert current track position as an org link."
  (interactive)
  (let* ((track (emms-playlist-current-selected-track))
	 (file (emms-track-name track))
	 (tp (format-seconds org-emms-time-format emms-playing-time)))
    (insert
     (if (derived-mode-p 'org-mode)
	 (format "[[emms:%s::%s][%s]]" file tp tp)
       (format "[%s]" tp)))))

(provide 'org-emms)
;;; org-emms.el ends here
#+end_src

** org-mpv-noter-config.el
:PROPERTIES:
:CREATED:  [2021-01-18 Mon 13:36]
:ID:       cf25ad44-f9a7-4790-a296-2c2075ce97a3
:END:
Defining ~org-mpv-noter~ major mode,

Some useful looking code for looping:
#+begin_src elisp
;;; Commentary:

;; Customization variables, hooks, keybindings, etc for org-mpv-noter-mode.

;;; Code:

(defgroup org-mpv-noter nil
  "Major mode for note taking videos."
  :group 'files
  :group 'multimedia
  :prefix "org-mpv-noter-")

(defvar-local org-mpv-noter--subtitle-format nil
  "Short form of the name of the subtitle format in the current buffer (e.g. \"srt\").")

(defvar org-mpv-noter--init-alist '(("srt" . org-mpv-noter-srt--init)
                            ("vtt" . org-mpv-noter-vtt--init))
  "Alist that maps file extensions to format-specific init functions.")

;; This variable is set in org-mpv-noter.el to avoid compiler warnings because it uses
;; functions defined in org-mpv-noter-common.el, and (require 'org-mpv-noter-common) results in
;; recursive requires.
(defvar org-mpv-noter-mode-map nil
  "Keymap for org-mpv-noter-mode.")

;; Variables

(defvar-local org-mpv-noter-debugging-enabled-p nil
  "Whether debugging messages are displayed.")

(defcustom org-mpv-noter-debug-buffer "*org-mpv-noter-debug*"
  "Name of the buffer that contains debugging messages."
  :type 'string
  :group 'org-mpv-noter)

(defcustom org-mpv-noter-mode-hook nil
  "Functions to call when entering org-mpv-noter mode."
  :type 'hook
  :group 'org-mpv-noter)

(defcustom org-mpv-noter-video-extensions '("mkv" "mp4" "m4v" "webm" "avi" "ts" "ogv")
  "Video file name extensions."
  :type 'list
  :group 'org-mpv-noter)
#+end_src

#+RESULTS:
: org-mpv-noter-video-extensions

How to adapt this? Incorporate org-noter code
#+begin_src elisp
(defcustom org-mpv-noter-auto-find-video t
  "Whether to open the video automatically when opening a subtitle file."
  :type 'boolean
  :group 'org-mpv-noter)


(defcustom org-mpv-noter-milliseconds-adjust 100
  "Milliseconds to add or subtract from start/stop time.
This variable is used when adjusting, moving or shifting
subtitles without a prefix argument.
This variable is set when adjusting, moving or shifting subtitles
with a prefix argument.  See `org-mpv-noter-increase-start-time' for
details.
Use `setq-default' to change the default value of this variable."
  :type 'float
  :group 'org-mpv-noter)

(defun org-mpv-noter-get-milliseconds-adjust (arg)
  "Set `org-mpv-noter-milliseconds-adjust' to ARG if it's a number.
If ARG is non-nil, reset `org-mpv-noter-milliseconds-adjust' to its
default.
Return new `org-mpv-noter-milliseconds-adjust' value."
  (cond ((integerp arg)
          (setq org-mpv-noter-milliseconds-adjust arg))                    ;; Custom adjustment
        (arg
         (custom-reevaluate-setting 'org-mpv-noter-milliseconds-adjust)))  ;; Reset to default
  org-mpv-noter-milliseconds-adjust)


(defcustom org-mpv-noter-playback-speed-while-typing 0
  "Video playback speed while the user is editing the buffer.
If set to zero or smaller, playback is paused."
  :type 'float
  :group 'org-mpv-noter)

(defcustom org-mpv-noter-playback-speed-while-not-typing 1.0
  "Video playback speed while the user is not editing the buffer."
  :type 'float
  :group 'org-mpv-noter)

(defcustom org-mpv-noter-unpause-after-typing-delay 1.0
  "Number of seconds to wait after typing stopped before unpausing the player."
  :type 'float
  :group 'org-mpv-noter)

(defvar-local org-mpv-noter--player-is-auto-paused nil
  "Whether the player was paused by the user or automatically.")


(defcustom org-mpv-noter-subtitle-spacing 100
  "Minimum time in milliseconds between subtitles when start/stop time is changed."
  :type 'integer
  :group 'org-mpv-noter)

(defcustom org-mpv-noter-default-subtitle-length 1000
  "How long to make inserted subtitles in milliseconds."
  :type 'float
  :group 'org-mpv-noter)

(defcustom org-mpv-noter-enforce-time-boundaries t
  "Whether to refuse time adjustments that result in overlapping subtitles or negative duration."
  :type 'boolean
  :group 'org-mpv-noter)

(defcustom org-mpv-noter-loop-seconds-before 1
  "Prelude in seconds when looping over subtitle(s)."
  :type 'float
  :group 'org-mpv-noter)

(defcustom org-mpv-noter-loop-seconds-after 1
  "Addendum in seconds when looping over subtitle(s)."
  :type 'float
  :group 'org-mpv-noter)

(defvar-local org-mpv-noter--subtitle-loop-start nil
  "Start position of loop in player in milliseconds.")

(defvar-local org-mpv-noter--subtitle-loop-stop nil
  "Stop position of loop in player in milliseconds.")


(defcustom org-mpv-noter-point-sync-delay-after-motion 1.0
  "Number of seconds the player can't adjust point after point was moved by the user."
  :type 'float
  :group 'org-mpv-noter)

(defvar-local org-mpv-noter--point-was-synced nil
  "When temporarily disabling point-to-player sync, this variable
remembers whether it was originally enabled by the user.")


(defcustom org-mpv-noter-socket-dir (concat (temporary-file-directory) "org-mpv-noter-socket")
  "Path to Unix IPC socket that is passed to mpv's --input-ipc-server option."
  :type 'file
  :group 'org-mpv-noter)

(defcustom org-mpv-noter-executable "mpv"
  "Path or filename of mpv executable."
  :type 'file
  :group 'org-mpv-noter)

(defcustom org-mpv-noter-arguments '("--osd-level=2" "--osd-fractions")
  "Additional arguments for \"mpv\".
The options --input-ipc-server=SRTEDIT-MPV-SOCKET and --idle are
hardcoded."
  :type '(repeat string)
  :group 'org-mpv-noter)

(defun org-mpv-noter--buffer-file-name ()
  "Return base name of buffer file name or a default name."
  (file-name-nondirectory (or (buffer-file-name) "unnamed")))


;; Hooks

(defvar-local org-mpv-noter-subtitle-time-adjusted-hook ()
  "Functions to call when a subtitle's start or stop time has changed.
The functions are called with the subtitle's start time.")

(defun org-mpv-noter--run-subtitle-time-adjusted-hook ()
  "Run `org-mpv-noter-subtitle-time-adjusted-hook' functions.
The functions are called with the subtitle's start time."
  (when org-mpv-noter-subtitle-time-adjusted-hook
    (run-hook-with-args 'org-mpv-noter-subtitle-time-adjusted-hook
                        (org-mpv-noter-subtitle-msecs-start))))

(defvar-local org-mpv-noter-point-motion-hook nil
  "Functions to call after point changed.")

(defvar-local org-mpv-noter-subtitle-motion-hook nil
  "Functions to call after current subtitle changed.")


(provide 'org-mpv-noter-config)
;;; org-mpv-noter-config.el ends here
#+end_src

** org-mpv-noter-common.el
:PROPERTIES:
:CREATED:  [2021-01-18 Mon 14:12]
:ID:       0aafbdc8-f2b9-4310-99ec-d6ee31767eec
:END:
Code for mpv interaction

Licence
#+begin_src elisp
;;; org-mpv-noter-common.el --- Subtitle-format agnostic functions  -*- lexical-binding: t; -*-

;;; License:
;;
;; This file is not part of GNU Emacs.
;;
;; This is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.
;;
;; This is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;; Boston, MA 02110-1301, USA.

;;; Commentary:
;;
;; The functions in this file do not expect any particular subtitle format.
;; Instead, they expect certain functions to exist that provide navigation and
;; manipulation for whatever format the current buffer contains.

;;; Code:

(require 'org-mpv-noter-config)
(require 'org-mpv-noter-debug)
(require 'org-mpv-noter)
#+end_src

#+begin_src elisp
;;; Utilities

(defun org-mpv-noter-msecs-to-timestamp (msecs)
  "Convert MSECS to human-readable string."
  ;; We need to wrap format-seconds in save-match-data because it does regexp
  ;; stuff and we need to preserve our own match-data.
  (concat (save-match-data (format-seconds "%02h:%02m:%02s" (/ msecs 1000)))
          "," (format "%03d" (mod msecs 1000))))

(defmacro org-mpv-noter-save-excursion (&rest body)
  "Restore relative point within current subtitle after executing BODY.
This also works if the buffer changes (e.g. when sorting
subtitles) as long the subtitle IDs don't change."
  (save-excursion
    `(let ((sub-id (org-mpv-noter-subtitle-id))
           (sub-pos (org-mpv-noter-subtitle-relative-point)))
       (progn ,@body)
       (org-mpv-noter-jump-to-subtitle-id sub-id)
       ;; Subtitle text may have changed and we may not be able to move to the
       ;; exact original position
       (condition-case nil
           (forward-char sub-pos)
         ('beginning-of-buffer nil)
         ('end-of-buffer nil)))))

(defmacro org-mpv-noter-for-each-subtitle (beg end reverse &rest body)
  "Run BODY for each subtitle between the region specified by BEG and END.
If END is nil, it defaults to `point-max'.
If BEG and END are both nil, run BODY only on the subtitle at point.
If REVERSE is non-nil, start on the subtitle at END and move backwards.
Before BODY is run, point is placed on the subtitle's ID."
  (declare (indent defun))
  `(atomic-change-group
     (if (not ,beg)
         ;; Run body on subtitle at point
         (save-excursion (org-mpv-noter-jump-to-subtitle-id)
                         ,@body)
       (let ((begm (make-marker))
             (endm (make-marker)))
         (set-marker begm ,beg)
         (set-marker endm (or ,end (point-max)))
         ;; Run body on multiple subtitles
         (if ,reverse
             ;; Iterate backwards
             (save-excursion (goto-char endm)
                             (org-mpv-noter-jump-to-subtitle-id)
                             (catch 'first-subtitle-reached
                               (while t
                                 ;; The subtitle includes every character up to the next subtitle's ID (or eob)
                                 (let ((sub-end (save-excursion (org-mpv-noter-jump-to-subtitle-end))))
                                   (when (< sub-end begm)
                                     (throw 'first-subtitle-reached t)))
                                 (progn ,@body)
                                 (unless (org-mpv-noter-backward-subtitle-id)
                                   (throw 'first-subtitle-reached t)))))
           ;; Iterate forwards
           (save-excursion (goto-char begm)
                           (org-mpv-noter-jump-to-subtitle-id)
                           (catch 'last-subtitle-reached
                             (while t
                               (when (> (point) endm)
                                 (throw 'last-subtitle-reached t))
                               (progn ,@body)
                               (unless (org-mpv-noter-forward-subtitle-id)
                                 (throw 'last-subtitle-reached t))))))))))

(defmacro org-mpv-noter-with-subtitle-replay-disabled (&rest body)
  "Run BODY while automatic subtitle replay is disabled."
  (declare (indent defun))
  `(let ((replay-was-enabled-p (org-mpv-noter-replay-adjusted-subtitle-p)))
     (org-mpv-noter-disable-replay-adjusted-subtitle :quiet)
     (progn ,@body)
     (when replay-was-enabled-p
       (org-mpv-noter-enable-replay-adjusted-subtitle :quiet))))

(defun org-mpv-noter--right-pad (string length fillchar)
  "Use FILLCHAR to make STRING LENGTH characters long."
  (concat string (make-string (- length (length string)) fillchar)))


;;; Hooks for point motion and subtitle motion

(defvar-local org-mpv-noter--current-point -1)
(defvar-local org-mpv-noter--current-subtitle-id -1)
(defun org-mpv-noter--post-command-handler ()
  "Detect point motion and user entering text and signal hooks."
  ;; Check for point motion first to avoid expensive calls to org-mpv-noter-subtitle-id
  ;; as often as possible.
  (let ((new-point (point)))
    (when (and new-point org-mpv-noter--current-point
               (not (= new-point org-mpv-noter--current-point)))

      ;; If point is synced to playback position, temporarily disable that so
      ;; that manual moves aren't cancelled immediately by automated moves.
      (org-mpv-noter-disable-sync-point-to-player-temporarily)

      ;; Store new point and fire signal.
      (setq org-mpv-noter--current-point new-point)
      (run-hooks 'org-mpv-noter-point-motion-hook)

      ;; Check if point moved across subtitle boundaries.
      (let ((new-sub-id (org-mpv-noter-subtitle-id)))
        (when (and new-sub-id org-mpv-noter--current-subtitle-id
                   (not (funcall (if (stringp org-mpv-noter--current-subtitle-id) 'string= 'equal)
                                 new-sub-id org-mpv-noter--current-subtitle-id)))
          ;; Store new ID and fire signal.
          (setq org-mpv-noter--current-subtitle-id new-sub-id)
          (run-hooks 'org-mpv-noter-subtitle-motion-hook))))))


;;; Adjusting start/stop time individually

(defun org-mpv-noter-adjust-subtitle-time-start (msecs &optional
                                               ignore-negative-duration
                                               ignore-overlap)
  "Add MSECS milliseconds to start time (use negative value to subtract).

Unless either IGNORE-NEGATIVE-DURATION or
`org-mpv-noter-enforce-time-boundaries' are non-nil, adjust MSECS so that
the stop time isn't smaller than the start time.  Zero-length
subtitles are always allowed.

Unless either IGNORE-OVERLAP or `org-mpv-noter-enforce-time-boundaries'
are non-nil, ensure that there are no gaps between subtitles
smaller than `org-mpv-noter-subtitle-spacing' milliseconds by adjusting
MSECS if necessary.

Return the number of milliseconds the start time was adjusted or
nil if nothing changed."
  (org-mpv-noter-disable-sync-point-to-player-temporarily)
  (let* ((msecs-start (org-mpv-noter-subtitle-msecs-start))
         (msecs-new (when msecs-start (+ msecs-start msecs))))
    (when msecs-new
      (if (> msecs 0)
          ;; Adding to start time
          (unless (or ignore-negative-duration
                      (not org-mpv-noter-enforce-time-boundaries))
            (let ((msecs-stop (org-mpv-noter-subtitle-msecs-stop)))
              (setq msecs-new (min msecs-new msecs-stop))))
        ;; Subtracting from start time
        (unless (or ignore-overlap
                    (not org-mpv-noter-enforce-time-boundaries))
          (let* ((msecs-prev-stop (save-excursion (when (org-mpv-noter-backward-subtitle-id)
                                                    (org-mpv-noter-subtitle-msecs-stop))))
                 (msecs-min (if msecs-prev-stop
                                (+ msecs-prev-stop org-mpv-noter-subtitle-spacing) 0)))
            (when msecs-min
              (setq msecs-new (max msecs-new msecs-min))))))
      ;; MSECS-NEW must be bigger than the current start time if we are adding
      ;; or smaller if we are subtracting.
      (when (and (>= msecs-new 0)                                  ;; Ignore negative times
                 (or (and (> msecs 0) (> msecs-new msecs-start))   ;; Adding
                     (and (< msecs 0) (< msecs-new msecs-start)))) ;; Subtracting
        (org-mpv-noter-set-subtitle-time-start msecs-new)
        (org-mpv-noter--run-subtitle-time-adjusted-hook)
        (- msecs-new msecs-start)))))

(defun org-mpv-noter-adjust-subtitle-time-stop (msecs &optional
                                              ignore-negative-duration
                                              ignore-overlap)
  "Add MSECS milliseconds to stop time (use negative value to subtract).

Unless either IGNORE-NEGATIVE-DURATION or
`org-mpv-noter-enforce-time-boundaries' are non-nil, adjust MSECS so that
the stop time isn't smaller than the start time.  Zero-length
subtitles are always allowed.

Unless either IGNORE-OVERLAP or `org-mpv-noter-enforce-time-boundaries'
are non-nil, ensure that there are no gaps between subtitles
smaller than `org-mpv-noter-subtitle-spacing' milliseconds by adjusting
MSECS if necessary.

Return the number of milliseconds the stop time was adjusted or
nil if nothing changed."
  (org-mpv-noter-disable-sync-point-to-player-temporarily)
  (let* ((msecs-stop (org-mpv-noter-subtitle-msecs-stop))
         (msecs-new (when msecs-stop (+ msecs-stop msecs))))
    (when msecs-new
      (if (> msecs 0)
          ;; Adding to stop time
          (unless (or ignore-overlap
                      (not org-mpv-noter-enforce-time-boundaries))
            (let* ((msecs-next-start (save-excursion (when (org-mpv-noter-forward-subtitle-id)
                                                       (org-mpv-noter-subtitle-msecs-start))))
                   (msecs-max (when msecs-next-start
                                (- msecs-next-start org-mpv-noter-subtitle-spacing))))
              (when msecs-max
                (setq msecs-new (min msecs-new msecs-max)))))
        ;; Subtracting from stop time
        (unless (or ignore-negative-duration
                    (not org-mpv-noter-enforce-time-boundaries))
          (let ((msecs-start (org-mpv-noter-subtitle-msecs-start)))
            (setq msecs-new (max msecs-new msecs-start)))))
      ;; MSECS-NEW must be bigger than the current stop time if we are adding or
      ;; smaller if we are subtracting.
      (when (and (>= msecs-new 0)                                  ;; Ignore negative times
                 (or (and (> msecs 0) (> msecs-new msecs-stop))    ;; Adding
                     (and (< msecs 0) (< msecs-new msecs-stop))))  ;; Subtracting
        (org-mpv-noter-set-subtitle-time-stop msecs-new)
        (org-mpv-noter--run-subtitle-time-adjusted-hook)
        (- msecs-new msecs-stop)))))

(defun org-mpv-noter-increase-start-time (&optional arg)
  "Add `org-mpv-noter-milliseconds-adjust' milliseconds to start time.

Return new start time in milliseconds or nil if it didn't change.

If prefix argument ARG is given, it is used to set
`org-mpv-noter-milliseconds-adjust' before moving subtitles.  If the
prefix argument is given but not numerical,
`org-mpv-noter-milliseconds-adjust' is reset to its default value.

Example usage:
  \\[universal-argument] 1000 \\[org-mpv-noter-increase-start-time]  Increase start time by 1000ms
           \\[org-mpv-noter-increase-start-time]  Increase start time by 1000ms again
   \\[universal-argument] 500 \\[org-mpv-noter-increase-start-time]  Increase start time by 500ms
           \\[org-mpv-noter-increase-start-time]  Increase start time by 500ms again
       \\[universal-argument] \\[org-mpv-noter-increase-start-time]  Increase start time by 100ms (the default)
           \\[org-mpv-noter-increase-start-time]  Increase start time by 100ms (the default) again"
  (interactive "P")
  (org-mpv-noter-adjust-subtitle-time-start (org-mpv-noter-get-milliseconds-adjust arg)))

(defun org-mpv-noter-decrease-start-time (&optional arg)
  "Subtract `org-mpv-noter-milliseconds-adjust' milliseconds from start time.

Return new start time in milliseconds or nil if it didn't change.

See `org-mpv-noter-increase-start-time' about ARG."
  (interactive "P")
  (org-mpv-noter-adjust-subtitle-time-start (* -1 (org-mpv-noter-get-milliseconds-adjust arg))))

(defun org-mpv-noter-increase-stop-time (&optional arg)
  "Add `org-mpv-noter-milliseconds-adjust' milliseconds to stop time.

Return new stop time in milliseconds or nil if it didn't change.

See `org-mpv-noter-increase-start-time' about ARG."
  (interactive "P")
  (org-mpv-noter-adjust-subtitle-time-stop (org-mpv-noter-get-milliseconds-adjust arg)))

(defun org-mpv-noter-decrease-stop-time (&optional arg)
  "Subtract `org-mpv-noter-milliseconds-adjust' milliseconds from stop time.

Return new stop time in milliseconds or nil if it didn't change.

See `org-mpv-noter-increase-start-time' about ARG."
  (interactive "P")
  (org-mpv-noter-adjust-subtitle-time-stop (* -1 (org-mpv-noter-get-milliseconds-adjust arg))))

(defun org-mpv-noter-copy-player-pos-to-start-time ()
  "Replace current subtitle's start time with current playback time."
  (interactive)
  (when (and org-mpv-noter-playback-position
	         (org-mpv-noter-subtitle-msecs-start))
    (org-mpv-noter-set-subtitle-time-start org-mpv-noter-playback-position)
    (org-mpv-noter--run-subtitle-time-adjusted-hook)
    org-mpv-noter-playback-position))

(defun org-mpv-noter-copy-player-pos-to-stop-time ()
  "Replace current subtitle's stop time with current playback time."
  (interactive)
  (when (and org-mpv-noter-playback-position
	         (org-mpv-noter-subtitle-msecs-stop))
    (org-mpv-noter-set-subtitle-time-stop org-mpv-noter-playback-position)
    (org-mpv-noter--run-subtitle-time-adjusted-hook)
    org-mpv-noter-playback-position))


;;; Moving subtitles
;;; (adjusting start and stop time by the same amount)

(defun org-mpv-noter--get-move-subtitle-func (msecs)
  "Return subtitle moving function.

When moving subtitles forward (MSECS > 0), we must adjust the
stop time first and adjust the start time by the same amount the
stop time was adjusted.  This ensures that subtitle length
doesn't change if we can't move MSECS milliseconds forward
because we'd overlap with the next subtitle.

When moving subtitles backward (MSECS < 0), it's the same thing
but we move the start time first."
  (if (> msecs 0)
      ;; Moving forward
      (lambda (msecs &optional ignore-overlap)
        (let ((msecs (org-mpv-noter-adjust-subtitle-time-stop msecs
                                                      :ignore-negative-duration
                                                      ignore-overlap)))
          (when msecs (org-mpv-noter-adjust-subtitle-time-start msecs
                                                        :ignore-negative-duration
                                                        ignore-overlap))))
    ;; Moving backward
    (lambda (msecs &optional ignore-overlap)
      (let ((msecs (org-mpv-noter-adjust-subtitle-time-start msecs
                                                     :ignore-negative-duration
                                                     ignore-overlap)))
        (when msecs (org-mpv-noter-adjust-subtitle-time-stop msecs
                                                     :ignore-negative-duration
                                                     ignore-overlap))))))

(defun org-mpv-noter--move-current-subtitle (msecs)
  "Move subtitle on point by MSECS milliseconds."
  (unless (= msecs 0)
    (org-mpv-noter-with-subtitle-replay-disabled
      (cl-flet ((move-subtitle (org-mpv-noter--get-move-subtitle-func msecs)))
        (move-subtitle msecs)))))

(defun org-mpv-noter--move-subtitles-in-region (msecs beg end)
  "Move subtitles in region specified by BEG and END by MSECS milliseconds."
  (unless (= msecs 0)
    (org-mpv-noter-with-subtitle-replay-disabled
      (cl-flet ((move-subtitle (org-mpv-noter--get-move-subtitle-func msecs)))
        ;; When moving subtitles forward, the first step is to move the last
        ;; subtitle because:
        ;;     a) We need to check if we can move at all and abort if not.
        ;;     b) We may have to reduce MSECS if we can move but not by the full
        ;;        amount. The goal is that all subtitles are moved by the same
        ;;        amount and the spacing between subtitles doesn't change.
        ;; All other subtitles must be moved without any checks because we only
        ;; ensure that the active region as a whole can be moved, not it's
        ;; individual parts, which may be too close together or even overlap.
        ;; Moving subtitles backward is basically the same thing but vice versa.
        (catch 'bumped-into-subtitle
          (if (> msecs 0)
              (save-excursion
                ;; Moving forward - Start on last subtitle to see if/how far
                ;; we can move forward.
                (goto-char end)
                (unless (setq msecs (move-subtitle msecs))
                  (throw 'bumped-into-subtitle t))
                (org-mpv-noter-backward-subtitle-id)
                (org-mpv-noter-for-each-subtitle beg (point) :reverse
                  (move-subtitle msecs :ignore-negative-duration)))
            ;; Start on first subtitle to see if/how far we can move backward.
            (save-excursion
              (goto-char beg)
              (unless (setq msecs (move-subtitle msecs))
                (throw 'bumped-into-subtitle t))
              (org-mpv-noter-forward-subtitle-id)
              (org-mpv-noter-for-each-subtitle (point) end nil
                (move-subtitle msecs :ignore-negative-duration)))))))))

(defun org-mpv-noter-move-subtitles (msecs &optional beg end)
  "Move subtitles between BEG and END MSECS milliseconds forward.
Use a negative MSECS value to move subtitles backward.
If END is nil, move all subtitles from BEG to end of buffer.
If BEG is nil, move only the current subtitle.
After subtitles are moved, replay the first moved subtitle if
replaying is enabled."
  (cond ((and beg end) (org-mpv-noter--move-subtitles-in-region msecs beg end))
        (beg (org-mpv-noter--move-subtitles-in-region msecs beg (point-max)))
        (t (org-mpv-noter--move-current-subtitle msecs)))
  (when (org-mpv-noter-replay-adjusted-subtitle-p)
    (save-excursion
      (when beg (goto-char beg))
      (org-mpv-noter-jump (org-mpv-noter-subtitle-msecs-start)))))

(defun org-mpv-noter-move-subtitle-forward (&optional arg)
  "Move subtitle `org-mpv-noter-milliseconds-adjust' forward.

Moving adjusts start and stop time by the same amount, preserving
subtitle duration.

All subtitles that are fully or partially in the active region
are moved.

If prefix argument ARG is given, it is used to set
`org-mpv-noter-milliseconds-adjust' before moving subtitles.  If the
prefix argument is given but not numerical,
`org-mpv-noter-milliseconds-adjust' is reset to its default value.

Example usage:
  \\[universal-argument] 1000 \\[org-mpv-noter-move-subtitle-forward]  Move subtitle 1000ms forward in time
           \\[org-mpv-noter-move-subtitle-forward]  Move subtitle 1000ms forward in time again
   \\[universal-argument] 500 \\[org-mpv-noter-move-subtitle-forward]  Move subtitle 500ms forward in time
           \\[org-mpv-noter-move-subtitle-forward]  Move subtitle 500ms forward in time again
       \\[universal-argument] \\[org-mpv-noter-move-subtitle-forward]  Move subtitle 100ms (the default) forward in time
           \\[org-mpv-noter-move-subtitle-forward]  Move subtitle 100ms (the default) forward in time again"
  (interactive "P")
  (let ((deactivate-mark nil)
        (msecs (org-mpv-noter-get-milliseconds-adjust arg))
        (beg (when mark-active (region-beginning)))
        (end (when mark-active (region-end))))
    (org-mpv-noter-move-subtitles msecs beg end)))

(defun org-mpv-noter-move-subtitle-backward (&optional arg)
  "Move subtitle `org-mpv-noter-milliseconds-adjust' backward.

See `org-mpv-noter-move-subtitle-forward' about ARG."
  (interactive "P")
  (let ((deactivate-mark nil)
        (msecs (* -1 (org-mpv-noter-get-milliseconds-adjust arg)))
        (beg (when mark-active (region-beginning)))
        (end (when mark-active (region-end))))
    (org-mpv-noter-move-subtitles msecs beg end)))


;;; Shifting subtitles
;;; (same as moving, but follow-up subtitles are also moved)

(defun org-mpv-noter-shift-subtitle-forward (&optional arg)
  "Shift subtitle `org-mpv-noter-milliseconds-adjust' backward.

Shifting is like moving, but it always moves the subtitles
between point and the end of the buffer.

See `org-mpv-noter-move-subtitle-forward' about ARG."
  (interactive "P")
  (let ((deactivate-mark nil)
        (msecs (org-mpv-noter-get-milliseconds-adjust arg)))
    (org-mpv-noter-move-subtitles msecs (point))))

(defun org-mpv-noter-shift-subtitle-backward (&optional arg)
  "Shift subtitle `org-mpv-noter-milliseconds-adjust' backward.

Shifting is like moving, but it always moves the subtitles
between point and the end of the buffer.

See `org-mpv-noter-move-subtitle-forward' about ARG."
  (interactive "P")
  (let ((deactivate-mark nil)
        (msecs (* -1 (org-mpv-noter-get-milliseconds-adjust arg))))
    (org-mpv-noter-move-subtitles msecs (point))))


;;; Inserting

(defun org-mpv-noter--insert-subtitle-info (arg)
  "Provide information for inserting subtitles.
ARG is the user-given argument.
Return a list of values in the following order:
  number-of-subs insert-before-current (t or nil) buffer-is-empty
  msecs-min msecs-max msecs-avail msecs-per-sub msecs-between
  insert-subtitle-func"
  (let* ((number-of-subs (cond ((not arg) 1)         ;; M-i
                               ((integerp arg) arg)  ;; C-u N M-i  /  C-u - N M-i
                               ;; C-u [C-u ...] M-i  /  C-u - [C-u ...] M-i
                               ((consp arg) (* (truncate (log (abs (car arg)) 4)) ;; ([-]64) -> 3
                                               (/ (car arg) (abs (car arg)))))    ;; Restore sign
                               (t 1)))  ;; C-u - M-i
         (insert-before-current (or (< number-of-subs 0)  ;; C-u - N M-i
                                    (eq arg '-)           ;; C-u - M-i
                                    (consp arg)))         ;; C-u [C-u ...] M-i
         ;; Ensure number-of-subs is positive, now that we figured out `insert-before-current'
         (number-of-subs (abs number-of-subs))
         (buffer-is-empty (if (org-mpv-noter-subtitle-id) nil t))
         ;; Find out how much time there is available
         (msecs-min (save-excursion (if insert-before-current
                                        (if (org-mpv-noter-backward-subtitle-id)
                                          (org-mpv-noter-subtitle-msecs-stop) 0)
                                      (org-mpv-noter-subtitle-msecs-stop))))
         (msecs-max (save-excursion (if insert-before-current
                                        (org-mpv-noter-subtitle-msecs-start)
                                      (when (org-mpv-noter-forward-subtitle-id)
                                        (org-mpv-noter-subtitle-msecs-start)))))
         (msecs-avail (cond ((and msecs-min msecs-max) (- msecs-max msecs-min))
                            (msecs-max msecs-max)
                            (t nil)))  ;; Unlimited
         (msecs-per-sub (if msecs-avail
                            (min org-mpv-noter-default-subtitle-length
                                 (max 0 (/ (- msecs-avail (* (1+ number-of-subs) org-mpv-noter-subtitle-spacing))
                                           number-of-subs)))
                          org-mpv-noter-default-subtitle-length))
         (msecs-between (if (or (not msecs-avail)
                                (>= msecs-avail (* (1+ number-of-subs) org-mpv-noter-subtitle-spacing)))
                            org-mpv-noter-subtitle-spacing
                          0))
         (insert-subtitle-func (if insert-before-current
                                   #'org-mpv-noter-prepend-subtitle
                                 #'org-mpv-noter-append-subtitle)))
    (org-mpv-noter-debug "Inserting %s subtitle(s) %s the current in %sempty buffer"
                 number-of-subs
                 (if insert-before-current "before" "after")
                 (if buffer-is-empty "" "non-"))
    (org-mpv-noter-debug "  Available time: min=%S max=%S avail=%S sublen=%S/%S"
                 msecs-min msecs-max msecs-avail msecs-per-sub org-mpv-noter-default-subtitle-length)
    (list number-of-subs insert-before-current buffer-is-empty
          msecs-min msecs-max msecs-avail msecs-per-sub msecs-between
          insert-subtitle-func)))

(defun org-mpv-noter-insert-subtitle (&optional arg)
  "Insert subtitle(s) evenly spaced.

The inserted subtitles are `org-mpv-noter-default-subtitle-length'
milliseconds long.

Subtitles are spread out evenly over the available time.

ARG, usually provided by `universal-argument', is used in the
following manner:
          \\[org-mpv-noter-insert-subtitle]   Insert 1 subtitle after the current subtitle
      \\[universal-argument] \\[org-mpv-noter-insert-subtitle]   Insert 1 subtitle before the current subtitle
    \\[universal-argument] 5 \\[org-mpv-noter-insert-subtitle]   Insert 5 subtitles after the current subtitle
  \\[universal-argument] - 5 \\[org-mpv-noter-insert-subtitle]   Insert 5 subtitles before the current subtitle
  \\[universal-argument] \\[universal-argument] \\[org-mpv-noter-insert-subtitle]   Insert 2 subtitles before the current subtitle"
  (interactive "P")
  (atomic-change-group
    (cl-multiple-value-bind (number-of-subs insert-before-current _buffer-is-empty
                             msecs-min msecs-max msecs-avail msecs-per-sub msecs-between
                             insert-subtitle-func)
                            (org-mpv-noter--insert-subtitle-info arg)
      (dotimes (i number-of-subs)
        ;; Value constellations:
        ;;     empty buffer, append           : min=0       max=nil     avail=nil
        ;;     empty buffer, prepend          : min=0       max=nil     avail=nil
        ;; non-empty buffer, prepend, betwixt : min=non-nil max=non-nil avail=non-nil
        ;; non-empty buffer, append,  betwixt : min=non-nil max=non-nil avail=non-nil
        ;; non-empty buffer, prepend to first : min=0       max=non-nil avail=non-nil
        ;; non-empty buffer, append  to last  : min=non-nil max=nil     avail=nil
        (let* ((multiplier (if insert-before-current
                               (- number-of-subs i)
                             (1+ i)))
               (msecs-start (if msecs-avail
                                ;; Inserting anywhere before the last subtitle
                                (+ msecs-min
                                   (if (< msecs-per-sub org-mpv-noter-default-subtitle-length)
                                       ;; Use all available space between subtitles
                                       (+ msecs-between
                                          (* (1- multiplier) (+ msecs-between msecs-per-sub)))
                                     ;; Leave extra space between subtitles
                                     (* multiplier (/ msecs-avail (1+ number-of-subs)))))
                              (if (and msecs-min (not msecs-max))
                                  ;; Appending to last subtitle
                                  (+ msecs-min
                                     ;; If buffer is empty, start first subtitle at 0
                                     (if (> msecs-min 0) msecs-between 0)
                                     (* (1- multiplier) (+ msecs-per-sub msecs-between)))
                                ;; Appending in empty buffer
                                (* i (+ msecs-per-sub msecs-between)))))
               (msecs-stop (+ msecs-start msecs-per-sub)))
          (org-mpv-noter-debug "  Inserting new subtitle at %S - %S" msecs-start msecs-stop)
          (funcall insert-subtitle-func nil msecs-start msecs-stop nil)))
      (unless insert-before-current
        (dotimes (_ (1- number-of-subs))
          (org-mpv-noter-backward-subtitle-text))))
    (org-mpv-noter-regenerate-ids-soon))
  (point))

(defun org-mpv-noter-insert-subtitle-adjacent (&optional arg)
  "Insert subtitle(s) close to each other.

The inserted subtitles are `org-mpv-noter-default-subtitle-length'
milliseconds long.

Subtitles are inserted `org-mpv-noter-subtitle-spacing' milliseconds
before or after the current subtitle.  When inserting multiple
subtitles, the gap between them is also `org-mpv-noter-subtitle-spacing'
milliseconds long.

ARG, usually provided by `universal-argument', is used in the
following manner:
          \\[org-mpv-noter-insert-subtitle]   Insert 1 subtitle after the current subtitle
      \\[universal-argument] \\[org-mpv-noter-insert-subtitle]   Insert 1 subtitle before the current subtitle
    \\[universal-argument] 5 \\[org-mpv-noter-insert-subtitle]   Insert 5 subtitles after the current subtitle
  \\[universal-argument] - 5 \\[org-mpv-noter-insert-subtitle]   Insert 5 subtitles before the current subtitle
  \\[universal-argument] \\[universal-argument] \\[org-mpv-noter-insert-subtitle]   Insert 2 subtitles before the current subtitle"
  (interactive "P")
  (atomic-change-group
    (cl-multiple-value-bind (number-of-subs insert-before-current buffer-is-empty
                             msecs-min msecs-max _msecs-avail msecs-per-sub msecs-between
                             insert-subtitle-func)
                            (org-mpv-noter--insert-subtitle-info arg)
      (dotimes (i number-of-subs)
        ;; Value constellations:
        ;;     empty buffer, append           : min=0       max=nil     avail=nil
        ;;     empty buffer, prepend          : min=0       max=nil     avail=nil
        ;; non-empty buffer, prepend, betwixt : min=non-nil max=non-nil avail=non-nil
        ;; non-empty buffer, append,  betwixt : min=non-nil max=non-nil avail=non-nil
        ;; non-empty buffer, prepend to first : min=0       max=non-nil avail=non-nil
        ;; non-empty buffer, append  to last  : min=non-nil max=nil     avail=nil
        (let* ((multiplier (if insert-before-current
                               (- number-of-subs i 1)
                             i))
               (msecs-start (if buffer-is-empty
                                (* multiplier (+ msecs-between msecs-per-sub))
                              (if insert-before-current
                                  (- msecs-max (* (1+ i) (+ msecs-between msecs-per-sub)))
                                (+ msecs-min
                                   msecs-between
                                   (* i (+ msecs-per-sub msecs-between))))))
               (msecs-stop (+ msecs-start msecs-per-sub)))
          (org-mpv-noter-debug "  Inserting new subtitle at %S - %S" msecs-start msecs-stop)
          (funcall insert-subtitle-func nil msecs-start msecs-stop nil)))
      (unless insert-before-current
        (dotimes (_ (1- number-of-subs))
          (org-mpv-noter-backward-subtitle-text))))
    (org-mpv-noter-regenerate-ids-soon))
  (point))

(defun org-mpv-noter-split-subtitle ()
  "Split current subtitle at point.

The subtitle text after point is moved to a new subtitle that is
inserted after the current subtitle.

If a video is playing, `org-mpv-noter-playback-position' is used as
the new stop time of the current subtitle. Otherwise, the
timestamp between the start and stop timestamp of the current
subtitle is used.

The newly inserted subtitle starts `org-mpv-noter-subtitle-spacing'
milliseconds after the current subtitle's new end timestamp.

Return point of the new subtitle.
"
  (interactive)
  (let ((text-beg (save-excursion (org-mpv-noter-jump-to-subtitle-text)))
        (text-end (save-excursion (or (org-mpv-noter-jump-to-subtitle-end) (point)))))
    ;; Ensure point is on subtitle text
    (unless (and text-beg text-end (>= (point) text-beg) (<= (point) text-end))
      (org-mpv-noter-jump-to-subtitle-text))
    (let* ((split-timestamp (if org-mpv-noter-playback-position
                                (+ org-mpv-noter-playback-position org-mpv-noter-subtitle-spacing)
                              (let ((sub-len (- (org-mpv-noter-subtitle-msecs-stop) (org-mpv-noter-subtitle-msecs-start))))
                                (+ (org-mpv-noter-subtitle-msecs-start) (/ sub-len 2)))))
           (new-text (string-trim (buffer-substring (point) text-end)))
           (new-start-timestamp (+ split-timestamp org-mpv-noter-subtitle-spacing))
           (new-stop-timestamp (org-mpv-noter-subtitle-msecs-stop)))
      (when (or (> split-timestamp new-stop-timestamp)
                (< split-timestamp (org-mpv-noter-subtitle-msecs-start)))
        (error "Playback position is not at the subtitle on point."))
      (org-mpv-noter-set-subtitle-time-stop split-timestamp)
      (delete-region (point) text-end)
      (org-mpv-noter-append-subtitle nil new-start-timestamp new-stop-timestamp new-text))
    (org-mpv-noter-regenerate-ids-soon)
    (point)))

;;; Merging

(defun org-mpv-noter-merge-with-previous ()
  "Merge the current subtitle with the previous subtitle.
Update the end timestamp accordingly."
  (interactive)
  (if (org-mpv-noter-backward-subtitle-id)
      (org-mpv-noter-merge-with-next)
    (error "No previous subtitle to merge into")))

;;; Replay time-adjusted subtitle

(defun org-mpv-noter-replay-adjusted-subtitle-p ()
  "Whether the player jumps to start time when start or stop time is adjusted."
  (member #'org-mpv-noter--replay-adjusted-subtitle org-mpv-noter-subtitle-time-adjusted-hook))

(defun org-mpv-noter-enable-replay-adjusted-subtitle (&optional quiet)
  "Automatically replay a subtitle when its start/stop time is adjusted.

If QUIET is non-nil, do not display a message in the minibuffer."
  (interactive)
  (unless (org-mpv-noter-replay-adjusted-subtitle-p)
    (add-hook 'org-mpv-noter-subtitle-time-adjusted-hook #'org-mpv-noter--replay-adjusted-subtitle :append :local)
    (org-mpv-noter-debug "Enabled replaying adjusted subtitle: %s" org-mpv-noter-subtitle-time-adjusted-hook)
    (unless quiet
      (message "Enabled replaying adjusted subtitle"))))

(defun org-mpv-noter-disable-replay-adjusted-subtitle (&optional quiet)
  "Do not replay a subtitle automatically when its start/stop time is adjusted.

If QUIET is non-nil, do not display a message in the minibuffer."
  (interactive)
  (when (org-mpv-noter-replay-adjusted-subtitle-p)
    (remove-hook 'org-mpv-noter-subtitle-time-adjusted-hook #'org-mpv-noter--replay-adjusted-subtitle :local)
    (org-mpv-noter-debug "Disabled replaying adjusted subtitle: %s" org-mpv-noter-subtitle-time-adjusted-hook)
    (unless quiet
      (message "Disabled replaying adjusted subtitle"))))

(defun org-mpv-noter-toggle-replay-adjusted-subtitle ()
  "Enable/disable subtitle replay when start/stop time is adjusted."
  (interactive)
  (if (org-mpv-noter-replay-adjusted-subtitle-p)
      (org-mpv-noter-disable-replay-adjusted-subtitle)
    (org-mpv-noter-enable-replay-adjusted-subtitle)))

(defun org-mpv-noter--replay-adjusted-subtitle (msecs-start)
  "Seek player to MSECS-START."
  (org-mpv-noter-debug "Replaying subtitle at: %s" (org-mpv-noter-msecs-to-timestamp msecs-start))
  (org-mpv-noter-jump msecs-start))


;;; Sync point-to-player

(defun org-mpv-noter-sync-point-to-player-p ()
  "Whether point is automatically moved to currently playing subtitle."
  (member #'org-mpv-noter--sync-point-to-player org-mpv-noter-playback-position-hook))

(defun org-mpv-noter-enable-sync-point-to-player (&optional quiet)
  "Automatically move point to the currently playing subtitle.

If QUIET is non-nil, do not display a message in the minibuffer."
  (interactive)
  (unless (org-mpv-noter-sync-point-to-player-p)
    (add-hook 'org-mpv-noter-playback-position-hook #'org-mpv-noter--sync-point-to-player :append :local)
    (org-mpv-noter-debug "Enabled syncing point to playback position: %s" org-mpv-noter-playback-position-hook)
    (unless quiet
      (message "Enabled syncing point to playback position"))))

(defun org-mpv-noter-disable-sync-point-to-player (&optional quiet)
  "Do not move point automatically to the currently playing subtitle.

If QUIET is non-nil, do not display a message in the minibuffer."
  (interactive)
  (when (org-mpv-noter-sync-point-to-player-p)
    (remove-hook 'org-mpv-noter-playback-position-hook #'org-mpv-noter--sync-point-to-player :local)
    (org-mpv-noter-debug "Disabled syncing point to playback position: %s" org-mpv-noter-playback-position-hook)
    (unless quiet
      (message "Disabled syncing point to playback position"))))

(defun org-mpv-noter-toggle-sync-point-to-player ()
  "Enable/disable moving point to the currently playing subtitle."
  (interactive)
  (if (org-mpv-noter-sync-point-to-player-p)
      (org-mpv-noter-disable-sync-point-to-player)
    (org-mpv-noter-enable-sync-point-to-player)))

(defun org-mpv-noter--sync-point-to-player (msecs)
  "Move point to subtitle at MSECS."
  (when (and (not (use-region-p)) ;; Don't sync with active-mark in transient-mark-mode
             (org-mpv-noter-jump-to-subtitle-text-at-msecs msecs))
    (org-mpv-noter-debug "Synchronized point to playback position: %s -> #%s"
                 (org-mpv-noter-msecs-to-timestamp msecs) (org-mpv-noter-subtitle-id))
    ;; post-command-hook is not triggered because we didn't move interactively,
    ;; but there shouldn't be a difference between automatic movement and manual
    ;; movement.  E.g. the minor mode `hl-line' breaks because its post-command
    ;; function is not called.
    ;; But it's also important NOT to call our own post-command function because
    ;; that causes player-to-point syncing, which would get hairy.
    (remove-hook 'post-command-hook #'org-mpv-noter--post-command-handler)
    (run-hooks 'post-command-hook)
    (add-hook 'post-command-hook #'org-mpv-noter--post-command-handler :append :local)))

(defvar-local org-mpv-noter--point-sync-delay-after-motion-timer nil)
(defun org-mpv-noter-disable-sync-point-to-player-temporarily ()
  "Temporarily disable syncing point to player.

After `org-mpv-noter-point-sync-delay-after-motion' seconds point is re-synced."
  (if org-mpv-noter--point-sync-delay-after-motion-timer
      (cancel-timer org-mpv-noter--point-sync-delay-after-motion-timer)
    (setq org-mpv-noter--point-was-synced (org-mpv-noter-sync-point-to-player-p)))
  (when org-mpv-noter--point-was-synced
    (org-mpv-noter-disable-sync-point-to-player :quiet))
  (when org-mpv-noter--point-was-synced
    (setq org-mpv-noter--point-sync-delay-after-motion-timer
          (run-at-time org-mpv-noter-point-sync-delay-after-motion nil
                       (lambda ()
                         (setq org-mpv-noter--point-sync-delay-after-motion-timer nil)
                         (org-mpv-noter-enable-sync-point-to-player :quiet))))))


;;; Sync player-to-point

(defun org-mpv-noter-sync-player-to-point-p ()
  "Whether playback position jumps to subtitle at point."
  (member #'org-mpv-noter--sync-player-to-point org-mpv-noter-subtitle-motion-hook))

(defun org-mpv-noter-enable-sync-player-to-point (&optional quiet)
  "Automatically seek player to subtitle at point.

If QUIET is non-nil, do not display a message in the minibuffer."
  (interactive)
  (unless (org-mpv-noter-sync-player-to-point-p)
    (org-mpv-noter--sync-player-to-point)
    (add-hook 'org-mpv-noter-subtitle-motion-hook #'org-mpv-noter--sync-player-to-point :append :local)
    (org-mpv-noter-debug "Enabled syncing playback position to point: %s" org-mpv-noter-subtitle-motion-hook)
    (unless quiet
      (message "Enabled syncing playback position to point"))))

(defun org-mpv-noter-disable-sync-player-to-point (&optional quiet)
  "Do not automatically seek player to subtitle at point.

If QUIET is non-nil, do not display a message in the minibuffer."
  (interactive)
  (when (org-mpv-noter-sync-player-to-point-p)
    (remove-hook 'org-mpv-noter-subtitle-motion-hook #'org-mpv-noter--sync-player-to-point :local)
    (org-mpv-noter-debug "Disabled syncing playback position to point: %s" org-mpv-noter-subtitle-motion-hook)
    (unless quiet
      (message "Disabled syncing playback position to point"))))

(defun org-mpv-noter-toggle-sync-player-to-point ()
  "Enable or disable automatically seeking player to subtitle at point."
  (interactive)
  (if (org-mpv-noter-sync-player-to-point-p)
      (org-mpv-noter-disable-sync-player-to-point)
    (org-mpv-noter-enable-sync-player-to-point)))

(defun org-mpv-noter--sync-player-to-point ()
  "Seek player to currently focused subtitle."
  (org-mpv-noter-debug "Seeking player to subtitle at point %s" (point))
  (let ((cur-sub-start (org-mpv-noter-subtitle-msecs-start))
        (cur-sub-stop (org-mpv-noter-subtitle-msecs-stop)))
    (when (and org-mpv-noter-playback-position cur-sub-start cur-sub-stop
               (or (< org-mpv-noter-playback-position cur-sub-start)
                   (> org-mpv-noter-playback-position cur-sub-stop)))
      (org-mpv-noter-jump cur-sub-start)
      (org-mpv-noter-debug "Synchronized playback position to point: #%s -> %s"
                   (org-mpv-noter-subtitle-id) cur-sub-start))))


;;; Loop over single subtitle

(defun org-mpv-noter-loop-over-current-subtitle-p ()
  "Whether the player is looping over the current subtitle."
  (or org-mpv-noter--subtitle-loop-start org-mpv-noter--subtitle-loop-stop))

(defvar-local org-mpv-noter--enable-point-to-player-sync-after-disabling-loop nil)

(defun org-mpv-noter-enable-loop-over-current-subtitle (&optional quiet)
  "Enable looping over the current subtitle in the player.

If enabled, point-to-player synchronization is disabled and
re-enabled again when `org-mpv-noter-disable-loop-over-current-subtitle'
is called.

If QUIET is non-nil, do not display a message in the minibuffer."
  (interactive)
  (unless (org-mpv-noter-loop-over-current-subtitle-p)
    (org-mpv-noter--set-subtitle-loop (org-mpv-noter-subtitle-id))
    (add-hook 'org-mpv-noter-playback-position-hook #'org-mpv-noter--ensure-subtitle-loop :append :local)
    (add-hook 'org-mpv-noter-subtitle-motion-hook #'org-mpv-noter--set-subtitle-loop :append :local)
    (org-mpv-noter-debug "Enabling loop: %s - %s" org-mpv-noter--subtitle-loop-start org-mpv-noter--subtitle-loop-stop)
    (when (org-mpv-noter-sync-point-to-player-p)
      (org-mpv-noter-disable-sync-point-to-player)
      (setq org-mpv-noter--enable-point-to-player-sync-after-disabling-loop t))
    (unless quiet
      (message "Enabled looping over current subtitle"))))

(defun org-mpv-noter-disable-loop-over-current-subtitle (&optional quiet)
  "Disable looping over the current subtitle in the player.

If QUIET is non-nil, do not display a message in the minibuffer."
  (interactive)
  (when (org-mpv-noter-loop-over-current-subtitle-p)
    (remove-hook 'org-mpv-noter-playback-position-hook #'org-mpv-noter--ensure-subtitle-loop :local)
    (remove-hook 'org-mpv-noter-subtitle-motion-hook #'org-mpv-noter--set-subtitle-loop :local)
    (setq org-mpv-noter--subtitle-loop-start nil
          org-mpv-noter--subtitle-loop-stop nil)
    (org-mpv-noter-debug "Disabling loop: %s - %s" org-mpv-noter--subtitle-loop-start org-mpv-noter--subtitle-loop-stop)
    (when org-mpv-noter--enable-point-to-player-sync-after-disabling-loop
      (org-mpv-noter-enable-sync-point-to-player)
      (setq org-mpv-noter--enable-point-to-player-sync-after-disabling-loop nil))
    (unless quiet
      (message "Disabled looping over current subtitle"))))

(defun org-mpv-noter-toggle-loop-over-current-subtitle (&optional quiet)
  "Enable or disable looping over the current subtitle in the player.

If QUIET is non-nil, do not display a message in the minibuffer."
  (interactive)
  (if (org-mpv-noter-loop-over-current-subtitle-p)
      (org-mpv-noter-disable-loop-over-current-subtitle quiet)
    (org-mpv-noter-enable-loop-over-current-subtitle quiet)))

(defun org-mpv-noter--set-subtitle-loop (&optional sub-id)
  "Set loop positions to start/stop time of SUB-ID or current subtitle."
  (let ((msecs-start (org-mpv-noter-subtitle-msecs-start sub-id))
        (msecs-stop (org-mpv-noter-subtitle-msecs-stop sub-id)))
    (when (and msecs-start msecs-stop)
      (setq org-mpv-noter--subtitle-loop-start (- msecs-start (* org-mpv-noter-loop-seconds-before 1000))
            org-mpv-noter--subtitle-loop-stop (+ msecs-stop (* org-mpv-noter-loop-seconds-after 1000)))
      (org-mpv-noter-debug "Set loop: %s - %s"
                   (org-mpv-noter-msecs-to-timestamp org-mpv-noter--subtitle-loop-start)
                   (org-mpv-noter-msecs-to-timestamp org-mpv-noter--subtitle-loop-stop))
      (message "Looping over %s - %s"
               (org-mpv-noter-msecs-to-timestamp org-mpv-noter--subtitle-loop-start)
               (org-mpv-noter-msecs-to-timestamp org-mpv-noter--subtitle-loop-stop)))))

(defun org-mpv-noter--ensure-subtitle-loop (cur-msecs)
  "Jump to current subtitle start time if CUR-MSECS is after stop time."
  (when (and org-mpv-noter--subtitle-loop-start org-mpv-noter--subtitle-loop-stop
             org-mpv-noter-is-playing)
    (when (or (< cur-msecs org-mpv-noter--subtitle-loop-start)
              (> cur-msecs org-mpv-noter--subtitle-loop-stop))
      (org-mpv-noter-debug "%s -> Looping over %s - %s"
                   (org-mpv-noter-msecs-to-timestamp cur-msecs)
                   (org-mpv-noter-msecs-to-timestamp org-mpv-noter--subtitle-loop-start)
                   (org-mpv-noter-msecs-to-timestamp org-mpv-noter--subtitle-loop-stop))
      (org-mpv-noter-jump org-mpv-noter--subtitle-loop-start))))


;;; Pause player while the user is editing

(defun org-mpv-noter-pause-while-typing-p ()
  "Whether player is automatically paused or slowed down during editing.

See `org-mpv-noter-playback-speed-while-typing' and
`org-mpv-noter-playback-speed-while-not-typing'."
  (member #'org-mpv-noter--pause-while-typing after-change-functions))

(defun org-mpv-noter-enable-pause-while-typing (&optional quiet)
  "Pause player while the user is editing a subtitle.

After `org-mpv-noter-unpause-after-typing-delay' seconds, playback is
resumed automatically unless the player was paused already.

If QUIET is non-nil, do not display a message in the minibuffer."
  (unless (org-mpv-noter-pause-while-typing-p)
    (add-hook 'after-change-functions #'org-mpv-noter--pause-while-typing :append :local)
    (unless quiet
      (org-mpv-noter-debug "%S" org-mpv-noter-playback-speed-while-typing)
      (if (<= org-mpv-noter-playback-speed-while-typing 0)
          (message "Playback will pause while subtitle texts are edited")
        (message "Playback will slow down by %s while subtitle texts are edited"
                 org-mpv-noter-playback-speed-while-typing)))))

(defun org-mpv-noter-disable-pause-while-typing (&optional quiet)
  "Do not automatically pause player while the user is editing the buffer.

If QUIET is non-nil, do not display a message in the minibuffer."
  (when (org-mpv-noter-pause-while-typing-p)
    (remove-hook 'after-change-functions #'org-mpv-noter--pause-while-typing :local)
    (unless quiet
      (message "Playback speed will not change while subtitle texts are edited"))))

(defun org-mpv-noter-toggle-pause-while-typing ()
  "Enable or disable auto-pausing while the user is editing the buffer."
  (interactive)
  (if (org-mpv-noter-pause-while-typing-p)
      (org-mpv-noter-disable-pause-while-typing)
    (org-mpv-noter-enable-pause-while-typing)))

(defvar-local org-mpv-noter--unpause-after-typing-timer nil)
(defun org-mpv-noter--pause-while-typing (&rest _args)
  "Pause or slow down playback for `org-mpv-noter-unpause-after-typing-delay' seconds.

This function is meant to be an item in `after-change-functions'
and therefore gets ARGS, which is ignored."
  (when org-mpv-noter--unpause-after-typing-timer
    (cancel-timer org-mpv-noter--unpause-after-typing-timer))
  (when (or org-mpv-noter-is-playing org-mpv-noter--player-is-auto-paused)
    (if (<= org-mpv-noter-playback-speed-while-typing 0)
        ;; Pause playback
        (progn
          (org-mpv-noter-pause)
          (setq org-mpv-noter--player-is-auto-paused t)
          (setq org-mpv-noter--unpause-after-typing-timer
                (run-at-time org-mpv-noter-unpause-after-typing-delay nil
                             (lambda ()
                               (setq org-mpv-noter--player-is-auto-paused nil)
                               (org-mpv-noter-unpause)))))
      ;; Slow down playback
      (progn
        (org-mpv-noter-playback-speed org-mpv-noter-playback-speed-while-typing)
        (setq org-mpv-noter--player-is-auto-paused t)
        (setq org-mpv-noter--unpause-after-typing-timer
              (run-at-time org-mpv-noter-unpause-after-typing-delay nil
                           (lambda ()
                             (setq org-mpv-noter--player-is-auto-paused nil)
                             (org-mpv-noter-playback-speed org-mpv-noter-playback-speed-while-not-typing))))))))


(defun org-mpv-noter-guess-video-file ()
  "Find video file with same base name as the opened file in the buffer.

The file extension of the return value of the function
`buffer-file-name' is replaced with each item in
`org-mpv-noter-video-extensions' and the first existing file is returned.

Language codes are also handled; e.g. \"foo.en.srt\" or
\"foo.estonian.srt\" -> \"foo.{mkv,mp4,...}\" (this actually
simply removes the extension from the extension-stripped file
name).

Return nil if function `buffer-file-name' returns nil."
  (when (buffer-file-name)
    (catch 'found-videofile
      (let* ((file-base (file-name-sans-extension (buffer-file-name)))
	         (file-stem (file-name-sans-extension file-base)))
	    (dolist (extension org-mpv-noter-video-extensions)
	      (let ((file-base-video (format "%s.%s" file-base extension))
		        (file-stem-video (format "%s.%s" file-stem extension)))
	        (when (file-exists-p file-base-video)
	          (throw 'found-videofile file-base-video))
	        (when (file-exists-p file-stem-video)
	          (throw 'found-videofile file-stem-video))))))))

(provide 'org-mpv-noter-common)
;;; org-mpv-noter-common.el ends here
#+end_src

** org-mpv-noter.el
:PROPERTIES:
:CREATED:  [2021-01-18 Mon 14:12]
:ID:       8daf4ff4-a537-43c1-b4cc-907eb04b3a83
:END:

License
#+begin_src elisp
;;; org-mpv-noter.el --- mpv integration for org-mpv-noter  -*- lexical-binding: t; -*-

;;; License:
;;
;; This file is not part of GNU Emacs.
;;
;; This is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.
;;
;; This is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;; Boston, MA 02110-1301, USA.

;;; Commentary:
;;
;; Based on:
;; https://github.com/mk-fg/emacs-setup/blob/master/extz/emms-player-mpv.el
#+end_src


#+begin_src elisp
;;; Code:

(require 'org-mpv-noter-config)
(require 'org-mpv-noter-debug)
(require 'json)

#+end_src

*** Variables
:PROPERTIES:
:CREATED:  [2021-01-18 Mon 17:42]
:ID:       f043f09d-bb24-4887-a427-f8c94bcc9f11
:END:
#+begin_src elisp
(defvar-local org-mpv-noter-is-playing nil
  "Whether mpv is currently playing or paused.")

(defvar-local org-mpv-noter-playback-speed nil
  "How fast mpv is playing the video.
1.0 is normal speed, 0.5 is half speed, etc.")

(defvar-local org-mpv-noter-playback-position nil
  "Current playback position in milliseconds.")

(defvar-local org-mpv-noter-playback-position-hook nil
  "Functions to call when mpv changes playback position.")

(defvar-local org-mpv-noter-file-loaded-hook '(org-mpv-noter-pause
                                           org-mpv-noter-jump-to-current-subtitle)
  "Functions to call when mpv has loaded a file and starts playing.")

(defvar-local org-mpv-noter--server-proc nil
  "Running mpv process.")

(defvar-local org-mpv-noter--client-proc nil
  "IPC socket process that communicates over `org-mpv-noter--socket'.")

(defconst org-mpv-noter--client-test-request
  (json-encode (list :command '(get_property mpv-version)))
  "Request as a string to send to check whether IPC connection is working.")

(defconst org-mpv-noter--retry-delays
  ;; Sums up to 5 seconds in total before failing
  '(0.1 0.1 0.1 0.1 0.2 0.2 0.3 0.4 0.5 0.5 0.5 0.5 0.5 0.5 0.5)
  "List of delays between attemps to connect to `org-mpv-noter--socket'.")

(defvar-local org-mpv-noter--client-command-queue nil
  "Commands to call when connection to `org-mpv-noter--socket' is established.")


;;; Server (mpv process that provides an IPC socket)

(defun org-mpv-noter--socket ()
  "Path to mpv's RPC socket for a particular buffer.
See also `org-mpv-noter-socket-dir'."
  (unless (file-exists-p org-mpv-noter-socket-dir)
    (condition-case err
        (make-directory org-mpv-noter-socket-dir :create-parents)
      (file-error
       (error "%s" (mapconcat #'identity (cdr err) ": ")))))
  (concat (file-name-as-directory org-mpv-noter-socket-dir)
          (format "%s:%s"
                  (let ((filename (file-name-sans-extension (org-mpv-noter--buffer-file-name))))
                    (substring (substring filename 0 (min (length filename) 20))))
                  (buffer-hash))))

(defun org-mpv-noter--server-start (&rest args)
  "Run mpv in JSON IPC mode.

Pass ARGS as command line arguments.  \"--idle\" and
\"--input-ipc-server\" are hardcoded."
  (org-mpv-noter--server-stop)
  (let* ((socket-file (org-mpv-noter--socket))
         (argv (append (list org-mpv-noter-executable
                             (format "--input-ipc-server=%s" socket-file)
                             "--idle")
                       args)))
    (when (file-exists-p socket-file)
      (error "An mpv instance for %s is already running: %s"
             (org-mpv-noter--buffer-file-name) socket-file))
    (org-mpv-noter-debug "Running %s" argv)
    (condition-case err
        (setq org-mpv-noter--server-proc (make-process :command argv
                                                   :name "org-mpv-noter-server"
                                                   :buffer nil
                                                   :noquery t))
      (error
       (error "%s" (mapconcat #'identity (cdr (cdr err)) ": "))))))

(defun org-mpv-noter--server-stop ()
  "Kill a running mpv process."
  (when (and org-mpv-noter--server-proc (process-live-p org-mpv-noter--server-proc))
    (delete-process org-mpv-noter--server-proc)
    (org-mpv-noter-debug "Killed mpv process"))
  (let ((socket-file (org-mpv-noter--socket)))
    (when (file-exists-p socket-file)
      (org-mpv-noter-debug "Removing IPC socket: %s" socket-file)
      (ignore-errors (delete-file socket-file))))
  (setq org-mpv-noter--server-proc nil))

(defun org-mpv-noter--server-started-p ()
  "Whether `org-mpv-noter--server-proc' is a running process."
  (if org-mpv-noter--server-proc t nil))


;;; Client (elisp process that connects to server's IPC socket)

(defun org-mpv-noter--client-buffer ()
  "Unique name of buffer that store RPC responses."
  (let ((buffer-name (format "*org-mpv-noter-buffer:%s-%s*"
                             (file-name-base (or (buffer-file-name) "unnamed"))
                             (buffer-hash))))
    (if org-mpv-noter-debugging-enabled-p
        buffer-name
      (concat " " buffer-name))))

(defun org-mpv-noter--client-connect (delays)
  "Try to connect to `org-mpv-noter--socket'.
If a connection attempt fails, wait (car DELAYS) seconds and try
again with (cdr DELAYS) as arguments."
  (org-mpv-noter-debug "Attempting to connect to IPC socket: %s" (org-mpv-noter--socket))
  (org-mpv-noter--client-disconnect)
  ;; NOTE: make-network-process doesn't fail when the socket file doesn't exist
  (let ((proc (make-network-process :name "org-mpv-noter-client"
                                    :family 'local
                                    :service (org-mpv-noter--socket)
                                    :coding '(utf-8 . utf-8)
					                :buffer (org-mpv-noter--client-buffer)
                                    :filter #'org-mpv-noter--client-filter
                                    :noquery t
                                    :nowait t)))
    ;; Test connection by sending a test request
    (condition-case err
        (progn
          (process-send-string proc (concat org-mpv-noter--client-test-request "\n"))
          (org-mpv-noter-debug "Connected to %s (%s)" proc (process-status proc))
          (setq org-mpv-noter--client-proc proc))
      (error
       (if delays
           (progn
             (org-mpv-noter-debug "Failed to connect (trying again in %s seconds)" (car delays))
             (run-at-time (car delays) nil #'org-mpv-noter--client-connect (cdr delays)))
         (progn
           (org-mpv-noter-debug "Connection failed: %s" err))))))
  ;; Run commands that were sent while the connection wasn't up yet
  (when (org-mpv-noter--client-connected-p)
    (while org-mpv-noter--client-command-queue
      (let ((cmd (pop org-mpv-noter--client-command-queue)))
        (org-mpv-noter-debug "Running queued command: %s" cmd)
        (apply #'org-mpv-noter--client-send (list cmd))))))

(defun org-mpv-noter--client-disconnect ()
  "Close connection to mpv process, if there is one."
  (when (org-mpv-noter--client-connected-p)
    (delete-process org-mpv-noter--client-proc)
    (org-mpv-noter-debug "Closed connection to mpv process"))
  (setq org-mpv-noter--client-proc nil
        org-mpv-noter-is-playing nil
        org-mpv-noter-playback-position nil))

(defun org-mpv-noter--client-connected-p ()
  "Whether the server connection has been established and tested successfully."
  (if org-mpv-noter--client-proc t nil))

(defun org-mpv-noter--client-send (cmd)
  "Send JSON IPC command.
If we're not connected yet but the server has been started, add
CMD to `org-mpv-noter--client-command-queue' which is evaluated by
`org-mpv-noter--client-connect' when the connection is up."
  (if (org-mpv-noter--client-connected-p)
      (let ((request-data (concat (json-encode (list :command cmd)))))
        (org-mpv-noter-debug "Sending request: %s" request-data)
        (condition-case err
            (process-send-string org-mpv-noter--client-proc (concat request-data "\n"))
          (error
           (org-mpv-noter-kill)
           (error "Unable to send commands via %s: %s" (org-mpv-noter--socket) (cdr err))))
        t)
    (when (org-mpv-noter--server-started-p)
      (org-mpv-noter-debug "Queueing command: %s" cmd)
      (setq org-mpv-noter--client-command-queue (append org-mpv-noter--client-command-queue (list cmd)))
      t)))

(defun org-mpv-noter--client-filter (proc response)
  "Handle response from the server.

PROC is the mpv process and RESPONSE is the response as a JSON
string."
  ;; JSON-STRING contains zero or more lines with JSON encoded objects, e.g.:
  ;;   {"data":"mpv 0.29.1","error":"success"}
  ;;   {"data":null,"request_id":1,"error":"success"}
  ;;   {"event":"start-file"}{"event":"tracks-changed"}
  ;; JSON-STRING can also contain incomplete JSON, e.g. `{"error":"succ'.
  ;; Therefore we maintain a buffer and process only complete lines.
  (when (buffer-live-p (process-buffer proc))
    (let ((orig-buffer (current-buffer)))
	  (with-current-buffer (process-buffer proc)
        ;; Insert new response where previous response ended
	    (let* ((proc-mark (process-mark proc))
               (moving (= (point) proc-mark)))
		  (save-excursion
		    (goto-char proc-mark)
		    (insert response)
		    (set-marker proc-mark (point)))
		  (if moving (goto-char proc-mark)))
	    ;; Process and remove all complete lines of JSON (lines are complete if
	    ;; they end with \n)
	    (let ((p0 (point-min)))
		  (while (progn (goto-char p0)
                        (end-of-line)
			            (equal (following-char) ?\n))
		    (let* ((p1 (point))
			       (line (buffer-substring p0 p1)))
			  (delete-region p0 (+ p1 1))
              ;; Return context to the subtitle file buffer because we're using
              ;; buffer-local variables to store player state.
              (with-current-buffer orig-buffer
			    (org-mpv-noter--client-handle-json line)))))))))

(defun org-mpv-noter--client-handle-json (json-string)
  "Process server response JSON-STRING."
  (let* ((json-data (condition-case nil
                        (json-read-from-string json-string)
                      (error
                       (org-mpv-noter-debug "Unable to parse JSON response:\n%S" json-string)
                       nil)))
         (event (when json-data
                  (alist-get 'event json-data))))
    (when event
      (org-mpv-noter--client-handle-event json-data))))

(defun org-mpv-noter--client-handle-event (json-data)
  "Handler for relevant mpv events.

JSON-DATA is mpv's JSON response in the form of an association
list.

See \"List of events\" in mpv(1)."
  (let ((event (alist-get 'event json-data)))
    (pcase event
      ("property-change"
       (when (string= (alist-get 'name json-data) "time-pos")
         (let ((pos-msecs (* 1000 (or (alist-get 'data json-data) 0))))
           (setq org-mpv-noter-playback-position (round pos-msecs))
           (run-hook-with-args 'org-mpv-noter-playback-position-hook org-mpv-noter-playback-position))))
      ("file-loaded"
       (setq org-mpv-noter-is-playing t)
       ;; TODO: Remove this code.  It seems unnecessary now.  Not sure why, but
       ;; I can't reproduce the issue.
       ;; Because mpv can report the player position AFTER the file was loaded
       ;; we disable automatic movement of point for a while so that the effect
       ;; of `org-mpv-noter-jump-to-current-subtitle' isn't cancelled immediately.
       ;; (org-mpv-noter-disable-sync-point-to-player-temporarily)
       (run-hooks 'org-mpv-noter-file-loaded-hook))
      ("unpause"
       (setq org-mpv-noter-is-playing t))
      ((or "pause" "end-file" "shutdown" "idle")
       (setq org-mpv-noter-is-playing nil)))))



;;; High-level functions

(defun org-mpv-noter-pause ()
  "Stop playback."
  (interactive)
  (when org-mpv-noter-is-playing
    (when (org-mpv-noter--client-send `(set_property pause yes))
      (org-mpv-noter--client-handle-event '((event . "pause"))))))

(defun org-mpv-noter-unpause ()
  "Start playback."
  (interactive)
  (unless org-mpv-noter-is-playing
    (when (org-mpv-noter--client-send `(set_property pause no))
      (org-mpv-noter--client-handle-event '((event . "unpause"))))))

(defun org-mpv-noter-toggle-pause ()
  "Start or stop playback."
  (interactive)
  (if org-mpv-noter-is-playing (org-mpv-noter-pause) (org-mpv-noter-unpause)))

(defun org-mpv-noter-playback-speed (factor)
  "Play video slower (FACTOR < 1) or faster (FACTOR > 1)."
  (interactive)
  (unless (eq org-mpv-noter-playback-speed factor)
    (when (org-mpv-noter--client-send `(set_property speed ,factor))
      (setq org-mpv-noter-playback-speed factor))))

(defun org-mpv-noter-seek (msec)
  "Move playback position MSEC milliseconds relative to current position."
  (org-mpv-noter--client-send `(seek ,(/ msec 1000.0) relative+exact)))

(defun org-mpv-noter-jump (msec)
  "Move playback position to absolute position MSEC milliseconds."
  (org-mpv-noter--client-send `(seek ,(/ msec 1000.0) absolute+exact)))

(defun org-mpv-noter-jump-to-current-subtitle ()
  "Move playback position to start of currently focused subtitle if possible."
  (let ((cur-sub-start (org-mpv-noter-subtitle-msecs-start)))
    (when cur-sub-start
      (org-mpv-noter-debug "Seeking player to focused subtitle: %S" cur-sub-start)
      (org-mpv-noter-jump cur-sub-start))))

(defun org-mpv-noter-add-subtitles (file)
  "Load FILE as subtitles in mpv."
  (org-mpv-noter--client-send `(sub-add ,file select)))

(defun org-mpv-noter-reload-subtitles ()
  "Reload subtitle file from disk."
  (org-mpv-noter--client-send '(sub-reload)))

(defun org-mpv-noter--is-video-file-p (filename)
  "Return whether FILENAME is a video file or directory."
  (and (not (or (string= filename ".") (string= filename "..")))
       (let ((filepath (expand-file-name filename)))
         (or (file-directory-p filepath)
             (member (file-name-extension filename) org-mpv-noter-video-extensions)))))

(defun org-mpv-noter--play (video)
  "Open VIDEO and play it in mpv."
  (when (org-mpv-noter--server-started-p)
    (org-mpv-noter-kill))
  (when (apply #'org-mpv-noter--server-start org-mpv-noter-arguments)
      (org-mpv-noter-debug "Opening video: %s" video)
      (org-mpv-noter--client-connect org-mpv-noter--retry-delays)
      (org-mpv-noter--client-send `(loadfile ,video replace))
      ;; mpv won't add the subtitles if the file doesn't exist yet, so we add it
      ;; via after-save-hook.
      (if (file-exists-p (buffer-file-name))
          (org-mpv-noter-add-subtitles (buffer-file-name))
        (add-hook 'after-save-hook #'org-mpv-noter--add-subtitle-after-first-save :append :local))
      (org-mpv-noter--client-send `(observe_property 1 time-pos))
      (org-mpv-noter-playback-speed org-mpv-noter-playback-speed-while-not-typing)))

(defun org-mpv-noter-play-video-from-url (url)
  "Open video file from URL in mpv.
See the mpv manual for a list of supported URL types.  If you
have youtube-dl installed, mpv can open videos from a variety of
hosting providers."
  (interactive "MURL: ")
  (org-mpv-noter--play url))

(defun org-mpv-noter-find-video (file)
  "Open video file FILE in mpv.

Video files are expected to have any of the extensions listed in
`org-mpv-noter-video-extensions'."
  (interactive (list (read-file-name "Find video: " nil nil t nil #'org-mpv-noter--is-video-file-p)))
  (org-mpv-noter--play (expand-file-name file)))

(defun org-mpv-noter--add-subtitle-after-first-save ()
  "Tell mpv to load subtitles from function `buffer-file-name'.

Don't send the load command to mpv if `org-mpv-noter-subtitle-id' returns
nil because that likely means the file is empty or invalid.

This function is supposed to be added to `after-save-hook', and
it removes itself from it so mpv doesn't add the same file every
time the buffer is saved."
  (when (org-mpv-noter-subtitle-id)
    (org-mpv-noter-add-subtitles (buffer-file-name))
    (remove-hook 'after-save-hook #'org-mpv-noter--add-subtitle-after-first-save :local)))

(defun org-mpv-noter-kill ()
  "Close connection to mpv process and kill the process."
  (org-mpv-noter--client-disconnect)
  (org-mpv-noter--server-stop))

(provide 'org-mpv-noter)
;;; org-mpv-noter.el ends here
#+end_src
** mpv-noter.el
:PROPERTIES:
:CREATED:  [2021-01-18 Mon 14:13]
:ID:       322242e1-c668-4dcb-9090-c31bf45a09a5
:END:

#+begin_src elisp
;;; org-mpv-noter.el --- A major mode for editing subtitles  -*- lexical-binding: t; -*-

;; Version: 0.0.1
;; Keywords: convenience, files, hypermedia, multimedia
;; URL: https://github.com/rndusr/org-mpv-noter
;; Package-Requires: ((emacs "25.1"))

;;; License:
;;
;; This file is not part of GNU Emacs.
;;
;; This is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.
;;
;; This is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;; Boston, MA 02110-1301, USA.

;;; Commentary:
;;
;; org-mpv-noter is a major mode for editing subtitles with Emacs and mpv.  See C-h f
;; org-mpv-noter-mode, the README.org file or https://github.com/rndusr/org-mpv-noter for more
;; information.

;;; Code:

(require 'org-mpv-noter-config)
(require 'org-mpv-noter-debug)
(require 'org-mpv-noter-common)
(require 'org-mpv-noter-srt)
(require 'org-mpv-noter-vtt)
(require 'org-mpv-noter)
#+end_src

I think a =hydra= might be more suited to the note taking workflow, but it will take up screen real estate which could impact visibility on smaller devices.

*** mpv-noter hydra
:PROPERTIES:
:CREATED:  [2021-01-18 Mon 17:04]
:ID:       c7966797-46d4-4603-bd10-94a246fe54ca
:END:
#+begin_src elisp
(setq org-mpv-noter-mode-map
  (let ((org-mpv-noter-mode-map (make-keymap)))
    (define-key org-mpv-noter-mode-map (kbd "M-n") #'org-mpv-noter-forward-subtitle-text)
    (define-key org-mpv-noter-mode-map (kbd "M-p") #'org-mpv-noter-backward-subtitle-text)
    (define-key org-mpv-noter-mode-map (kbd "C-M-a") #'org-mpv-noter-jump-to-subtitle-text)
    (define-key org-mpv-noter-mode-map (kbd "C-M-e") #'org-mpv-noter-jump-to-subtitle-end)
    (define-key org-mpv-noter-mode-map (kbd "M-[") #'org-mpv-noter-decrease-start-time)
    (define-key org-mpv-noter-mode-map (kbd "M-]") #'org-mpv-noter-increase-start-time)
    (define-key org-mpv-noter-mode-map (kbd "M-{") #'org-mpv-noter-decrease-stop-time)
    (define-key org-mpv-noter-mode-map (kbd "M-}") #'org-mpv-noter-increase-stop-time)
    (define-key org-mpv-noter-mode-map (kbd "C-M-n") #'org-mpv-noter-move-subtitle-forward)
    (define-key org-mpv-noter-mode-map (kbd "C-M-p") #'org-mpv-noter-move-subtitle-backward)
    (define-key org-mpv-noter-mode-map (kbd "C-M-f") #'org-mpv-noter-shift-subtitle-forward)
    (define-key org-mpv-noter-mode-map (kbd "C-M-b") #'org-mpv-noter-shift-subtitle-backward)
    (define-key org-mpv-noter-mode-map (kbd "M-i") #'org-mpv-noter-insert-subtitle)
    (define-key org-mpv-noter-mode-map (kbd "C-M-i") #'org-mpv-noter-insert-subtitle-adjacent)
    (define-key org-mpv-noter-mode-map (kbd "M-k") #'org-mpv-noter-kill-subtitle)
    (define-key org-mpv-noter-mode-map (kbd "M-m") #'org-mpv-noter-merge-with-next)
    (define-key org-mpv-noter-mode-map (kbd "M-M") #'org-mpv-noter-merge-with-previous)
    (define-key org-mpv-noter-mode-map (kbd "M-.") #'org-mpv-noter-split-subtitle)
    (define-key org-mpv-noter-mode-map (kbd "M-s") #'org-mpv-noter-sort)
    (define-key org-mpv-noter-mode-map (kbd "M-SPC") #'org-mpv-noter-toggle-pause)
    (define-key org-mpv-noter-mode-map (kbd "C-c C-d") #'org-mpv-noter-toggle-debugging)
    (define-key org-mpv-noter-mode-map (kbd "C-c C-v") #'org-mpv-noter-find-video)
    (define-key org-mpv-noter-mode-map (kbd "C-c C-u") #'org-mpv-noter-play-video-from-url)
    (define-key org-mpv-noter-mode-map (kbd "C-c C-p") #'org-mpv-noter-toggle-pause-while-typing)
    (define-key org-mpv-noter-mode-map (kbd "C-c C-l") #'org-mpv-noter-toggle-loop-over-current-subtitle)
    (define-key org-mpv-noter-mode-map (kbd "C-c C-r") #'org-mpv-noter-toggle-replay-adjusted-subtitle)
    (define-key org-mpv-noter-mode-map (kbd "C-c [") #'org-mpv-noter-copy-player-pos-to-start-time)
    (define-key org-mpv-noter-mode-map (kbd "C-c ]") #'org-mpv-noter-copy-player-pos-to-stop-time)
    (define-key org-mpv-noter-mode-map (kbd "C-c .") #'org-mpv-noter-toggle-sync-point-to-player)
    (define-key org-mpv-noter-mode-map (kbd "C-c ,") #'org-mpv-noter-toggle-sync-player-to-point)
    org-mpv-noter-mode-map))

#+end_src

*** mpv-noter-notes-mode
:PROPERTIES:
:CREATED:  [2021-01-18 Mon 17:04]
:ID:       21f482e3-def3-4a0b-a111-f4cb232da6ed
:END:
Instead of using the org-mpv-noter-mode major mode, we can copy the [[file:~/.emacs.d/.local/straight/repos/org-noter/org-noter.el::(define-minor-mode org-noter-notes-mode][minor mode]] defined in ~org-noter~:
#+begin_src elisp
 (define-minor-mode org-noter-notes-mode
  "Minor mode for the notes buffer.
Keymap:
\\{org-noter-notes-mode-map}"
  :keymap `((,(kbd "M-p")   . org-noter-sync-prev-page-or-chapter)
            (,(kbd "M-.")   . org-noter-sync-current-page-or-chapter)
            (,(kbd "M-n")   . org-noter-sync-next-page-or-chapter)
            (,(kbd "C-M-p") . org-noter-sync-prev-note)
            (,(kbd "C-M-.") . org-noter-sync-current-note)
            (,(kbd "C-M-n") . org-noter-sync-next-note)))
#+end_src

We may still want to extract some of its code however:
**** org-mpv-noter major mode
:PROPERTIES:
:CREATED:  [2021-01-18 Mon 17:02]
:ID:       83b95bc3-2b30-467e-b0b2-63ca116488c7
:END:
#+begin_src elisp
;;;###autoload
(define-derived-mode org-mpv-noter-mode text-mode "org-mpv-noter"
  "Major mode for editing subtitles.

org-mpv-noter uses the following terminology when it comes to changes in
subtitles' timestamps:

Adjust - Increase or decrease start or stop time of a subtitle
  Move - Increase or decrease start and stop time of a subtitle
         by the same amount
 Shift - Increase or decrease start and stop time of the current
         and all following subtitles by the same amount

Key bindings:
\\{org-mpv-noter-mode-map}"
  :group 'org-mpv-noter
  (org-mpv-noter--init)
  (add-hook 'post-command-hook #'org-mpv-noter--post-command-handler :append :local)
  (add-hook 'before-save-hook #'org-mpv-noter-sort :append :local)
  (add-hook 'after-save-hook #'org-mpv-noter-reload-subtitles :append :local)
  (add-hook 'kill-buffer-hook #'org-mpv-noter-kill :append :local)
  (add-hook 'kill-emacs-hook #'org-mpv-noter-kill :append :local)
  (when org-mpv-noter-auto-find-video
    (let ((video-file (org-mpv-noter-guess-video-file)))
      (when video-file
        (org-mpv-noter-debug "Auto-discovered video file: %s" video-file)
        (condition-case err
            (org-mpv-noter-find-video video-file)
          (error (message "%s -- Set org-mpv-noter-auto-find-video to nil to avoid this error."
                          (car (cdr err))))))))
  (org-mpv-noter-enable-pause-while-typing :quiet)
  (org-mpv-noter-enable-sync-point-to-player :quiet)
  (org-mpv-noter-enable-sync-player-to-point :quiet)
  (org-mpv-noter-enable-replay-adjusted-subtitle :quiet)
  (org-mpv-noter-enable-loop-over-current-subtitle :quiet))

;; Internally, supported formats are listed in `org-mpv-noter--init-alist', which
;; associates file extensions with format-specific init methods (e.g. "srt" ->
;; org-mpv-noter-srt--init).  Here we map each file extension as a regexp to
;; `org-mpv-noter-mode-enable', which will call the format-specific init method and do
;; generic init stuff.
;;;###autoload
(dolist (item org-mpv-noter--init-alist)
  (let ((file-ext-regex (car item)))
    (add-to-list 'auto-mode-alist (cons (concat "\\." file-ext-regex "\\'")
                                        'org-mpv-noter-mode))))

(provide 'org-mpv-noter)
;;; org-mpv-noter.el ends here
#+end_src

*** Uneeded code
:PROPERTIES:
:CREATED:  [2021-01-18 Mon 17:04]
:ID:       6ad3bdc2-d491-4adb-82e9-0cfb922ecb9e
:END:
Most likely we won't need this as the format is always going to be orgmode.
#+begin_src elisp
;;; Abstraction hack to support different subtitle formats
;;
;; We need subtitle format-specific functions for each individual buffer so it
;; is possible to open a .srt and a .sub file in the same Emacs session.
;; Buffer-local functions don't exist in Elisp, but we can store the format in a
;; buffer-local variable.
;;
;; `org-mpv-noter-mode-enable' runs a format-specific init function based on the file
;; extension.  The init function sets the buffer-local variable
;; `org-mpv-noter--subtitle-format' which is then used by generic functions to assemble
;; the names of format-specific functions on the fly (e.g. (concat "org-mpv-noter-"
;; org-mpv-noter-subtitle-format "--subtitle-id")).

(defvar org-mpv-noter--generic-function-suffixes
  (list "subtitle-id" "subtitle-id-max" "subtitle-id-at-msecs"
        "subtitle-msecs-start" "subtitle-msecs-stop"
        "subtitle-text" "subtitle-relative-point"
        "jump-to-subtitle-id" "jump-to-subtitle-id-at-msecs"
        "jump-to-subtitle-time-start" "jump-to-subtitle-time-stop"
        "jump-to-subtitle-text" "jump-to-subtitle-text-at-msecs"
        "jump-to-subtitle-end"
        "forward-subtitle-id" "backward-subtitle-id"
        "forward-subtitle-text" "backward-subtitle-text"
        "forward-subtitle-end" "backward-subtitle-end"
        "forward-subtitle-time-start" "backward-subtitle-time-start"
        "forward-subtitle-time-stop" "backward-subtitle-time-stop"
        "set-subtitle-time-start" "set-subtitle-time-stop"
        "prepend-subtitle" "append-subtitle" "kill-subtitle" "merge-with-next"
        "regenerate-ids" "regenerate-ids-soon"
        "sanitize" "validate" "sort"))

(defun org-mpv-noter--get-generic-func (func-suffix)
  "Return the generic/public function for FUNC-SUFFIX."
  (intern (concat "org-mpv-noter-" func-suffix)))

(defun org-mpv-noter--get-specific-func (func-suffix)
  "Return the format-specific function for the current buffer for FUNC-SUFFIX."
  (intern (concat "org-mpv-noter-" org-mpv-noter--subtitle-format "--" func-suffix)))

(defun org-mpv-noter--init ()
  "Call subtitle format-specific init function and (re-)alias generic functions."
  ;; Call format-specific init function based on file extension and
  ;; `org-mpv-noter--init-alist'.
  (let* ((file-ext (when (buffer-file-name)
                     (file-name-extension (buffer-file-name))))
         (init-func (alist-get file-ext org-mpv-noter--init-alist nil nil 'equal)))
    (if (functionp init-func)
        (funcall init-func)
      (error "Missing init function: %S" init-func))
    (unless org-mpv-noter--subtitle-format
      (error "%S failed to set buffer-local variable: org-mpv-noter--subtitle-format"
             init-func)))
  ;; Define generic functions like `org-mpv-noter-subtitle-text'.
  (cl-loop for func-suffix in org-mpv-noter--generic-function-suffixes do
           (let ((generic-func (org-mpv-noter--get-generic-func func-suffix))
                 (specific-func (org-mpv-noter--get-specific-func func-suffix)))
             (unless (functionp specific-func)
               (error "Missing subtitle format-specific function: %s" specific-func))
             (if (functionp specific-func)
               (let* ((argspec (help-function-arglist specific-func))
                      (argvars (seq-filter (lambda (argvar)
                                             (let ((first-char (substring (symbol-name argvar) 0 1)))
                                               (not (equal first-char "&"))))
                                           argspec)))
                 (defalias generic-func
                   `(lambda ,argspec
                      ,(interactive-form specific-func) ;; (interactive ...) or nil
                      (let (;; Get the format-specific function for the current
                            ;; buffer.  We must do this every time the generic
                            ;; function is called because the result depends on
                            ;; the buffer-local variable `org-mpv-noter--subtitle-format'.
                            (specific-func (org-mpv-noter--get-specific-func ,func-suffix))
                            ;; Turn the list of variable names into a list of
                            ;; corresponding values.
                            (argvals (mapcar 'eval ',argvars)))
                        (apply specific-func argvals)))
                   (documentation specific-func t)))))))
#+end_src

* org-brain integration
:PROPERTIES:
:CREATED:  [2021-01-15 Fri 19:51]
:ID:       c53811c9-1ada-4958-9389-5b823a811479
:END:

#+begin_src elisp
(org-brain-open-resource (org-brain-entry-at-pt t))
#+end_src
* org-noter integration
:PROPERTIES:
:CREATED:  [2021-01-19 Tue 16:27]
:ID:       6f30757e-e54b-4e7b-a43f-1443c1090730
:END:

#+begin_src elisp
;;; lang/org-private/+ir.el -*- lexical-binding: t; -*-
#+end_src

This should be a minor mode as is done with [[file:~/.emacs.d/.local/straight/repos/org-noter/org-noter.el::(define-minor-mode org-noter-notes-mode][org-noter]] (note that there are /2/ minor modes).
#+begin_src elisp
;; Key binds etc
(use-package! major-mode-hydra
  :config
  (major-mode-hydra-define pdf-view-mode
    (:title "Incremental Reading Options")
    ("Reading qeue"
     ;; There should a hydra that moves to the next item in the reading que
     (("n" evil-collection-pdf-view-next-line-or-next-page "next")
      ("p" evil-collection-pdf-view-previous-line-or-previous-page "previous"))
     "Test"
     (("s" isearch-forward "search"))
     ;; "Priority"
     ;; Priority setting options
     ;;TODO Should define some functions
     "Drill"
     (("d" nanjigen/org-drill-in-ir-dir "org-drill items")
      ("D" org-drill-resume "Resume last org-drill"))
     )))

  (pretty-hydra-define ir-hydra
    (:color blue :title "Incremental Reading")
    ("Reading que"
     ;; There should a hydra that moves to the next item in the reading que
     (("n" evil-collection-pdf-view-next-line-or-next-page "next")
      ("p" evil-collection-pdf-view-previous-line-or-previous-page "previous"))
     "org-noter"
     (("o" follow-noter-page-link "follow org-pdftools link")
      ;; Should this be a function in a specific workspace?
      ("N" org-noter "Start org-noter session")
      ("S" org-noter-pdftools-create-skeleton "Create org-noter outline"))
     ;; "Priority"
     ;; Priority setting options
     ;;TODO Should define some functions
     "Drill"
     (("d" nanjigen/org-drill-in-ir-dir "org-drill items")
      ("D" org-drill-resume "Resume last org-drill"))
     ))


(map! :localleader
      :map pdf-view-mode-map
          :desc "Insert to Org" "h" 'nanjigen/org-noter-highlight-drill)

#+end_src

The below function is an addition to [[file:~/.emacs.d/.local/straight/repos/org-noter/org-noter.el::defun org-noter-insert-note-toggle-no-questions (][org-noter-insert-note-no-questions]], possibly to insure that the ~org-pdftools~ link gets inserted correctly.
#+begin_src elisp
  ;; Add a function to ensure precise note is inserted
  (defun org-noter-pdftools-insert-precise-note (&optional toggle-no-questions)
    (interactive "P")
    (org-noter--with-valid-session
     (let ((org-noter-insert-note-no-questions (if toggle-no-questions
                                                   (not org-noter-insert-note-no-questions)
                                                 org-noter-insert-note-no-questions))
           (org-pdftools-use-isearch-link t)
           (org-pdftools-use-freestyle-annot t))
       (org-noter-insert-note (org-noter--get-precise-info)))))

#+end_src

We want items inserted with the following syntax:
#+begin_example org-mode
,** [[cite:laufer2001][10]] annot-2-0 | descriptive text                  :extract:
#+end_example

The =:extract:= tag will allow us to target those inserted headers with ~elisp~ code, and differentiate extraction headers from skeleton entries. The =cite:= syntax activates ~org-ref~ functions which may be used programmatically down the line. The "annot-2-0" is a reference to the ~org-pdftools~ link syntax -
(:NOTER_PAGE: [[pdf:~/Documents/PDF/laufer2001.pdf::2++0.00;;annot-2-0]] in this case).
The first numeral, 2, is a reference to the internal page number of the source pdf. With some text-munging we can procure the page number of the pdf for the given extract and potentially insert that into an org-buffer when writing to aid with citing: [[cite:laufer2001][2]].

#+begin_src elisp
(org-ref-insert-link nil)
(funcall org-ref-insert-cite-function)
(defun nanjigen/org-pdftools-annot-id ()
  "get 'annot' id from 'NOTER_PAGE' property"
  (interactive)
  (let* ((id (car (last (s-split ";;" (org-entry-get nil "NOTER_PAGE")))))
         (id-clean (s-chop-suffix "]]" id)))
    (insert (format "%s" id-clean))))

(org-toggle-tag "extract")
#+end_src

#+begin_src elisp
(when (and org-noter-insert-selected-text-inside-note selected-text) (insert (concat "#+begin_quote\n" selected-text "\n#+end_quote")))

(defun org-noter-insert-note-content ()
  (interactive)
  (progn (setq currenb (buffer-name))
         (set-buffer currenb)
         (org-noter-insert-note)
         ;; (org-noter-quote)
))

(fset 'org-noter-quote
      (kmacro-lambda-form [?  ?: ?j ?o ?i ?n ?e ?  backspace backspace return ?V ?  ?i ?s ?q ?u ?o ?t ?e return escape ?\{ ?\{ ?d ?d] 0 "%d"))

(setq org-noter-default-heading-title )
#+end_src

#+begin_src elisp
(defun org-noter-insert-selected-text-as-content (&optional precise-info)
  "Insert note associated with the current location.

This command will prompt for a title of the note and then insert
it in the notes buffer. When the input is empty, a title based on
`org-noter-default-heading-title' will be generated.

If there are other notes related to the current location, the
prompt will also suggest them. Depending on the value of the
variable `org-noter-closest-tipping-point', it may also
suggest the closest previous note.

PRECISE-INFO makes the new note associated with a more
specific location (see `org-noter-insert-precise-note' for more
info).

When you insert into an existing note and have text selected on
the document buffer, the variable `org-noter-insert-selected-text-inside-note'
defines if the text should be inserted inside the note."
  (interactive)
  (org-noter--with-valid-session
   (let* ((ast (org-noter--parse-root)) (contents (org-element-contents ast))
          (window (org-noter--get-notes-window 'force))
          (selected-text
           (cond
            ((eq (org-noter--session-doc-mode session) 'pdf-view-mode)
             (when (pdf-view-active-region-p)
               (mapconcat 'identity (pdf-view-active-region-text) ? )))

            ((eq (org-noter--session-doc-mode session) 'nov-mode)
             (when (region-active-p)
               (buffer-substring-no-properties (mark) (point))))))
          force-new
          (location (org-noter--doc-approx-location (or precise-info 'interactive) (gv-ref force-new)))
          (view-info (org-noter--get-view-info (org-noter--get-current-view) location)))

     (let ((inhibit-quit t))
       (with-local-quit
         (select-frame-set-input-focus (window-frame window))
         (select-window window)

         ;; IMPORTANT(nox): Need to be careful changing the next part, it is a bit
         ;; complicated to get it right...

         (let ((point (point))
               (minibuffer-local-completion-map org-noter--completing-read-keymap)
               collection default default-begin title selection
               (empty-lines-number (if org-noter-separate-notes-from-heading 2 1)))

           (cond
            ;; NOTE(nox): Both precise and without questions will create new notes
            ((or precise-info force-new)
             (setq default (and selected-text (replace-regexp-in-string "\n" " " selected-text))))
            (org-noter-insert-note-no-questions)
            (t
             (dolist (note-cons (org-noter--view-info-notes view-info))
               (let ((display (org-element-property :raw-value (car note-cons)))
                     (begin (org-element-property :begin (car note-cons))))
                 (push (cons display note-cons) collection)
                 (when (and (>= point begin) (> begin (or default-begin 0)))
                   (setq default display
                         default-begin begin))))))

           (setq collection (nreverse collection)
                 title (if org-noter-insert-note-no-questions
                           default
                         (completing-read "Note: " collection nil nil nil nil default))
                 selection (unless org-noter-insert-note-no-questions (cdr (assoc title collection))))


             ;; NOTE(nox): Inserting a new note
             (let ((reference-element-cons (org-noter--view-info-reference-for-insertion view-info))
                   level)
                 (setq title "test")
                 ;; (setq title (replace-regexp-in-string (regexp-quote "$p$") (number-to-string (car location))
                 ;;                                       org-noter-default-heading-title))

           (org-show-set-visibility t)
           (org-cycle-hide-drawers 'all)
           (org-cycle-show-empty-lines t)))
       (when quit-flag
         ;; NOTE(nox): If this runs, it means the user quitted while creating a note, so
         ;; revert to the previous window.
         (select-frame-set-input-focus (org-noter--session-frame session))
         (select-window (get-buffer-window (org-noter--session-doc-buffer session)))))))))
#+end_src

#+name: selected text to content
#+begin_src elisp
(defun org-noter-insert-selected-text-as-content (&optional precise-info)
  "Insert note associated with the current location.

This command will prompt for a title of the note and then insert
it in the notes buffer. When the input is empty, a title based on
`org-noter-default-heading-title' will be generated.

If there are other notes related to the current location, the
prompt will also suggest them. Depending on the value of the
variable `org-noter-closest-tipping-point', it may also
suggest the closest previous note.

PRECISE-INFO makes the new note associated with a more
specific location (see `org-noter-insert-precise-note' for more
info).

When you insert into an existing note and have text selected on
the document buffer, the variable `org-noter-insert-selected-text-inside-note'
defines if the text should be inserted inside the note."
  (interactive)
  (org-noter--with-valid-session
   (let* ((ast (org-noter--parse-root)) (contents (org-element-contents ast))
          (window (org-noter--get-notes-window 'force))
          (selected-text
           (cond
            ((eq (org-noter--session-doc-mode session) 'pdf-view-mode)
             (when (pdf-view-active-region-p)
               (mapconcat 'identity (pdf-view-active-region-text) ? )))

            ((eq (org-noter--session-doc-mode session) 'nov-mode)
             (when (region-active-p)
               (buffer-substring-no-properties (mark) (point))))))
          force-new
          (location (org-noter--doc-approx-location (or precise-info 'interactive) (gv-ref force-new)))
          (view-info (org-noter--get-view-info (org-noter--get-current-view) location)))

     (let ((inhibit-quit t))
       (with-local-quit
         (select-frame-set-input-focus (window-frame window))
         (select-window window)

         ;; IMPORTANT(nox): Need to be careful changing the next part, it is a bit
         ;; complicated to get it right...

         (let ((point (point))
               (minibuffer-local-completion-map org-noter--completing-read-keymap)
               collection default default-begin title selection
               (empty-lines-number (if org-noter-separate-notes-from-heading 2 1)))

           (cond
            ;; NOTE(nox): Both precise and without questions will create new notes
            ((or precise-info force-new)
             (setq default (and selected-text (replace-regexp-in-string "\n" " " selected-text))))
            (org-noter-insert-note-no-questions)
            (t
             (dolist (note-cons (org-noter--view-info-notes view-info))
               (let ((display (org-element-property :raw-value (car note-cons)))
                     (begin (org-element-property :begin (car note-cons))))
                 (push (cons display note-cons) collection)
                 (when (and (>= point begin) (> begin (or default-begin 0)))
                   (setq default display
                         default-begin begin))))))

           (setq collection (nreverse collection)
                 title (if org-noter-insert-note-no-questions
                           default
                         (completing-read "Note: " collection nil nil nil nil default))
                 selection (unless org-noter-insert-note-no-questions (cdr (assoc title collection))))

           (if selection
               ;; NOTE(nox): Inserting on an existing note

               (let* ((note (car selection))
                      (insert-before-element (cdr selection))
                      (has-content
                       (eq (org-element-map (org-element-contents note) org-element-all-elements
                             (lambda (element)
                               (if (org-noter--check-location-property element)
                                   'stop
                                 (not (memq (org-element-type element) '(section property-drawer)))))
                             nil t)
                           t)))
                 (when has-content (setq empty-lines-number 2))
                 (if insert-before-element
                     (goto-char (org-element-property :begin insert-before-element))
                   (goto-char (org-element-property :end note)))


                 (if (org-at-heading-p)
                     (progn
                       (org-N-empty-lines-before-current empty-lines-number)
                       (forward-line -1))
                   (unless (bolp) (insert "\n"))
                   (org-N-empty-lines-before-current (1- empty-lines-number)))

                 (when (and org-noter-insert-selected-text-inside-note selected-text) (insert selected-text)))
                 ;; (insert selected-text))

             ;; NOTE(nox): Inserting a new note
             (let ((reference-element-cons (org-noter--view-info-reference-for-insertion view-info))
                   level)
               (when (zerop (length title))
                 (setq title (replace-regexp-in-string (regexp-quote "$p$") (number-to-string (car location))
                                                       org-noter-default-heading-title)))

               (if reference-element-cons
                   (progn
                     (cond
                      ((eq (car reference-element-cons) 'before)
                       (goto-char (org-element-property :begin (cdr reference-element-cons))))
                      ((eq (car reference-element-cons) 'after)
                       (goto-char (org-element-property :end (cdr reference-element-cons)))))

                     ;; NOTE(nox): This is here to make the automatic "should insert blank" work better.
                     (when (org-at-heading-p) (backward-char))

                     (setq level (org-element-property :level (cdr reference-element-cons))))

                 (goto-char (org-element-map contents 'section
                              (lambda (section) (org-element-property :end section))
                              nil t org-element-all-elements))
                 (setq level (1+ (org-element-property :level ast))))

               ;; NOTE(nox): This is needed to insert in the right place
               (outline-show-entry)
               (org-noter--insert-heading level title empty-lines-number location)
               (when (org-noter--session-hide-other session) (org-overview))

               (setf (org-noter--session-num-notes-in-view session)
                     (1+ (org-noter--session-num-notes-in-view session)))))

           (org-show-set-visibility t)
           (org-cycle-hide-drawers 'all)
           (org-cycle-show-empty-lines t)))
       (when quit-flag
         ;; NOTE(nox): If this runs, it means the user quitted while creating a note, so
         ;; revert to the previous windo.
         (select-frame-set-input-focus (org-noter--session-frame session))
         (select-window (get-buffer-window (org-noter--session-doc-buffer session))))))))
#+end_src

** old org-noter code                                                :extract:
:PROPERTIES:
:CREATED:  [2021-01-19 Tue 17:18]
:ID:       52a04c78-0f21-46af-80af-18a43cbea9f4
:header-args: :tangle ~/.doom.d/modules/lang/org-private/+ir.el :noweb yes
:END:

#+begin_src elisp
;;; lang/org-private/+ir.el -*- lexical-binding: t; -*-
#+end_src

The actual function to extract to point
#+begin_src elisp
(defun nanjigen/org-noter-extract ()
  "Extract highlighted text into org-noter buffer as org-drill item"
  (interactive)
  ;; (org-back-to-heading)
  (save-window-excursion
  ;; Now I need to move the header text (which is the extracted pdf text) into the body
    (progn
      (nanjigen/move-headline-to-contents)
      (org-toggle-tag "extract"))))
#+end_src

#+begin_src elisp
(defun nanjigen/open-link-clipboard ()
  (interactive)
  (let ((link (substring-no-properties (x-get-selection 'CLIPBOARD 'STRING))))
    (org-link-open-from-string link)))

;; (org-noter "[[pdf:/home/vrika/Documents/PDF/books/wickedcoolshellscripts.pdf::1]]")
;; (org-brain-open-org-noter "3f0bea0e-07dd-4e48-9df7-aaeb8f1d3b8d")
#+end_src

#+RESULTS:
: nanjigen/open-link-clipboard

This is a fairly ugly hack. My ultimate intention is to use modified org-noter code.
#+begin_src elisp
(defun nanjigen/move-headline-to-contents ()
  "Move extracted PDF text to body of subtree"
  (interactive)
  ;; (let ((origin-element-type (org-element-type (org-element-at-point))))
  ;;   (if (string-equal "property-drawer" origin-element-type)
  ;;       (evil-insert-newline-below)))
  (progn
    ;; (with-selected-window (org-noter--get-notes-window)
    ;;   (evil-insert-newline-below))
    (org-noter-insert-note-toggle-no-questions)
    (org-back-to-heading)
    (org-toggle-tag "extract")
    (let* ((parent
            (save-excursion
              (org-backward-element)
              (org-element-property :title (org-element-at-point))))
           (headline (org-element-at-point))
           (title (org-element-property :title headline))
           (property-end (org-element-property :contents-end headline))
           ;; (property (org-element-at-point (goto-char property-pos)))
           (indent (org-element-property :level headline))
           (title-start (+ indent (org-element-property :begin headline)))
           (title-end (- (org-element-property :contents-begin headline) 1))
           (annot-id (car (last (s-split ";;" (org-entry-get nil "NOTER_PAGE")))))
           (annot-id-clean (s-chop-suffix "]]" annot-id))
           (org-uuid (org-entry-get nil "ID"))
           (annot-link (format "[[brain:%s][%s]]" org-uuid annot-id-clean))
           (cite-page (with-selected-window (org-noter--get-doc-window)
                        (format "%s"
                                (eval '(nth (1- (pdf-view-current-page))
                                            (pdf-cache-pagelabels))))))
           (cite (file-name-sans-extension (file-name-nondirectory (buffer-file-name)))))
      ;; (when (eq 'property-drawer (car property))
      ;; (goto-char (org-element-property :end property)))
      (goto-char property-end)
      (insert title)
      (delete-region title-start title-end)
      (goto-char title-start)
      ;;HACK use logic to identify if parent is an org-noter-outline headline
      ;; and then indent with org-mode code, not a hacky *!
      (insert (format " [[cite:%s][p%s]] %s" cite cite-page annot-link))
      ;; (save-excursion
        ;; (if (not (string-prefix-p "cite" parent))
        ;;     ;; (nanjigen/org-move-to-sibling)
        ;;     (nanjigen/org-move-to-extreme)
        ;;   )
      ;;
      ;;     (insert (format " cite:%s %s" cite id-clean))
      ;;   (insert (format "* cite:%s %s" cite id-clean)))
      (org-back-to-heading))))
#+end_src

#+RESULTS:
: nanjigen/move-headline-to-contents

Attempting to move to max point in tree from https://emacs.stackexchange.com/questions/43651/moving-a-subtree-to-the-top-or-bottom-of-its-parent/43662#43662
#+begin_src elisp
(defun nanjigen/org-move-to-extreme ()
  "Move current org subtree to the start of its parent."
  (interactive)
  (condition-case err
      (while t
        (funcall 'org-move-subtree-up)))
    (user-error
     (let ((err-msg (cadr err)))
       (unless (string-match "Cannot move past superior level or buffer limit" err-msg)
         (signal 'user-error (list err-msg))))))
#+end_src

#+begin_src elisp
(defun nanjigen/org-move-to-sibling ()
  "Move extracted org subtree under its 'cite:' sibling."
  (interactive)
  (setq parent (nanjigen/org-get-above-headline))
  (while (not (string-prefix-p "cite" parent))
     (funcall 'org-move-subtree-up)
     (setq parent (nanjigen/org-get-above-headline))))
#+end_src

#+begin_src elisp
(defun nanjigen/org-get-above-headline ()
"Get the headline entry of above parent/sibling as text"
(save-excursion
  (org-backward-element)
  (org-element-property :title (org-element-at-point))))
#+end_src

#+RESULTS:
: JK-org-move-to-extreme

#+begin_src elisp
(defun nanjigen/chopper ()
  "get 'annot' id from 'NOTER_PAGE' property"
  (interactive)
  (let* ((id (car (last (s-split ";;" (org-entry-get nil "NOTER_PAGE")))))
         (id-clean (s-chop-suffix "]]" id)))
    (insert (format "%s" id-clean))))

(defun nanjigen/delete-headline ()
  "delete the original title of text extracted with
(org-noter-insert-note-toggle-no-questions)"
  (interactive)
  (let* ((headline (org-element-at-point))
         (title-start (org-element-property :contents-begin headline))
         (title-end (org-element-property :end headline)))
    (delete-region title-start title-end)))

;; Functions for capturing from org noter
  (defun nanjigen/get-noter-link ()
    "return PROPERTY value of pdftools link"
    (interactive)
    (let ((linkStr (org-entry-get nil "NOTER_PAGE")))
      (insert linkStr)))

  ;;https://emacs.stackexchange.com/questions/32283/how-to-capture-and-link-code-comments-as-org-agenda-items
  (defun capture-noter-link ()
    "insert PROPERTY value of pdftools link"
    (interactive)
    (let ((linkStr
            (save-excursion
              (save-window-excursion
                (switch-to-buffer (plist-get org-capture-plist :original-buffer))
                (car (org-get-outline-path)))
              )))
      ))


  (defun insert-key (&optional p)
    "insert header as key value of org-brain header"
    ;; (unless p (setq p "NOTER_PAGE"))
    ;; (message "property passed is: %s" p)
    (interactive)
    (let ((pvalue
            (save-window-excursion
              (message "%s" (org-capture-get :original-buffer))
              (switch-to-buffer (org-capture-get :original-buffer))
              (message "retrieved header (key) is: %s" (car (org-get-outline-path (point) p)))
              (car (org-get-outline-path (point) p))
              )))
      pvalue))


  (defun key-to-header (&optional p)
    "insert header in org-capture target file as key value of org-brain header"
    ;; (unless p (setq p "NOTER_PAGE"))
    ;; (message "property passed is: %s" p)
    (interactive)
    (let ((heading
            (save-window-excursion
              (message "%s" (org-capture-get :original-buffer))
              (switch-to-buffer (org-capture-get :original-buffer))
              (message "retrieved header (key) is: %s" (car (org-get-outline-path (point) p)))
              (car (org-get-outline-path (point) p))
              )))
      (goto-char (org-find-exact-headline-in-buffer "IR Cards"))
      (unless (search-forward (format "** %s" heading) nil t)
        (org-end-of-subtree)
        (insert (format "\n** %s" heading))
        )))

  (defun insert-property (&optional p)
    "insert PROPERTY value of pdftools link"
    (interactive)
    (unless p (setq p "NOTER_PAGE"))
    (message "property passed is: %s" p)
    (let ((pvalue
            (save-window-excursion
              (message "%s" (org-capture-get :original-buffer))
              (switch-to-buffer (org-capture-get :original-buffer))
              (message "retrieved property is: %s" (org-entry-get (point) p))
              (org-entry-get (point) p)
              )))
      pvalue))

  (defun follow-noter-page-link ()
    "return PROPERTY value of pdftools link and follow in other-window"
    (interactive)
    ;; (run-with-timer 3 nil (lambda ()
      ;; TODO switch-to-buffer?
    (let ((linkStr (org-entry-get nil "NOTER_PAGE")))
      (if (> (length (window-list)) 1)
          (other-window 1)
        ;; (balance-windows)
          ;; (switch-to-buffer-other-window)
        (split-window-right))
      (org-link-open-from-string linkStr)))
;;
#+end_src

** Flameshot
:PROPERTIES:
:CREATED:  [2021-06-02 Wed 17:04]
:ID:       1b6ec7b5-1957-4b53-ad71-1f58f2b99fac
:END:

#+begin_src elisp
(use-package! org-download)

(defun org-noter-insert-image-slice-note ()
  (interactive)
  (async-start (shell-command "flameshot gui")
               (progn
                 ;; (switch-to-buffer )
                 (shell-command "xdotool key --clearmodifiers super+Tab")
                 (async-start (org-noter-insert-note)
                   (org-download-clipboard)))))

(define-key org-noter-doc-mode-map (kbd "y") 'org-noter-insert-image-slice-note)
#+end_src

** old org-drill code
:PROPERTIES:
:CREATED:  [2021-01-20 Wed 13:58]
:ID:       7a12e649-f742-443e-bf42-6de953eb9752
:END:
#+begin_src elisp
;; This is to initiate drill from anywhere
;; Have next PDF fire off instead if all done?
(defun nanjigen/org-drill-in-ir-dir ()
  (interactive)
  (with-current-buffer (find-file-noselect "~/org/article-notes/article-index.org")
    (org-drill)))


;; (advice-add 'org-drill-reschedule :after-until #'follow-noter-page-link)
;; (advice-add 'org-drill-entry-p :after #'follow-noter-page-link)
;; (advice-add '(org-drill-entries (session-done)) :after #'follow-noter-page-link)
;; (advice-add 'org-drill-goto-entry :after #'follow-noter-page-link)
;; (advice-add 'org-drill-present-simple-card :after #'follow-noter-page-link)
;; (advice-add 'org-drill-present-default-answer :after #'follow-noter-page-link)
;; (advice-add 'org-drill-present-two-sided-card :after #'follow-noter-page-link)
;; (advice-add 'org-drill--edit-key :after #'follow-noter-page-link)
;; (advice-add 'org-drill-response-complete-rtn :after #'follow-noter-page-link)
;; (advice-add 'org-drill-response-complete :after #'follow-noter-page-link)
;; (advice-add 'org-drill-response-quit  :after #'follow-noter-page-link)
;; (add-function :after ('org-drill-response-edit) #'follow-noter-page-link)
;; (advice-add 'org-drill-response-complete :after #'follow-noter-page-link)
(advice-add 'org-drill-response-edit :after #'follow-noter-page-link)
(advice-add 'org-drill-response-edit :after-while #'follow-noter-page-link)
(advice-add 'org-drill-response-quit  :after #'follow-noter-page-link)
;; (advice-add 'org-drill--edit-key :after #'follow-noter-page-link)


;; This triggers the function but not at the right time
;; (add-hook 'org-drill-display-answer-hook #'follow-noter-page-link)
#+end_src
