#+BRAIN_PARENTS: system
#+TITLE: Supermemo configuration
#+auto_tangle: t

This is my literate config detailing the installation and management of Supermemo under Wine - interfaced via Emacs.

Features:

- Automated installation of SM18 under Wine (mostly via ~supermemo-wine~)
- Emacs integration by the following means:
  + Emacs and EXWM x-window/buffer management
    - Reliable named buffers navigate-able through EXWM
    - =display-buffer-alist= rules for SM windows; allowing for declarative window arrangement
    - ~Burly~ bookmarking of SM views
  + Text-streams via =exwm-input--fake-key= (utilizing ~Autohotkey~ as a backend) allowing for
    - vIM-style modal bindings with NORMAL and Insert modes (EXWM).
    - Access to SM interface options as hydra-menus.
    - Item element editing in org buffers, with all markup converted back to HTML.

- Bridging functions between SMA, SM, and Emacs creating possibilities for:
  + Helm fuzzy lookup of elements based on their element-id
  + Org-mode card building, much like [[https://github.com/louietan/anki-editor][anki-editor]]
  + *Incremental video via mpv*, allowing for ~lua~ script based generation of gifs, extractions of subs.
  + *Incremental writing of email with ~mu4e~!*
  + *Incremental literate programming* with org-mode and SM's algorithm!


* Installation
:PROPERTIES:
:CREATED:  [2020-11-19 Thu 22:48]
:ID:       c5e3d6cf-81c6-47cf-9bf3-eff77b6a5270
:END:
This guide is meant as a 0-to-working playbook. Parts of it tangle to scripts and Elisp config files that may be opinionated and platform specific. One day it might exist as a Melpa package but for now should be treated as a walk-through.

The first hurdle is getting a working installation of SM18.
We'll be using allesivs [[https://github.com/alessivs/supermemo-wine][supermemo-wine]] .verb for the installation of SM18.

Cloning in the verbs:
#+begin_src sh
cd ~/Templates/sm
git clone https://github.com/alessivs/supermemo-wine.git
#+end_src

Make sure we have the correct wine version: https://dl.winehq.org/wine/source/5.x/

#+begin_src sh
wine --version
#+end_src

#+RESULTS:
: wine-5.2

#+begin_src sh :mkdirp yes :results silent
cd ~/Templates/sm/
curl -O https://dl.winehq.org/wine/source/5.x/wine-5.2.tar.xz
#+end_src

After installation of (the [[https://github.com/Winetricks/winetricks/issues/1593][correct]] version) Wine and Winetricks we can setup the =wineprefix= and install.
Something about the ~:dir sudo~ syntax isn't working
#+begin_src sh :dir /sudo::/vrika
cd ~/Templates/sm/
tar -xf wine-5.2.tar.xz
cd /wine-5.2
./configure
make
sudo make install
#+end_src

#+begin_src sh
env WINEARCH=win32 sh winetricks arch=32 prefix=supermemo18
sh winetricks prefix=supermemo18 ~/Templates/sm/supermemo-wine/verbs/supermemo18.verb
#+end_src

#+RESULTS:

* Setup SM window management
:PROPERTIES:
:CREATED:  [2020-10-09 Fri 18:15]
:ID:       5f96c370-eb26-4117-a7d8-43793e465c9d
:END:
By identifying and naming different SuperMemo window buffers, we can have a reliable way to target those buffers with text streams. Specifically, we can target a buffer with a simulated keypress, affording us a kind of poor-man's API by way of scripting window movement and key-chords in an orchistrated way.

** Capturing buffers
:PROPERTIES:
:CREATED:  [2020-11-20 Fri 10:39]
:ID:       8cf89b9a-bdb4-41a4-a3a9-4343be5c0ee6
:END:

A quirk of using SM under Wine is that a virtual desktop

We want to capture the following buffer titles with a regex so that we can move:
a. The Knowledge tree to the left of the screen.
b. The tray to the bottom, but not spanning the whole width of the screen.
c. Have the review buffer as the main window.
d. Have all other SM related windows as floating frames centered on the screen.

We'll use [[info:elisp#Rx][rx]] to handle the notation.

Example of the kinds of text we'll need to capture:
#+begin_example:
Topic #10:
Element #9:
OR
Element
sm18.exe/Second Language
#+end_example:

We can test if our regex captures this

#+name: element-window-rx
#+begin_src elisp
(rx bol "home" eol)
#+end_src

#+RESULTS: element-window-rx
: ^home$

#+begin_src elisp :noweb yes
(seq-filter (lambda (buf)
              (string-match-p
               <<element-window-rx>>
               (buffer-name buf)))
            (buffer-list))
#+end_src

#+RESULTS:

lol
#+begin_src elisp :noweb yes
(add-hook 'exwm-update-title-hook
          (defun sm-element-test-class-hook ()
            (when (string-match "Mousepad" exwm-class-name)
              (exwm-workspace-rename-buffer exwm-title))))
#+end_src

#+RESULTS:
| sm-element-test-class-hook | my-exwm-update-title-hook |

#+NAME: element-data-rx
#+begin_src elisp
(rx (| (seq (or "Topic" "Element") space "#" (one-or-more digit) ":") (seq "Element data")))
#+end_src

#+RESULTS: element-data-rx
: \(?:Element\|Topic\)[[:space:]]#[[:digit:]]+:\|Element data

#+begin_src elisp :noweb yes
(seq-filter (lambda (buf)
              (string-match-p
               <<element-data-rx>>
               (buffer-name buf)))
            (buffer-list))
#+end_src

#+RESULTS:

Next capture the knowledge tree:
"X:sm18.exe/neuron"
#+NAME: knowledge-tree-rx
#+begin_src elisp
(rx bol "neuron" eol)
#+end_src

#+RESULTS: knowledge-tree-rx
: ^neuron$

#+begin_src elisp :noweb yes
(seq-filter (lambda (buf)
              (string-match-p
               <<knowledge-tree-rx>>
               (buffer-name buf)))
            (buffer-list))
#+end_src

#+RESULTS:

We'll also attempt to suppress the empty(?) buffer created by Supermemo.
#+NAME: empty-sm-rx
#+begin_src elisp
(rx "z:\\home\\vrika\\documents\\sm")
#+end_src

#+RESULTS: empty-sm-rx
: z:\\home\\vrika\\documents\\sm

#+begin_src elisp :noweb yes :noweb-ref empty-sm-window
(seq-filter (lambda (buf)
              (string-match-p
              <<empty-sm-rx>>
               (buffer-name buf)))
            (buffer-list))
#+end_src

#+NAME: concepts-rx
#+begin_src elisp
(rx "Concepts")
#+end_src

#+RESULTS: concepts-rx
: Concepts

#+begin_src elisp :noweb yes
(seq-filter (lambda (buf)
              (string-match-p
               <<concepts-rx>>
               (buffer-name buf)))
            (buffer-list))
#+end_src

Now we'll throw this together as a set of buffer rules:

** hooking sm-buffers
:PROPERTIES:
:CREATED:  [2020-11-20 Fri 10:39]
:ID:       c0a59157-a741-4824-b25e-4b8cab63a2d9
:END:

Currently the catch-all [[file:~/.doom.d/modules/desktop/exwm/+funcs.el::defun exwm/rename-buffer (][exwm/rename-buffer]] function captures the sm buffers on each update of the
=title-hook=. We'll cook up some rules to leave handling these buffers to another custom hooked function.

Currently the [[file:~/.local/share/applications/supermemo18.supermemo18.desktop::StartupWMClass=sm18.exe][StartupWMClass]] for sm18 is not propagating out to the actuall WM_CLASS as =sm18.exe=, possibly as a limitation of =wine-5.2= We'll have to clobber all ~Wine~ applications for now.

Excluding based on =class=. (this doesn't seem to do it though)
#+begin_src elisp :noweb yes :noweb-ref exwm-class-hook
(add-hook 'exwm-update-class-hook
          (defun my-exwm-update-class-hook ()
            (unless (or (string-prefix-p "Wine" exwm-class-name))
                        (string-prefix-p "Internet Explorer" exwm-class-name)
                        (string-prefix-p "sm18.exe" exwm-class-name)
                        ;; (string-prefix-p "SuperMemo" exwm-class-name)
                        ;; (string-prefix-p "Explorer" exwm-class-name))
              (exwm/rename-buffer))))
#+end_src

#+RESULTS:
| my-exwm-update-class-hook |

Exclusion based on =exwm-title=:
#+begin_src elisp :noweb yes :noweb-ref exwm-title-hook
(add-hook 'exwm-update-title-hook
          (defun my-exwm-update-title-hook ()
            (unless (or (string-prefix-p <<element-window-rx>> exwm-title)
                        (string-prefix-p <<knowledge-tree-rx>> exwm-title)
                        (string-prefix-p <<element-data-rx>> exwm-title)
                        (string-prefix-p <<concepts-rx>> exwm-title)
                        (string-prefix-p <<empty-sm-rx>> exwm-title)
                        ;; (string-prefix-p (rx "z:\\home\\vrika\\documents\\sm") exwm-title)
                        ;; The below may be necessary
                        ;; (string-prefix-p (rx (seq "Mousepad")) exwm-title))
                        (string-prefix-p "Internet Explorer" exwm-class-name)
                        (string-prefix-p "Choose Collection" exwm-class-name)
                        (string-prefix-p "RAIL" exwm-class-name)
                        (string-prefix-p "sm18.exe" exwm-class-name)
                        (string-prefix-p "Wine" exwm-class-name))
              (exwm/rename-buffer))))
#+end_src

#+RESULTS:
| my-exwm-update-title-hook |

#+begin_src elisp :noweb yes :noweb-ref element-window-hook :results silent
(add-hook 'exwm-update-title-hook
          (defun sm-element-test-title-hook ()
            (when (string-match <<element-window-rx>> exwm-title)
              (exwm-workspace-rename-buffer "sm-element-window"))))
#+end_src

#+begin_src elisp :noweb yes :noweb-ref knowledge-tree-hook :results silent
(add-hook 'exwm-update-title-hook
          (defun sm-knowledge-tree-title-hook ()
            (when (string-match <<knowledge-tree-rx>> exwm-title)
              (exwm-workspace-rename-buffer "sm-knowledge-tree"))))
#+end_src

#+begin_src elisp :noweb yes :noweb-ref element-data-hook :results silent
(add-hook 'exwm-update-title-hook
          (defun sm-element-data-title-hook ()
            (when (string-match <<element-data-rx>> exwm-title)
              (exwm-workspace-rename-buffer "sm-element-data"))))
#+end_src

#+begin_src elisp :noweb yes :noweb-ref empty-sm-hook :results silent
(add-hook 'exwm-update-title-hook
          (defun sm-element-frame-title-hook ()
            (if (string-match (rx "z:\\home\\vrika\\documents\\sm") exwm-title)
              (exwm-workspace-rename-buffer "sm-frame"))))
#+end_src

#+begin_src elisp :noweb yes :noweb-ref empty-sm-hook2 :results silent
(add-hook 'exwm-update-title-hook
          (defun sm-frame-title-hook ()
            (if (string-match (rx "c:\\users\\dan\\documents\\sm") exwm-title)
              (exwm-workspace-rename-buffer "sm-frame"))))
#+end_src

Instead of having several seperate hooks we can define one function with several conditions:
Could I write a list for this section?

I think that I could write a macro for this

#+begin_src elisp :noweb yes :noweb-ref sm-window hooks
(add-hook 'exwm-update-title-hook
          (defun sm-element-frame-title-hook ()
            (when (string-match (rx "z:\\home\\vrika\\documents\\sm") exwm-title)
                (exwm-workspace-rename-buffer "sm-frame"))
            (when (string-match (rx bol "home" eol) exwm-title)
              (exwm-workspace-rename-buffer "sm-element-window"))
            (when (string-match (rx bol "neuron" eol) exwm-title)
              (exwm-workspace-rename-buffer "sm-knowledge-tree"))
            (when (string-match (rx (| (seq (or "Topic" "Element") space "#" (one-or-more digit) ":") (seq "Element data"))) exwm-title)
              (exwm-workspace-rename-buffer "sm-element-data"))
            (when (string-match (rx bol "Images") exwm-title)
              (exwm-workspace-rename-buffer "sm-images"))
            (when (string-match (rx bol "Repetition sorting criteria") exwm-title)
              (exwm-workspace-rename-buffer "sm-sorting"))
            (when (string-match (rx bol "Subset") exwm-title)
              (exwm-workspace-rename-buffer "Subset"))
            (when (string-match (rx bol "Repair Options") exwm-title)
              (exwm-workspace-rename-buffer "sm-repair-collection"))
            (when (string-match (rx bol "Analysis") exwm-title)
              (exwm-workspace-rename-buffer "sm-statistics-analysis"))
            (when (string-match (rx bol "Question") exwm-title)
              (exwm-workspace-rename-buffer "sm-question-window"))
            (when (string-match (rx bol "Modify Priorities") exwm-title)
              (exwm-workspace-rename-buffer "sm-modify-priority"))
            (when (string-match (rx bol "Element Priority") exwm-title)
              (exwm-workspace-rename-buffer "sm-priority"))
            (when (string-match (rx bol "Copying") exwm-title)
              (exwm-workspace-rename-buffer "sm-backup-copy"))
            (when (string-match (rx bol "Information") exwm-title)
              (exwm-workspace-rename-buffer "sm-info-window"))
            (when (string-match (rx bol "Options") exwm-title)
              (exwm-workspace-rename-buffer "sm-options-window"))
            (when (string-match (rx bol "Find elements") exwm-title)
              (exwm-workspace-rename-buffer "sm-element-finder"))
            ))
#+end_src

Then we add manually all the potential windows SM might spawn to =exwm-manage-configurations= so they can float over the main windows:

#+begin_src elisp :noweb yes :noweb-ref sm managed configurations
(add-to-list 'exwm-manage-configurations '((string-match (rx bol "Images") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Concepts") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Choices") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Template") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Subset") exwm-title) managed t floating nil))
(add-to-list 'exwm-manage-configurations '((string-match (rx "SuperMemo Commander") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Repetition sorting criteria") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Repair Options") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Analysis") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Question") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Element Priority") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Modify Priorities") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Element Priority") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Options") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Information") exwm-title) managed t floating t))
(add-to-list 'exwm-manage-configurations '((string-match (rx "Find elements") exwm-title) managed t floating t))

#+end_src

#+begin_src elisp :noweb yes :noweb-ref window assignments :results silent
(require 'subr-x)  ;; Because of when-let

(defvar exwm-workspace-window-assignments
  '(("sm-element-window" . 3)
    ("sm-knowledge-tree" . 3)
    ("sm-element-data" . 3))
  "An alist of window classes and which workspace to put them on.")

(add-hook 'exwm-manage-finish-hook
          (lambda ()
            (when-let ((target (cdr (assoc exwm-class-name exwm-workspace-window-assignments))))
              (exwm-workspace-move-window target))))
#+end_src

Was this for "New Concepts"?
#+begin_src elisp :noweb yes :noweb-ref concepts-hook :results silent
(add-to-list 'exwm-manage-configurations '((string= exwm-title <<concepts-rx>>) managed t floating t))

(add-hook 'exwm-update-title-hook
          (defun sm-element-concepts-title-hook ()
            (when (string-match <<concepts-rx>> exwm-title)
              (exwm-workspace-rename-buffer "concepts"))))

(add-to-list 'exwm-manage-configurations '((string= exwm-title (rx (seq "New Concept"))) managed t floating t))

(add-hook 'exwm-update-title-hook
          (defun sm-element-concepts1-title-hook ()
            (when (string-match (rx (seq "New Concept")) exwm-title)
              (exwm-workspace-rename-buffer "New Concept"))))

(add-hook 'exwm-update-title-hook
          (defun iexplorer-title-hook ()
            (when (string-match (rx (seq "Internet Explorer")) exwm-title)
              (exwm-workspace-rename-buffer "iexplorer"))))

(add-hook 'exwm-update-title-hook
          (defun sma-title-hook ()
            (when (string-match (rx (seq "Choose Collection")) exwm-title)
              (exwm-workspace-rename-buffer "supermemoassistant"))))

;; (add-to-list 'exwm-manage-configurations
;;    '((string= (buffer-name) "sm-element-window")
;;      (string= (buffer-name) "sm-knowledge-tree")
;;      (string= (buffer-name) "sm-element-data")
;;       workspace 3))

;; (add-to-list 'exwm-manage-configurations
;;    '((string= (buffer-name) "sm-element-window")
;;      workspace 3))

(add-to-list 'exwm-manage-configurations
   '((string= exwm-instance-name "sm18.exe")
     workspace 3 managed t floating nil))

(add-to-list 'exwm-manage-configurations
   '((string= exwm-instance-name "SuperMemo 18")
     workspace 3 managed t floating nil))
#+end_src

#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+sm-window-rules.el
;;; desktop/exwm/+sm-window-rules.el -*- lexical-binding: t; -*-
;; <<empty-sm-hook>>

;; <<element-window-hook>>

;; <<knowledge-tree-hook>>

;; <<element-data-hook>>

;; <<concepts-hook>>

<<sm-window hooks>>

<<sm managed configurations>>

<<dbc rules>>
#+end_src

** display-buffer-alist
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:31]
:ID:       6b6b8247-b27b-4771-bd30-74ec4653f123
:header-args: :noweb-ref buffer alist hooks
:END:
Once have these tested and working, theoretically as x-windows under EXWM are just emacs buffers, they could be controlled with the built-in ~display-buffer~ tooling via ~display-buffer-alist~:

#+begin_src elisp :tangle no :noweb no
;; (add-to-list 'display-buffer-alist
;;              `((,<<empty-sm>>
;;                 (display-buffer-no-window))
;;                (,<<tree-rx>>
;;                 (display-buffer-reuse-window display-buffer-in-side-window)
;;                 (side . left)
;;                 (slot . 0)
;;                 (window-width . 0.22))
;;                (,<<element-data-rx>>
;;                 (display-buffer-at-bottom)
;;                 ;; (side . bottom)
;;                 ;; (slot . 0)
;;                 (window-height . 0.19))))
#+end_src

However, this doesn't work as expected an we have to wrap this rules in an exwm hook:
#+begin_src elisp :noweb yes :results silent
(add-hook 'exwm-manage-finish-hook
          (lambda ()
            (when (string-match-p "sm-frame" (buffer-name))
              (display-buffer
               (get-buffer-create "sm-frame")
               '((display-buffer-no-window)
                 ;; (allow-no-window . t)
                 )))
            (when (string-match-p "sm-element-window" (buffer-name))
              (display-buffer
               (get-buffer-create "sm-element-window")
               '((display-buffer-same-window))))
            (when (string-match-p "sm-knowledge-tree" (buffer-name))
              (display-buffer
               (get-buffer-create "sm-knowledge-tree")
               '((display-buffer-in-side-window)
                 ;; (inhibit-same-window . t)
                 (side . left)
                 (slot . 0)
                 (window-width . 0.21))))
            (when (string-match-p "sm-element-data" (buffer-name))
              (progn (exwm-layout-hide-mode-line)
                     (display-buffer
                      (get-buffer-create "sm-element-data")
                      '((display-buffer-in-side-window)
                        ;; (inhibit-same-window . t)
                        (side . bottom)
                        (slot . 1)
                        (window-height . 0.21)))))
            ))
#+end_src

#+begin_src elisp :noweb yes :results silent
  ;; (add-hook 'exwm-manage-finish-hook
  ;;           (lambda ()
  ;;             (when (string-match-p "sm-knowledge-tree" (buffer-name))
  ;;               (display-buffer-in-side-window (current-buffer)
  ;;                                              '((side . left)
  ;;                                                (slot . 0)
  ;;                                                (window-height . 0.16))))))
#+end_src

#+begin_src elisp :noweb yes :results silent
  ;; (add-hook 'exwm-manage-finish-hook
  ;;           (lambda ()
  ;;             (when (string-match-p "sm-element-data" (buffer-name))
  ;;               (display-buffer-in-side-window (current-buffer)
  ;;                                              '((side . bottom)
  ;;                                                (slot . 0)
  ;;                                                (window-height . 0.20))))))
#+end_src

#+begin_src elisp :tangle no :noweb yes :results silent
;; (remove-hook 'exwm-manage-finish-hook
;;           (lambda ()
;;             (when (string-match-p
;;                    <<element-data-rx>>
;;                    (buffer-name))
;;               (display-buffer-in-side-window (current-buffer)
;;                                              '((side . bottom)
;;                                                (slot . 0)
;;                                                (window-width . 0.23))))))
#+end_src

** dbc
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:31]
:ID:       bbd768ea-8399-40f1-a256-9af276fa9796
:END:

An alternative would be to use the [[https://gitlab.com/matsievskiysv/display-buffer-control][dbc]] package, a wrapper around ~display-buffer~ which makes configuration a little easier:

*** Element window window
:PROPERTIES:
:CREATED:  [2020-11-30 Mon 17:08]
:ID:       aeb600d7-3e63-46d0-a536-656885c5d139
:END:

#+begin_src elisp :noweb yes :results silent :noweb-ref element window rule
(dbc-add-ruleset "expose" '((display-buffer-reuse-window display-buffer-pop-up-frame) .
                            ((reusable-frames . 0))))

(dbc-add-rule "expose" "main" :newname "sm-element-window")
#+end_src

*** Knowledge tree window
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:36]
:ID:       f413ac69-a518-4fae-9228-6c298771a214
:END:

dbc ruleset for the knowledge tree

#+begin_src elisp :results silent :noweb-ref left rule
(dbc-add-ruleset "left" '((display-buffer-reuse-window display-buffer-in-side-window) .
                          ((side . left) (slot . -1) (window-width . 0.22))) 5)

(dbc-add-rule "left" "tree" :newname "sm-knowledge-tree")
#+end_src

Remove the rule for testing purposes
#+begin_src elisp :noweb yes :results silent
(dbc-remove-rule "left" "tree")
#+end_src

#+begin_src elisp :noweb yes
(dbc-add-rule "bottom" "bar" :newname <<lower-bar-rx>>)
#+end_src

*** Element data window
:PROPERTIES:
:CREATED:  [2020-11-30 Mon 17:08]
:ID:       e9c424ac-738f-4688-ad9c-8cdbbfd5d568
:END:

#+begin_src elisp :results silent :noweb-ref element tray rule
(dbc-add-ruleset "bottom" '((display-buffer-reuse-window display-buffer-in-side-window) .
                            ((side . bottom) (slot . 0) (window-height . 0.23))) 10)

(dbc-add-rule "bottom" "tray" :newname "sm-element-data")
#+end_src

#+begin_src elisp :results silent
(dbc-remove-ruleset "bottom")
#+end_src

#+begin_src elisp
(dbc-remove-rule "bottom" "tray")
#+end_src

*** Empty frame
:PROPERTIES:
:CREATED:  [2020-11-30 Mon 17:08]
:ID:       549b81e7-1902-4bd5-bb1c-4a82268a6a71
:END:

There seems to be somekind of empty frame that Supermemo produces. When inside this frame/window it can cause all the other SM related windows to freak out and rapidly cylce through them hanging the system temporarily.

#+begin_src elisp :noweb yes :results silent
;; (dbc-add-rule "left" "test" :newname (rx (seq "Mousepad")))
(dbc-add-rule "left" "test123" :newname "Mousepad")
#+end_src

#+begin_src elisp :results silent
(dbc-add-ruleset "supress" '((display-buffer-no-window)) 1)
#+end_src

#+begin_src elisp :noweb yes
(dbc-add-rule "supress" "empty" :newname <<empty-sm>>)
#+end_src

#+begin_src elisp :noweb yes
(use-package! dbc
  :after exwm
  :config
  ;; (dbc-remove-ruleset "expose" '((display-buffer-reuse-window display-buffer-pop-up-frame) .
  ;;                             ((reusable-frames . 0))))

  (dbc-add-ruleset "top" dbc-same-window-action 100)

  (dbc-add-ruleset "left" '((display-buffer-reuse-window display-buffer-in-side-window) .
                            ((side . left) (slot . -1) (window-width . 0.22))) 5)


  (dbc-add-ruleset "bottom" '((display-buffer-reuse-window display-buffer-in-side-window) .
                              ((side . bottom) (slot . 0) (window-height . 0.23))) 10)

  (add-hook 'exwm-manage-finish-hook
            (lambda ()
              (dbc-add-rule "top" "main" :newname "sm-element-window")))

  (add-hook 'exwm-manage-finish-hook
            (lambda ()
              (dbc-add-rule "left" "tree" :newname "sm-knowledge-tree")))

  (add-hook 'exwm-manage-finish-hook
            (lambda ()
              (dbc-add-rule "bottom" "tray" :newname "sm-element-data")))
  )
#+end_src

** Final buffer tangle
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:36]
:ID:       bef0674e-a594-442b-a959-c7005f24a4d4
:header-args: :noweb-ref dbc rules
:END:
#+begin_src elisp :noweb yes
;; (use-package! dbc
;; :config

<<exwm-class-hook>>

<<exwm-title-hook>>

<<buffer alist hooks>>
;; <<element window rule>>

;; <<left rule>>

;; <<element tray rule>>

;; )
#+end_src

* sm-core
:PROPERTIES:
:CREATED:  [2020-11-20 Fri 15:55]
:ID:       b98cd336-e48d-4a92-9998-bd88a20b1d12
:END:
Here we'll define the core keypress events we'd want to send to Supermemo.

simulation keys
#+begin_src elisp
(setq exwm-input-simulation-keys
      '(
        ;; ([?\C-b] . [left])
        ;; ([?\C-f] . [right])
        ;; ([?\C-p] . [up])
        ;; ([?\C-n] . [down])
        ;; ([?\C-a] . [home])
        ;; ([?\C-e] . [end])
        ;; ([?\M-v] . [prior])
        ([?\C-c] . [left])
        ([?\C-v] . [?\C-v])
        ([?\C-j] . [?\C-j])
        ([?\M-x] . [?\M-x])))
#+end_src

#+RESULTS:
: (([3] . [left]) ([22] . [22]) ([10] . [10]) ([134217848] . [134217848]))

** Advanced functions with AHK
:PROPERTIES:
:CREATED:  [2021-04-20 Tue 15:53]
:ID:       ace7c6f8-9504-4596-a159-a4436e5d1147
:END:

A little function to assist with executing ahk.exe's
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;; desktop/exwm/+exwm-sm-core.el -*- lexical-binding: t; -*-

;; (defun ahk-run (ahk)
;;     "pass an AHK .exe on to start-process-shell-command in a temp buffer"
;;     (setq sm-current-buffer (current-buffer))
;;       (progn
;;         (when (posframe-workable-p)
;;           (posframe-show "*ahk-run*"
;;                          :height 30
;;                          :width 30
;;                          :internal-border-width 2
;;                          :internal-border-width 2
;;                          :internal-border-width "purple"))
;;         (switch-to-buffer-other-frame "*ahk-run*")
;;         ;; (switch-to-buffer "*ahk-run*"))
;;         (let ((process (start-process-shell-command
;;                         "ahk-run"
;;                         "*ahk-run*"
;;                         "env WINEPREFIX='/home/volk/.local/share/wineprefixes/supermemo18'"
;;                         "wine" ahk)))
;;           (set-process-sentinel process 'ahk-run-sentinel))))

;; (defun ahk-run-sentinel (p e)
;; "quit the popup buffer after successful run of shell process"
;;  (when (= 0 (process-exit-status p))
;;    (posframe-hide "*ahk-run*")
;;    (switch-to-buffer sm-current-buffer)))


  ;; (exwm-input-release-keyboard)
#+end_src

#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el

(defun ahk-run (ahk)
  (start-process-shell-command
  "ahk-run"
  "*ahk-run*"
  (format "%s %s" "wineconsole" ahk)))
#+end_src

** Basic movement functions
:PROPERTIES:
:CREATED:  [2021-04-20 Tue 15:53]
:ID:       08f4795c-fb26-4b13-8a48-99a03d67cb53
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
(require 'exwm)
(require 'exwm-input)

;;; Basic navigation
;;;###autoload
(defun exwm-sm-core-up ()
  "Move up."
  (interactive)
  (exwm-input--fake-key 'up))

;;;###autoload
(defun exwm-sm-core-down ()
  "Move down."
  (interactive)
  (exwm-input--fake-key 'down))

;;;###autoload
(defun exwm-sm-core-left ()
  "Move down."
  (interactive)
  (exwm-input--fake-key 'left))

;;;###autoload
(defun exwm-sm-core-right ()
  "Move down."
  (interactive)
  (exwm-input--fake-key 'right))

;;;###autoload
(defun exwm-sm-core-goto-parent ()
  "Go to parent of current element"
  (interactive)
  (ahk-run "~/.scripts/ahk/goto-parent.exe"))

;;;###autoload
(defun exwm-sm-core-goto-child ()
  "Go to the first child of current element"
  (interactive)
  (ahk-run "~/.scripts/ahk/goto-child.exe"))

;; ;;;###autoload
;; (defun exwm-sm-core-forward ()
;;   "Go forward element"
;;   (interactive)
;;   (let ((exwm-input-line-mode-passthrough t))
;;     (ahk-run "~/.scripts/ahk/forward.exe")))


;;;###autoload
(defun exwm-sm-core-forward ()
  "Go forward element"
  (interactive)
    (ahk-run "~/.scripts/ahk/forward.exe"))

;;;###autoload
(defun exwm-sm-core-back ()
  "Go back element"
  (interactive)
    (ahk-run "~/.scripts/ahk/forward.exe"))
;; ;;;###autoload
;; (defun exwm-sm-core-back ()
;;   "Go back element"
;;   (interactive)
;;   (async-shell-command (format "%s %s" "wine cmd.exe /C" "~/.scripts/ahk/back.exe")))

(add-to-list
 'display-buffer-alist
  '("\\*Async Shell Command\\*"
     (display-buffer-no-window)
     (allow-no-window . t)))

(add-to-list
 'display-buffer-alist
  '("\\*EXWM\\*"
     (display-buffer-no-window)
     (allow-no-window . t)))
#+end_src

** Find and search operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:22]
:ID:       daa8e452-7e02-4b2f-a081-45f97eeaeedf
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;; Find/Search

;;;###autoload
(defun exwm-sm-core-find ()
  "Find general."
  (interactive)
  (ahk-run "~/.scripts/ahk/find.exe"))

;;;###autoload
(defun exwm-sm-core-search ()
  "Search for texts containing a given string."
  (interactive)
  (ahk-run "~/.scripts/ahk/search.exe"))

;;;###autoload
(defun exwm-sm-core-find-elements ()
  "Find elements."
  (interactive)
  (ahk-run "~/.scripts/ahk/find-elements.exe"))

;;;###autoload
(defun exwm-sm-core-search-phrase ()
  "Search currently selected phrase."
  (interactive)
  (ahk-run "~/.scripts/ahk/search-phrase.exe"))

;;;###autoload
(defun exwm-sm-core-find-next ()
  "Find next."
  (interactive)
  (exwm-input--fake-key ?\C-g))

;;;###autoload
(defun exwm-sm-core-find-previous ()
  "Find previous."
  (interactive)
  (exwm-input--fake-key ?\C-\S-g))

#+end_src

** Editing
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:25]
:ID:       1d576d49-e772-40ec-a57c-2160d44fd808
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;; Editing
;;;###autoload

(defun exwm-sm-core-paste ()
  "Paste from clipboard."
   (interactive)
   (ahk-run "~/.scripts/ahk/paste.exe"))

(defun exwm-sm-core-paste-html ()
  "Paste html from clipboard."
   (interactive)
   (ahk-run "~/.scripts/ahk/paste-html.exe"))

;;;###autoload
(defun exwm-sm-core-copy ()
  "Copy to clipboard."
   (interactive)
   (ahk-run "~/.scripts/ahk/copy-clipboard.exe"))

;;;###autoload
(defun exwm-sm-core-cut ()
  "Cut text."
   (interactive)
   (ahk-run "~/.scripts/ahk/cut.exe"))

;;;###autoload
(defun exwm-sm-core-delete ()
  "Delete text."
   (interactive)
   (ahk-run "~/.scripts/ahk/delete.exe"))

;;;###autoload
(defun exwm-sm-core-undo ()
  "Undo."
   (interactive)
   (ahk-run "~/.scripts/ahk/undo.exe"))

;;;###autoload
(defun exwm-sm-core-redo ()
  "Redo."
   (interactive)
   (ahk-run "~/.scripts/ahk/redo.exe"))

;;;###autoload
(defun exwm-sm-core-forward-word ()
  "Move word forward."
  (interactive)
  (exwm-input--fake-key 'C-right))

;;;###autoload
(defun exwm-sm-core-back-word ()
  "Move word backward."
  (interactive)
  (exwm-input--fake-key 'C-left))

;;;###autoload
(defun exwm-sm-core-bold ()
  "Embolden selected text"
  (interactive)
  (ahk-run "~/.scripts/ahk/bold-font.exe"))

;;;###autoload
(defun exwm-sm-core-italic ()
  "Italicise selected text."
  (interactive)
  (ahk-run "~/.scripts/ahk/italic-font.exe"))

;;;###autoload
(defun exwm-sm-decrease-font ()
  "Decrease selected font size"
  (interactive)
  (ahk-run "~/.scripts/ahk/decrease-font-size.exe"))

;;;###autoload
(defun exwm-sm-increase-font ()
  "Increase selected font size"
  (interactive)
  (ahk-run "~/.scripts/ahk/increase-font-size.exe"))

;;;###autoload
(defun exwm-sm-core-edit-question ()
  "Edit the question component"
  (interactive)
  (ahk-run "~/.scripts/ahk/edit-question.exe"))

;;;###autoload
(defun exwm-sm-core-edit-answer ()
  "Edit the first answer"
  (interactive)
  (ahk-run "~/.scripts/ahk/edit-answer.exe"))

;;;###autoload
(defun exwm-sm-core-edit-file ()
  "Edit .HTM file"
  (interactive)
  (ahk-run "~/.scripts/ahk/edit-file.exe"))

;;;###autoload
(defun exwm-sm-core-edit-next-component ()
  "Edit the next component in element window"
  (interactive)
  (ahk-run "~/.scripts/ahk/edit-next-component.exe"))

;;;###autoload
(defun exwm-sm-core-edit-switch-mode ()
  "Cycle presentation -> editing -> dragging modes"
  (interactive)
  (ahk-run "~/.scripts/ahk/edit-next-component.exe"))

#+end_src

** Selection
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:45]
:ID:       468001dc-ec7e-454c-aef6-5559c240f146
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;;; Selection
;;;###autoload
(defun exwm-sm-core-forward-word-select ()
  "Move word forward and select."
  (interactive)
  (exwm-input--fake-key 'C-S-right))

;;;###autoload
(defun exwm-sm-core-back-word-select ()
  "Move word backward and select."
  (interactive)
  (exwm-input--fake-key 'C-S-left))

;;;###autoload
(defun exwm-sm-core-select-all ()
  "Select whole page."
  (interactive)
  (exwm-input--fake-key ?\C-a))

#+end_src

** Element functions
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:45]
:ID:       6f4b7ba2-8c14-4a7f-a03a-06dd3f193523
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;;###autoload
(defun exwm-sm-core-elements-dismiss-element ()
"Dismiss element while in element window"
  (interactive)
  (ahk-run "~/.scripts/ahk/element-dismiss-element.exe"))

;;;###autoload
(defun exwm-sm-core-contents-dismiss-element ()
"Dismiss element while in contents window"
  (interactive)
  (ahk-run "~/.scripts/ahk/contents-dismiss-element.exe"))

;;;###autoload
(defun exwm-sm-core-delete-element ()
  "Delete/dismiss currently displayed element"
  (interactive)
  (ahk-run "~/.scripts/ahk/dismiss-delete.exe"))

;;;###autoload
(defun exwm-sm-core-element-params ()
  "Bring up apply template menu"
  (interactive)
  (ahk-run "~/.scripts/ahk/element-params.exe"))

;;;###autoload
(defun exwm-sm-core-insert-image ()
  "Insert image into component."
  (interactive)
  (ahk-run "~/.scripts/ahk/insert-image.exe"))

;;;###autoload
(defun exwm-sm-core-insert-splitline ()
  "Insert image into component."
  (interactive)
  (ahk-run "~/.scripts/ahk/insert-splitline.exe"))

;;;###autoload
(defun exwm-sm-core-cycle-image-stretch ()
  "Cycle stretch of image component."
  (interactive)
  (ahk-run "~/.scripts/ahk/cycle-image-stretch.exe"))

;;;###autoload
(defun exwm-sm-core-apply-template ()
  "Bring up apply template menu"
  (interactive)
  (ahk-run "~/.scripts/ahk/element-apply-template.exe"))

;;;###autoload
(defun exwm-sm-core-item-picture ()
  "Apply Item Picture template to element"
  (interactive)
  (ahk-run "~/.scripts/ahk/item-picture.exe"))

;;;###autoload
(defun exwm-sm-core-import-component ()
  "Import component in element window"
  (interactive)
  (ahk-run "~/.scripts/ahk/import-component.exe"))

;;;###autoload
(defun exwm-sm-core-reorder-components ()
  "Bring up reorder components menu"
  (interactive)
  (ahk-run "~/.scripts/ahk/reorder-components.exe"))

;;;###autoload
(defun exwm-sm-core-reference-label ()
  "Bring up references menu"
  (interactive)
  (ahk-run "~/.scripts/ahk/reference-label-menu.exe"))

;;;###autoload
(defun exwm-sm-core-test-rep-cycle ()
  "Emulate learning mode to test element/components"
  (interactive)
  (ahk-run "~/.scripts/ahk/test-rep-cycle.exe"))

;;;###autoload
(defun exwm-sm-core-tile-components ()
  "Go into tiling menu for component tiling"
  (interactive)
  (ahk-run "~/.scripts/ahk/tile-components.exe"))

(defun exwm-sm-core-ancestors ()
"Bring up element ancestors menu"
  (interactive)
  (ahk-run "~/.scripts/ahk/ancestors.exe"))

(defun exwm-sm-core-create-hyperlink ()
"Create hyperlink over selected text"
  (interactive)
  (ahk-run "~/.scripts/ahk/create-hyperlink.exe"))

(defun exwm-sm-core-get-filepath ()
"Get the file path of the current element"
  (interactive)
  (ahk-run "~/.scripts/ahk/get-filepath.exe"))

(let ((unix-path (replace-regexp-in-string "\n\\'" ""
                  (shell-command-to-string
                   (shell-quote-argument "winepath -u $(xclip -sel clip -o)"))))))
(shell-command "xclip -sel clip -o")

(subst-char-in-string ?\\ ?\ (gui--selection-value-internal 'CLIPBOARD))

z:\home\vrika\documents\sm\neuron\elements\1\26\15\16953.HTM
(defun exwm-input--on-ButtonPress-line-mode (buffer button-event)
  "Handle button events in line mode.
BUFFER is the `exwm-mode' buffer the event was generated
on. BUTTON-EVENT is the X event converted into an Emacs event.

The return value is used as event_mode to release the original
button event."
  (with-current-buffer buffer
    (let ((read-event (exwm-input--mimic-read-event button-event)))
      (exwm--log "%s" read-event)
      (if (and read-event
               (exwm-input--event-passthrough-p read-event))
          ;; The event should be forwarded to emacs
          (progn
            (exwm-input--cache-event read-event)
            (exwm-input--unread-event button-event)

            xcb:Allow:ReplayPointer)
        ;; The event should be replayed
        xcb:Allow:ReplayPointer))))

#+end_src

** Learn operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 12:46]
:ID:       88b59ad6-d7ea-4e85-b828-c147fa4bb902
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;;; Learn operations

;;;###autoload
(defun exwm-sm-core-learn ()
  "Start learning"
  (interactive)
  (ahk-run "~/.scripts/ahk/learn.exe"))

;;;###autoload
(defun exwm-sm-core-replay ()
  "Replay component"
  (interactive)
  (ahk-run "~/.scripts/ahk/replay.exe"))

;;;###autoload
(defun exwm-sm-core-cloze ()
  "Extract selected text"
  (interactive)
  (ahk-run "~/.scripts/ahk/cloze.exe"))

;;;###autoload
(defun exwm-sm-core-extract ()
  "Extract selected text"
  (interactive)
  (ahk-run "~/.scripts/ahk/extract.exe"))

;;;###autoload
(defun exwm-sm-core-schedule-extract ()
  "Extract and schedule for a later time"
  (interactive)
  (ahk-run "~/.scripts/ahk/schedule-extract.exe"))

;;;###autoload
(defun exwm-sm-core-prioritize ()
  "Modify priority of current element"
  (interactive)
  (ahk-run "~/.scripts/ahk/priority.exe"))

;;;###autoload
(defun exwm-sm-core-reschedule ()
  "Learning: Reschedule to another day"
  (interactive)
  (ahk-run "~/.scripts/ahk/reschedule.exe"))

;;;###autoload
(defun exwm-sm-core-postpone ()
  "Schedule review later today"
  (interactive)
  (ahk-run "~/.scripts/ahk/later-today.exe"))

;;;###autoload
(defun exwm-sm-core-element-dismiss-element ()
  "Dismiss element from element window"
  (interactive)
  (ahk-run "~/.scripts/ahk/element-dismiss-element.exe"))

;;;###autoload
(defun exwm-sm-core-remember ()
  "Introduce element into learning que"
  (interactive)
  (ahk-run "~/.scripts/ahk/remember.exe"))

;;;###autoload
(defun exwm-sm-core-execute-rep ()
  "Execute a mid-interval rep at later date"
  (interactive)
  (ahk-run "~/.scripts/ahk/execute-rep.exe"))

;;;###autoload
(defun exwm-sm-core-cancel-grade ()
  "Undo grading on element"
  (interactive)
  (ahk-run "~/.scripts/ahk/cancel-grade.exe"))

;;;###autoload
(defun exwm-sm-core-branch-learning ()
  "Subset review of a selection of a branch in contents"
  (interactive)
  (ahk-run "~/.scripts/ahk/branch-learning.exe"))

;;;###autoload
(defun exwm-sm-core-random-learning ()
  "Random learning"
  (interactive)
  (ahk-run "~/.scripts/ahk/random-learning.exe"))

;;;###autoload
(defun exwm-sm-core-random-test ()
  "Random test"
  (interactive)
  (ahk-run "~/.scripts/ahk/random-test.exe"))

;;;###autoload
(defun exwm-sm-core-set-read-point ()
  "Set the read-point"
  (interactive)
  (ahk-run "~/.scripts/ahk/set-read-point.exe"))

;;;###autoload
(defun exwm-sm-core-mercy ()
  "Activate mercy"
  (interactive)
  (ahk-run "~/.scripts/ahk/mercy.exe"))

;;;###autoload
(defun exwm-sm-core-neural ()
  "Go neural"
  (interactive)
  (ahk-run "~/.scripts/ahk/go-neural.exe"))

;;;###autoload
(defun exwm-sm-core-sorting-criteria ()
  "Open sorting criteria window"
  (interactive)
  (ahk-run "~/.scripts/ahk/sorting-criteria.exe"))

;;;###autoload
(defun exwm-sm-core-subset-learning ()
  "Subset learning"
  (interactive)
  (ahk-run "~/.scripts/ahk/subset-learning.exe"))

#+end_src

** Knowledge tree operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 15:27]
:ID:       a34b8b01-dc40-4ee0-be9c-fdc44715ba48
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;;###autoload
(defun exwm-sm-convert-to-concept ()
  "Convert element to concept"
  (interactive)
  (ahk-run "~/.scripts/ahk/convert-to-concept.exe"))

;;;###autoload
(defun exwm-sm-new-article ()
  "Create new article"
  (interactive)
  (ahk-run "~/.scripts/ahk/new-article.exe"))

#+end_src

** Misc operations
:PROPERTIES:
:CREATED:  [2021-04-21 Wed 13:48]
:ID:       795a6453-5dfc-42e4-b2cf-735fdd224d0c
:END:
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
;;; Misc

;;;###autoload
(defun exwm-sm-core-sm-commander ()
  "Summon the SuperMemo Commander"
  (interactive)
  (ahk-run "~/.scripts/ahk/sm-commander.exe"))

;;;###autoload
(defun exwm-sm-core-sm-repair-collection ()
  "Bring up the collection repair menu"
  (interactive)
  (ahk-run "~/.scripts/ahk/repair-collection.exe"))

;;;###autoload
(defun exwm-sm-core-restore-layout ()
  "Restore the default window layout"
  (interactive)
  (ahk-run "~/.scripts/ahk/restore-layout.exe"))

;;;###autoload
(defun exwm-sm-core-statistics-analysis ()
  "Open stats window"
  (interactive)
  (ahk-run "~/.scripts/ahk/statistics-analysis.exe"))

;;;###autoload
(defun exwm-sm-core-open-file ()
  "Open file."
  (interactive)
  (exwm-input--fake-key ?\C-o))

;;;###autoload
(defun exwm-sm-core-quit ()
  "Quit sm."
  (interactive)
  (exwm-input--fake-key ?\C-q))

(provide '+exwm-sm-core)
#+end_src
** TODO Try get ~input-fake-key~ working with Wine
:PROPERTIES:
:CREATED:  [2020-12-08 Tue 15:05]
:ID:       733fbf64-129d-4b63-8b92-8fcc569c5627
:END:
Testing some elisp functions to convert Windows paths from Wine to Linux
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
(defun my-translate-winpath ()
  "change :C\win\path to 'nix /path/path"
  (let ((path (current-kill 0 'do-not-move)))
    (shell-command-to-string (format "~/.scripts/winpath.sh %s" path))))

(defun my-translate-winpath ()
  "change :C\win\path to 'nix /path/path"
  (let ((path (current-kill 0 'do-not-move)))
    (my-translate-path)))

(defun my-translate-winpath ()
  (interactive)
  (let* ((path (s-chop-prefix "z:" (current-kill 0 'do-not-move)))
         (nixpath (s-replace "\\" "/" path))
         (path1 (s-replace "documents" "Documents" nixpath)))
    (s-replace "sm" "SM" path1)))
#+end_src

Let's test this with Xdotool. It works, but isn't reliable.
#+begin_src elisp :tangle no
(defun exwm-sm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
(progn)
(my-translate-winpath)
;; (sit-for 3)
(message sm-path-nix))

(defun exwm-sm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
  (shell-command "sh ~/.scripts/xdotool/get_element_path.sh"))
  (shell-command "sh ~/.scripts/xdotool/get_element_path.sh"))

(defun exwm-sm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
(progn
  (shell-command "sh ~/.scripts/xdotool/get_element_path.sh")
  (gui--selection-value-internal 'CLIPBOARD)))

(defun exwm-sm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
  (shell-command "sh ~/.scripts/xdotool/get_element_path.sh")
(lambda ()
)
  (setq sm-path (gui--selection-value-internal 'CLIPBOARD)))
  ;; (shell-command "sh ~/.scripts/xdotool/get_element_path.sh"))
#+end_src

Testing with EXWM functionality (elisp only).
The big issue here is that control keys are not passed on to the Wine application. However, they are when using ~exwm-input-send-next-key~.
#+begin_src elisp :tangle no
(defun exwm-sm-core-test()
  "test"
  (interactive)
  ;; (exwm--log)
  ;; (let ((exwm-input-line-mode-passthrough t))
         ;; (key "?/C-v"))
         ;; (key (read-key "22")))
    (exwm-input--fake-key ("?/C-s-o")))

(exwm-input-set-key (kbd "<f9>") #'exwm-sm-core-test)


;;;###autoload
(defun exwm-sm-core-test ()
  "Move down."
  (interactive)
  (let ((exwm-input-line-mode-passthrough t))
    (exwm-input--fake-key 'left)))
#+end_src

#+RESULTS:

Try and get the right key code
#+begin_src elisp :tangle no
;; (read-key)
(vector "v")
#+end_src

#+RESULTS:
: ["? C-v"]

Trying the same but with a string.
#+begin_src elisp :tangle no
(defun my-exwm-send-string (string)
  "Send STRING to `exwm-mode' buffer or just insert it."
  (if (eq major-mode 'exwm-mode)
      (mapc #'exwm-input--fake-key (string-to-list string))
    (insert string)))

(defun exwm-sm-core-string-test ()
  (interactive)
  ;; (let ((exwm-input-line-mode-passthrough t))
    ;; (my-exwm-send-string [#o26])))
  (my-exwm-send-string [94 3]))

;; (term-send-raw-string "l")

;; (read-key-sequence-vector)

(exwm-input-set-key (kbd "<f9>") #'exwm-sm-core-string-test)
;; ###autoload
;; (defun exwm-sm-core-test ()
;;   "Send string to a given exwm buffer"
;;   (interactive)
;;   (my-exwm-send-string "sm-get-path ")
;;   (find-file (my-translate-winpath)))
#+end_src

#+RESULTS:

Try with this
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-core.el
(cl-defun exwm-input-send-sim-key (key)
  "Fake a key event according to the last input key sequence."
  (interactive)
  (exwm--log)
  (unless (derived-mode-p 'exwm-mode)
    (cl-return-from exwm-input-send-simulation-key))
  (let ((keys (gethash (this-single-command-keys)
                       exwm-input--simulation-keys)))
    (dolist (key keys)
      (exwm-input--fake-key key))))
#+end_src

#+begin_src elisp :tangle no
(cl-defun my-exwm-input-send-next-key (keys)
  "Send next key to client window.

EXWM will prompt for the key to send.  This command can be prefixed to send
multiple keys.  If END-KEY is non-nil, stop sending keys if it's pressed."
  (interactive "p")
  (exwm--log)
  (unless (derived-mode-p 'exwm-mode)
    (cl-return-from my-exwm-input-send-next-key))
  (let (key keys)
      ;; Skip events not from keyboard
      (let ((exwm-input-line-mode-passthrough t))
            ;; (setq key (read-key (format (key-description keys))
        (setq key (key-description "?\C-v")))
      (setq keys (vconcat keys (vector key)))
      (exwm-input--fake-key key)))
#+end_src

#+RESULTS:
: my-exwm-input-send-next-key

#+begin_src elisp :tangle no
(defun exwm-sm-core-test()
  "test"
  (interactive)
  (exwm/enter-char-mode)
  (exwm-input--fake-key ?\C-v))

  ;; (exwm-input-release-keyboard)
;;; Find
;;;###autoload
(defun exwm-sm-core-find ()
  "Find."
  (interactive)
  (exwm-input--fake-key ?\C-f))

;;;###autoload
(defun exwm-sm-core-quick-find ()
  "Quick find."
  (interactive)
  (exwm-input--fake-key ?/))

;;;###autoload
(defun exwm-sm-core-find-next ()
  "Find next."
  (interactive)
  (exwm-input--fake-key ?\C-g))

;;;###autoload
(defun exwm-sm-core-find-previous ()
  "Find previous."
  (interactive)
  (exwm-input--fake-key ?\C-\S-g))


;;;###autoload
(defun exwm-sm-core-test()
  "Find previous."
  (interactive)
  (exwm-input--fake-key ?\-g))

;;; Editing
;; ;;;###autoload
(defun exwm-sm-core-test ()
  "Copy text."
  (interactive)
  (exwm-input--invoke--m))
(exwm-input-invoke-factory "m")

;; (defun exwm-sm-core-test ()
;;   "Copy text."
;;   (interactive)
;;   (with-current-buffer (window-buffer)
;;     (fhd/exwm-input-char-mode)
;;     (exwm-input--invoke--m)))

;; (exwm-input--fake-key ?\C-v)))

;; (defun invoke-ctl-v-map ()
;;   (interactive)
;;   (exwm-input--cache-event ?\C-v t)
;;   (exwm-input--unread-event ?\C-v))

;; (defun exwm-sm-core-paste ()
;;   "Paste text."
;;   (interactive)
;;   (exwm-input-send-next-key (exwm-input--fake-key ?\C-p)))

;; (defun exwm-sm-core-paste ()
;;   "Paste text."
;;   (interactive)
;;   (exwm-input-send-next-key 2 ?\C-p))

;;;###autoload
(defun exwm-sm-core-copy ()
  "Copy text."
  (interactive)
  (exwm-input--fake-key ?\C-c))

;;;###autoload
(defun exwm-sm-core-cut ()
  "Cut text."
  (interactive)
  (exwm-input--fake-key ?\C-x))

;;;###autoload
(defun exwm-sm-core-paste ()
  "Paste text."
  (interactive)
  (exwm-input--fake-key ?\C-v))

;;;###autoload
(defun exwm-sm-core-delete ()
  "Delete text."
  (interactive)
  (exwm-input--fake-key 'delete))

;;;###autoload
(defun exwm-sm-core-undo ()
  "Undo."
  (interactive)
  (exwm-input--fake-key ?\C-z))

;;;###autoload
(defun exwm-sm-core-redo ()
  "Redo."
  (interactive)
  (exwm-input--fake-key ?\C-\S-z))

;;;###autoload
(defun exwm-sm-core-redo-last ()
  "redo last undo (in html text editing)."
  (interactive)
  (exwm-input--fake-key ?\C-y))

;;;###autoload
(defun exwm-sm-core-forward-word ()
  "Move word forward."
  (interactive)
  (exwm-input--fake-key 'C-right))

;;;###autoload
(defun exwm-sm-core-back-word ()
  "Move word backward."
  (interactive)
  (exwm-input--fake-key 'C-left))

;;;###autoload
(defun exwm-sm-core-edit-answer ()
  "Edit the first answer"
  (interactive)
  (exwm-input--fake-key ?\a))

;;;###autoload
(defun exwm-sm-core-edit-texts ()
  "Edit texts"
  (interactive)
  (exwm-input--fake-key ?\e))

;;;###autoload
(defun exwm-sm-core-edit-question ()
  "Edit the first question"
  (interactive)
  (exwm-input--fake-key ?\q))

;;;###autoload
(defun exwm-sm-core-delete-element ()
  "Delete currently displayed element"
  (interactive)
  (exwm-input--fake-key 'delete))

;; ;;;###autoload
;; (defun exwm-sm-core-xxx ()
;;   "xxx"
;;   (interactive)
;;   (exwm-input--fake-key 'xxx))

;; ;;;###autoload
;; (defun exwm-sm-core-xxx ()
;;   "xxx"
;;   (interactive)
;;   (exwm-input--fake-key 'xxx))

;;;; Selection
;;;###autoload
(defun exwm-sm-core-forward-word-select ()
  "Move word forward and select."
  (interactive)
  (exwm-input--fake-key 'C-S-right))

;;;###autoload
(defun exwm-sm-core-back-word-select ()
  "Move word backward and select."
  (interactive)
  (exwm-input--fake-key 'C-S-left))

;;;###autoload
(defun exwm-sm-core-select-all ()
  "Select whole page."
  (interactive)
  (exwm-input--fake-key ?\C-a))

;;;; Learn operations

;;;###autoload
(defun exwm-sm-core-learn ()
  "Start learning"
  (interactive)
  (exwm-input--fake-key ?\C-l))

;;;###autoload
(defun exwm-sm-core-prioritize ()
  "Modify priority of current element"
  (interactive)
  (exwm-input--fake-key 'M-p))

;;;###autoload
(defun exwm-sm-core-reschedule ()
  "Learning: Reschedule to another day"
  (interactive)
  (exwm-input--fake-key ?\C-j))

;;;###autoload
(defun exwm-sm-core-postpone ()
  "Schedule review later today"
  (interactive)
  (exwm-input--fake-key ?\C-\S-j))

;; ;;;###autoload
;; (defun exwm-sm-core-xxx ()
;;   "xxx"
;;   (interactive)
;;   (exwm-input--fake-key 'xxx))

;;;###autoload
(defun exwm-sm-core-extract ()
  "Extract selected text"
  (interactive)
  (exwm-input--fake-key 'M-x))

;;;###autoload
(defun exwm-sm-core-neural ()
  "Go neural"
  (interactive)
  (exwm-input--fake-key 'C-f2))


;;; Misc
;;;###autoload
(defun exwm-sm-core-cancel ()
  "General cancel action."
  (interactive)
  ;; Needs to get user out of search bar, this is the only way i've found to do it
  (exwm-input--fake-key 'escape)
  (exwm-input--fake-key 'tab))

;;;###autoload
(defun exwm-sm-core-open-file ()
  "Open file."
  (interactive)
  (exwm-input--fake-key ?\C-o))

;;;###autoload
(defun exwm-sm-core-quit ()
  "Quit sm."
  (interactive)
  (exwm-input--fake-key ?\C-q))

(provide '+exwm-sm-core)
#+end_src

#+RESULTS:
: +exwm-sm-core

* sm-evil
:PROPERTIES:
:CREATED:  [2020-11-21 Sat 10:31]
:ID:       c792bb4f-4d32-4eaf-a7b4-aa521e5dfcde
:END:

#+begin_src elisp :noweb yes :tangle ~/.doom.d/modules/desktop/exwm/+exwm-sm-evil.el
;;; desktop/exwm/+exwm-sm-evil.el -*- lexical-binding: t; -*-

(require 'evil)
(require 'evil-core)
(require '+exwm-sm-core)

;; (defvar exwm-sm-evil-sm-class-name '("Excel" "excel.exe" "WineDesktop - Wine desktop" "explorer.exe" "Wine" "Wine desktop")
;;   "The class name use for detecting if a SM buffer is selected.")

(defvar exwm-sm-evil-sm-buffer-name '(sm-element-window)
  "The buffer name used for detecting if a SM buffer is selected.")

;;; State transitions
(defun exwm-sm-evil-normal ()
  "Pass every key directly to Emacs."
  (interactive)
  (setq-local exwm-input-line-mode-passthrough t)
  (evil-normal-state))

(defun exwm-sm-evil-insert ()
  "Pass every key to SM."
  (interactive)
  (setq-local exwm-input-line-mode-passthrough nil)
  (evil-insert-state))

(defun exwm-sm-evil-exit-visual ()
  "Exit visual state properly."
  (interactive)
  ;; Unmark any selection
  (exwm-sm-core-left)
  (exwm-sm-core-right)
  (exwm-sm-evil-normal))

(defun exwm-sm-evil-visual-change ()
  "Change text in visual mode."
  (interactive)
  (exwm-sm-core-cut)
  (exwm-sm-evil-insert))

;;; Keys
(defvar exwm-sm-evil-mode-map (make-sparse-keymap))

;; Bind normal
(define-key exwm-sm-evil-mode-map [remap evil-exit-visual-state] 'exwm-sm-evil-exit-visual)
(define-key exwm-sm-evil-mode-map [remap evil-normal-state] 'exwm-sm-evil-normal)
(define-key exwm-sm-evil-mode-map [remap evil-force-normal-state] 'exwm-sm-evil-normal)
;; Bind insert
(define-key exwm-sm-evil-mode-map [remap evil-insert-state] 'exwm-sm-evil-insert)
(define-key exwm-sm-evil-mode-map [remap evil-insert] 'exwm-sm-evil-insert)
(define-key exwm-sm-evil-mode-map [remap evil-substitute] 'exwm-sm-evil-insert)
(define-key exwm-sm-evil-mode-map [remap evil-append] 'exwm-sm-evil-insert)

        ;;;; Normal
;; Basic movements
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "k") 'exwm-sm-core-up)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "j") 'exwm-sm-core-down)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "h") 'exwm-sm-core-left)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "l") 'exwm-sm-core-right)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "K") 'exwm-sm-core-goto-parent)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "J") 'exwm-sm-core-goto-child)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "H") 'exwm-sm-core-back)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "L") 'exwm-sm-core-forward)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "/") 'exwm-sm-core-find)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "t") 'exwm-sm-core-test)

;;; Editing text
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "y") 'exwm-sm-core-copy)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "d") 'exwm-sm-core-cut)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "p") 'exwm-sm-core-paste)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "u") 'exwm-sm-core-undo)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "R") 'exwm-sm-core-redo)
;; Editing elements
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "e") 'exwm-sm-core-answer)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "E") 'exwm-sm-core-question)

;;; Learn operations
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "d") 'exwm-sm-core-contents-dismiss-element)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "x") 'exwm-sm-core-extract)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "X") 'exwm-sm-core-schedule-extract)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "SPC") 'exwm-sm-core-learn)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd ",") 'nanjigen/sm-hydra/body)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "<return>") 'exwm-sm-core-rep)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "P") 'exwm-sm-core-prioritize)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "s") 'exwm-sm-core-reschedule)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "o") 'exwm-sm-core-get-filepath)
(evil-define-key 'normal exwm-sm-evil-mode-map (kbd "r") 'exwm-sm-core-replay)


(map! :map exwm-sm-evil-mode-map
      :n "SPC" #'exwm-sm-core-learn)


;;; Mode
;;;###autoload
(define-minor-mode exwm-sm-evil-mode nil nil nil exwm-sm-evil-mode-map
  (if exwm-sm-evil-mode
      (progn
        (exwm-sm-evil-normal))))

;;;###autoload
(defun exwm-sm-evil-activate-if-sm ()
  "Activates exwm-sm mode when buffer is SM.
SM variant can be assigned in 'exwm-sm-evil-sm-name`"
  (interactive)
  (if (member exwm-class-name exwm-sm-evil-sm-buffer-name)
      (exwm-sm-evil-mode 1)))

(provide '+exwm-sm-evil)

;;; +exwm-sm-evil.el ends here
#+end_src

#+RESULTS:
: +exwm-sm-evil
* sm-hydra
:PROPERTIES:
:CREATED:  [2021-04-20 Tue 15:49]
:ID:       70ea4d74-e725-4448-b1fe-10c10eaa5a9a
:END:

By using a =hydra-title= like [[file:~/.emacs.d/.local/straight/repos/org-media-note/org-media-note.el::defun org-media-note--hydra-title (][here]], I can have commands run in the background to influence the names of hydra commands.
#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+sm-hydra.el
;;; desktop/exwm/+sm-hydra.el -*- lexical-binding: t; -*-
(pretty-hydra-define nanjigen/sm-hydra
  (:color red
   ;; :title (--hydra-title)
   :hint nil)
  ("Learn"
   (("rr" (exwm-sm-core-remember) "Remember")
    ("c" (exwm-sm-core-cancel-grade) "Undo grading")
    ("s" (nanjigen/sm-subset-hydra/body) "Subset operations")
    ("rs" (exwm-sm-core-set-read-point) "Set read point")
    ("m" (exwm-sm-core-mercy) "Mercy")
    ("S" (exwm-sm-core-sorting-criteria) "Sorting Criteria"))
  "Editing"
   (("i" (exwm-sm-core-italic) "italics")
    ("b" (exwm-sm-core-bold) "bold")
    ("q" (exwm-sm-core-edit-question) "Edit Question")
    ("a" (exwm-sm-core-edit-answer) "Edit Answer")
    ("n" (exwm-sm-core-edit-answer) "Edit Next Component")
    ("f" (exwm-sm-core-edit-file) "Edit File"))
  "Misc"
   (("SPC" (exwm-sm-core-sm-commander) "SuperMemo Commander")
    ("rc" (exwm-sm-core-repair-collection) "Repair Collection")
    ("rl" (exwm-sm-core-restore-layout) "Restore layout")
    ("A" (exwm-sm-core-statistics-analysis) "Stats window"))))

#+end_src

#+begin_src elisp :tangle ~/.doom.d/modules/desktop/exwm/+sm-hydra.el
;;; desktop/exwm/+sm-hydra.el -*- lexical-binding: t; -*-
(pretty-hydra-define nanjigen/sm-subset-hydra
  (:color red
   ;; :title (--hydra-title)
   :hint nil)
  ("Learn"
   (("b" (exwm-sm-core-branch-learning) "Branch learning")
    ("r" (exwm-sm-core-random-learning) "Random learning")
    ("t" (exwm-sm-core-random-test) "Random test")
    ("n" (exwm-sm-core-neural) "Go neural")
    ("s" (exwm-sm-core-subset-learning) "Subset learning"))))

#+end_src

* AHK
:PROPERTIES:
:CREATED:  [2020-11-30 Mon 17:08]
:ID:       8d766356-bb00-4536-8974-6906b6c2837f
:END:

A good guide for ahk under linux https://code.google.com/archive/p/winetricks/wikis/AutoHotkey.wiki
#+begin_src ahk :tangle ~/.scripts/ahk/activate.verb :mkdirp yes
w_metadata activate apps \
title="Hello, Autohotkey"

load_activate()
{
w_ahk_do "
;WinActivate, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
run, notepad.exe
WinWait, Untitled - Notepad
;ControlSend, lol, Test, ahk_class TElWind
;ControlSend, Test2, {v}, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
;j::
;WinActivate, ahk_exe sm18.exe
;WinGetActiveTitle, Title
;WinGetClass, Var, A
;MsgBox ahk_class %Var%
;MsgBox, The active window is "%Title%".
send, l
;return
"
}
#+end_src

Finding the class of a window
#+begin_src ahk :tangle ~/.scripts/ahk/class.verb :mkdirp yes
w_metadata class apps \
title="Hello, Autohotkey"

load_class()
{
w_ahk_do "
j::
;WinActivate, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
;WinActivate, ahk_class sm18.exe
WinGetActiveTitle, Var
;WinGetClass, Var, A
;ControlGet, Var, A
;MsgBox ahk_class %Var%
MsgBox, The active window is "%Var%".
;send, l
return
"
}
#+end_src

Testing some sending code
#+begin_src ahk :tangle ~/.scripts/ahk/send.verb :mkdirp yes
w_metadata send apps \
title="Hello, Autohotkey"

load_send()
{
w_ahk_do "
;j::
;WinActivate, ahk_class TElWind
;#IfWinActive, ahk_class, TElWind
;#IfWinActive, ahk_class, Notepad
;ControlSend, Edit1, Test, WinTitle, Untitled - Notepad
;ControlSend, Edit1, Test, Untitled - Notepad
ControlSend, Edit1, Test, home
;WinGetActiveTitle, Var
;WinGetClass, Var, A
;MsgBox ahk_class %Var%
;MsgBox, The active window is "%Var%".
;send, l
;return
"
}
#+end_src

This works well for copying the element path
#+begin_src ahk :tangle ~/.scripts/ahk/senda.verb :mkdirp yes
w_metadata senda apps \
title="Hello, Autohotkey"

load_senda()
{
w_ahk_do "
#NoEnv  ; Recommended for performance and compatibility with future AutoHotkey releases.
; #Warn  ; Enable warnings to assist with detecting common errors.
SendMode Input  ; Recommended for new scripts due to its superior speed and reliability.
;SetWorkingDir %A_ScriptDir%  ; Ensures a consistent starting directory.
SetTitleMatchMode,2
;WinActivate, ahk_exe sm18.exe
;WinWaitActive, ahk_exe sm18.exe
;WinActivate, ahk_class TElWind
;WinWaitActive, WinTitle Untitled - Notepad
#IfWinActive, ahk_class TElWind

::sm-get-path::
send, +{F10}
;sleep,5
send, f
;sleep,5
send, c
;send, ^a
"
}
#+end_src
z:\\home\\vrika\\documents\\sm\\neuron\\elements\\16\\168.HTM
z:\home\vrika\documents\sm\neuron\elements\16\168.HTM
file:/home/vrika/Documents/SM/neuron/elements/16/167.HTM

Change windows path to unix:

#+begin_src elisp
;; (defun my-translate-winpath ()
  ;; (interactive)
  ;; "change :C\win\path to 'nix /path/path"
  (let ((path (current-kill 0 'do-not-move)))
    (shell-command-to-string (format "~/.scripts/winpath.sh %s" path)))
#+end_src

#+begin_src elisp
(defun my-translate-winpath ()
  (interactive)
  (progn
  ;; (shell-command "sh ~/.scripts/xdotool/get_element_path.sh")
  (shell-command "xclip -sel clip -o")
  (shell-command "xdotool sleep 0.2 key --delay 50 shift+F10+f+c")
;; (gui--selection-value-internal 'CLIPBOARD)
  (setq sm-path (gui--selection-value-internal 'CLIPBOARD))
    (let* ((path1 (s-chop-prefix "z:" sm-path))
           (nixpath (s-replace "\\" "/" path1))
           (docpath (s-replace "documents" "Documents" nixpath))
           (finpath (s-replace "sm" "SM" docpath)))
      (setq sm-path-nix finpath))))
;; (list path path2)
;; (shell-command-to-string (format "~/.scripts/winpath.sh" ))
#+end_src

#+RESULTS:
: my-translate-winpath

#+begin_src elisp
(defun exwm-sm-core-test ()
  "Send string to a given exwm buffer"
  (interactive)
  (my-exwm-send-string "sm-get-path ")
  (sit-for 0.3)
  (let ((path (my-translate-winpath)))
    (find-file path)))
#+end_src

#+RESULTS:
: my-translate-winpath

#+begin_src elisp
(defun my-exwm-send-string (string)
  "Send STRING to `exwm-mode' buffer or just insert it."
  (if (eq major-mode 'exwm-mode)
      (mapc #'exwm-input--fake-key (string-to-list string))
    (insert string)))
#+end_src
z:\home\vrika\documents\sm\neuron\elements\5.HTM
#+RESULTS:
: my-exwm-send-string

#+begin_src elisp
;; (subst-char-in-string ?\ ?/ (regexp-quote "\home"))
;; (regexp-quote "^home")
;; (convert-standard-filename "z:\home\vrika\documents\sm\neuron\elements\16\168.HTM")
;; (setq windows-path (unescape-windows-path "\home\vrika"))

;; (setq windows-path1 "\home\vrika")
;; (wsl-path-convert-file-name "\home\vrika")
;; (s-replace "\\" "/" "\home")
;; (s-replace "\\" "/" windows-path)
;; (replace-regexp-in-string "\\\\" "\\\\\\\\" "\home\vrika")
;; (message windows-path1)
;; (defun unescape-windows-path (pth)
;;   ;; (interactive "*sWindows path:")
;;    (replace-regexp-in-string "\\\\" "\\\\\\\\" pth))

;; (defun paste-windows-path (pth)
;;   (interactive "*sWindows path:")
;;   (insert
;;    (replace-regexp-in-string "\\\\" "\\\\\\\\" pth)))
;; (message (current-kill 0 'do-not-move))
;; (shell-command-to-string "sed -e 's#^J:##' -e 's#\\#/#g' <<< 'test'")

(convert-standard-filename "~/Documents")
#+end_src

#+RESULTS:
: ~/Documents

#+begin_src sh :tangle ~/.scripts/winpath.sh
function winpath(){
    line=$(sed -e 's#^J:##' -e 's#\\#/#g' <<< "$1")
    echo "$line"
}
#+end_src

#+begin_src sh
#!/bin/bash
clip=$(xclip -selection c -o)
line=$(sed -e 's#^z:##' -e 's#\\#/#g' <<< "$clip")
echo "$line"
#+end_src

#+RESULTS:

#+begin_src ahk :tangle ~/.scripts/ahk/hotstring.verb :mkdirp yes
w_metadata hotstring apps \
title="Hello, Autohotkey"

load_hotstring()
{
w_ahk_do "
:*:get::get it boi
"
}
#+end_src

#+begin_src sh :dir ~/.scripts/ahk/ :session test
env WINEPREFIX=/home/vrika/.local/share/wineprefixes/supermemo18 winetricks activate.verb
#+end_src

#+RESULTS:
|                                              |               |                       |                                     |            |                                                                  |        |          |     |                |
| Executing                                    | mkdir         | -p                    | /home/vrika/.local/share/wineprefixes |            |                                                                  |        |          |     |                |
| Using                                        | winetricks    | 20200412              | -                                   | sha256sum: | 40ff4c67804584b73d4d36153e1f64ca426d739f1790bd748f5ded0865e8cc7f | with   | wine-5.2 | and | WINEARCH=win32 |
| Executing                                    | w_do_call     | activate              |                                     |            |                                                                  |        |          |     |                |
| Executing                                    | mkdir         | -p                    | /home/vrika/.local/share/wineprefixes |            |                                                                  |        |          |     |                |
| Executing                                    | load_activate |                       |                                     |            |                                                                  |        |          |     |                |
| Executing                                    | wine          | x:\ahk\AutoHotkey.exe | C:\windows\Temp\activate.ahk        |            |                                                                  |        |          |     |                |
| 00b9:fixme:keyboard:X11DRV_GetKeyboardLayout | couldn't      | return                | keyboard                            | layout     | for                                                              | thread |       81 |     |                |

** Snippet
:PROPERTIES:
:CREATED:  [2020-12-01 Tue 22:38]
:ID:       e177ba0d-cfc1-41d7-bc09-4b2e3a1edef9
:END:

#+begin_src yas
# -*- mode: snippet -*-
# name: SuperMemo Ref
# key: sm-ref
# --

#SuperMemo Reference:
#Title: (org-web-tools--html-title (org-web-tools--get-first-url))
#Date: Imported on Oct 15, 2020, 18:50:29
#Source: Wikipedia
#Link: (org-web-tools--get-first-url)
#Comment: Lisp (programming language)
#Parent: 17: Programming
#Concept group: Root: neuron (1: neuron)
#+end_src

* sm desktop
:PROPERTIES:
:CREATED:  [2020-10-19 Mon 13:36]
:ID:       c5515f7e-a0c6-40d8-8b60-36b4334874ad
:END:
.desktop file:
#+begin_src conf
[Desktop Entry]
Name=SuperMemo 18 (ms-office)
Exec=env WINEPREFIX="/home/volk/.local/share/wineprefixes/ms-office" wine "/home/volk/.local/share/wineprefixes/ms-office/drive_c/SuperMemo/sm18.exe"
Type=Application
Categories=Education;
StartupNotify=true
Comment=Organize your knowledge and learn at the maximum possible speed
Path=/home/volk/.local/share/wineprefixes/ms-office/drive_c/SuperMemo
Icon=/home/volk/.local/share/wineprefixes/ms-office/drive_c/SuperMemo/smicon.png
StartupWMClass=sm18.exe
#+end_src

* SM in a VM and RPC
:PROPERTIES:
:CREATED:  [2020-12-11 Fri 21:15]
:ID:       fafd87f0-c7c8-467d-861c-d0fc634d9893
:END:

* SM with Emacs
:PROPERTIES:
:CREATED:  [2021-01-04 Mon 15:52]
:ID:       a04ab1f5-a77b-4dec-8c59-3276246dfb88
:END:

** sm yasnippet
:PROPERTIES:
:CREATED:  [2021-01-04 Mon 15:52]
:ID:       9fd2197d-3730-458d-ad94-c90d7309d355
:END:

#+begin_src yasnippet
# -*- mode: snippet -*-
# name: org-pdftools-sm-reference
# key: pdf-ref
# --

#SuperMemoReference
#Title:
#Author:
#Date: Imported on Dec 28, 2020, 00:00:00
#Source: (org-ref) bibtex?
#Link: pdf:
#Comment:
#Article: 40:
#Concept group: Root: neruon (1: neuron)
#+end_src

* org-protocol
:PROPERTIES:
:CREATED:  [2021-02-19 Fri 13:42]
:ID:       4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b
:END:
By using ~org-protocol~, we can call =emacsclient= from other applications by specifying a link recognised by the OS (whether is be Linux or Windows).

First we declare a regedit for WINE, in which we allow Windows to recognise the ~org-protocol:~ scheme handler:
https://github.com/nobiot/Zero-to-Emacs-and-Org-roam/blob/main/90.org-protocol.md
#+begin_src conf
Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\org-protocol]
@="URL:Org Protocol"
"URL Protocol"=""
[HKEY_CLASSES_ROOT\org-protocol\shell]
[HKEY_CLASSES_ROOT\org-protocol\shell\open]
[HKEY_CLASSES_ROOT\org-protocol\shell\open\command]
@="C:\\windows\\system32\\winebrowser.exe -nohome \"%1\""
#+end_src

#+begin_src elisp :tangle ~/.doom.d/modules/lang/org-private/+org-protocol.el
;;; lang/org-private/+org-protocol.el -*- lexical-binding: t; -*-

(use-package! org-protocol
  :after org
  :config
  <<org-protocol handlers>>
  )

<<org-export backend>>

#+end_src

** Custom org-protocol handlers
:PROPERTIES:
:CREATED:  [2021-03-01 Mon 15:07]
:ID:       c342cd1d-25eb-499f-9bf5-d1b4dbf1e470
:header-args: :noweb-ref org-protocol handlers
:END:
Then we can write a custom org-id [[https://emacs.stackexchange.com/questions/47986/jump-to-org-mode-heading-from-external-application][protocol handler]]:
#+begin_src elisp

(add-to-list 'org-protocol-protocol-alist
             '("org-id" :protocol "org-id"
               :function org-id-protocol-goto-org-id))

(defun org-id-protocol-goto-org-id (info)
  "This handler simply goes to the org heading with given id using emacsclient.

    INFO is an alist containing additional information passed by the protocol URL.
    It should contain the id key, pointing to the path of the org id.

      Example protocol string:
      org-protocol://org-id?id=309A0509-81BE-4D51-87F4-D3F61B79EBA4"
  (when-let ((id (plist-get info :id)))
    (org-id-goto id))
  nil)

(defun org-id-protocol-link-copy ()
  (interactive)
  (org-kill-new (concat "org-protocol://org-id?id="
                        (org-id-copy))))

#+end_src

#+begin_src elisp
(add-to-list 'org-protocol-protocol-alist
             '("brain-id" :protocol "brain-id"
               :function brain-id-protocol-visualize-brain-id))

(defun brain-id-protocol-visualize-brain-id (info)
  "This handler visualizes the org heading with given id using emacsclient.

    INFO is an alist containing additional information passed by the protocol URL.
    It should contain the id key, pointing to the path of the org id.

      Example protocol string:
      org-protocol://brain-id?id=309A0509-81BE-4D51-87F4-D3F61B79EBA4"
  (when-let ((id (plist-get info :id)))
    (org-brain-visualize (or (org-brain-entry-from-id id))))
  nil)

(defun brain-id-protocol-link-copy ()
  (interactive)
  (org-kill-new (concat "org-protocol://brain-id?id="
                        (org-id-copy))))

#+end_src

#+begin_src elisp
(add-to-list 'org-protocol-protocol-alist
             '("pdf-tools" :protocol "pdf-tools"
               :function pdftools-protocol-pop-pdf))

(defun pdftools-protocol-pop-pdf (info)
  "This opens the highlight location of the given extract

    INFO is an alist containing additional information passed by the protocol URL.
    It should contain the org-pdf-tools link, pointing to the path of the org id.

      Example protocol string:
      org-protocol://brain-id?id=309A0509-81BE-4D51-87F4-D3F61B79EBA4"
  (when-let ((link (plist-get info :pdf)))
    (org-link-open-from-string (format "[[pdf:%s]]" link)))
  nil)

(defun pdf-tools-protocol-link-copy ()
  (interactive)
  (org-kill-new (concat "org-protocol://pdf-tools?pdf="
                        (org-entry-get nil "NOTER_PAGE"))))

(defun pdft-tools-protocol-htmlfier ()
  (interactive)
  (let ((pdf-link (org-entry-get nil "ID")))
    (format "<a href=\"org-protocol://pdf-tools?pdf=%s\"></a>" pdf-link)))

(defun pdf-tools-protocol-html-link-copy ()
  (interactive)
  (org-kill-new (concat "<a href=\"org-protocol://pdf-tools?pdf="
                        (org-entry-get nil "NOTER_PAGE") "</a>")))

#+end_src
"<a href=\"org-protocol://brain-id?id=%s\">%s</a>"

#+begin_src elisp
(add-to-list 'org-protocol-protocol-alist
             '("media-link" :protocol "media-link"
               :function media-link-protocol-play-mpv-video))

(defun media-link-protocol-play-mpv-video (info)
  "This handler visualizes the org heading with given id using emacsclient.

    INFO is an alist containing additional information passed by the protocol URL.
    It should contain the id key, pointing to the path of the org id.

      Example protocol string:
      org-protocol://media-link?video=~/org/.attach/27/e2318b-7353-4004-943a-2f1d69b32209/doge_vid420.mpg#0:00:13"
  (when-let ((link (plist-get info :video)))
    (org-link-open-from-string (format "[[video:%s]]" link)))
  nil)

(defun media-link-protocol-link-copy ()
  (interactive)
  (org-kill-new (concat "org-protocol://media-link?video="
                        (org-id-copy))))

#+end_src

#+begin_src elisp
(defun media-link-protocol-play-cite-video (info)
"This handler visualizes the org heading with given id using emacsclient.

  INFO is an alist containing additional information passed by the protocol URL.
  It should contain the id key, pointing to the path of the org id.

    Example protocol string:
    org-protocol://media-link?videocite=~/org/.attach/27/e2318b-7353-4004-943a-2f1d69b32209/doge_vid420.mpg#0:00:13"
(when-let ((link (plist-get info :videocite)))
  (org-link-open-from-string (format "[[videocite:%s]]" link)))
nil)

(defun media-link-protocol-cite-link-copy ()
  (interactive)
  (org-kill-new (concat "org-protocol://media-link?videocite="
                        (org-media-note--current-org-ref-key))))
#+end_src
org-protocol://media-link?video=https://www.youtube.com/watch?v=lW3eWIj3Q04#0:03:28-0:03:39
org-protocol://org-id?id=4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b
[[org-protocol://org-id/?id=4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b]]
[[org-protocol://org-id?id=4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b]] ;; doesn't work

Because we have defined a regedit, with the right formatting, html links will redirect to the org-protocol handler as well:
#+begin_example html :tangle no
<A href="org-protocol://org-id?id=4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b">Link text here</A>
<A href="org-protocol://org-id?id=4dd04a25-b81d-4da3-b6d0-dc1ba9dd307b">** org-protocol</A>
#+end_example

This can be directly pasted into an element with either =e= (for Questions) or =a= (for Answers) and then =M-<F10>-x-p= (Element pane -> Text -> Paste Html)

Now we can write a key script to automate this process, and bind it to a contextual hydra:

** org-export backend
:PROPERTIES:
:CREATED:  [2021-03-01 Mon 15:07]
:ID:       d2942d96-207d-4061-bcea-116f8a437b8d
:header-args: :noweb-ref org-export backend
:END:
To automate the process, we can write extend the =org-export= backend with [[https://kitchingroup.cheme.cmu.edu/blog/2018/05/09/Making-it-easier-to-extend-the-export-of-org-mode-links-with-generic-functions/][org-link-set-parameters]] to introduce the above protocol link into header text automatically
#+begin_src elisp
(cl-defgeneric brain-link-export (path desc backend)
 "Generic function to export a brain link."
 path)

;; this one runs when the backend is equal to html
(cl-defmethod brain-link-export ((path t) (desc t) (backend (eql html)))
 (format "<a href=\"org-protocol://brain-id?id=%s\">%s</a>" path desc))

(org-link-set-parameters "brain" :export 'brain-link-export)
#+end_src

=video:= link exporter
#+begin_src elisp
(cl-defgeneric media-link-export (path desc backend)
 "Generic function to export a brain link."
 path)

;; this one runs when the backend is equal to html
(cl-defmethod media-link-export ((path t) (desc t) (backend (eql html)))
 (format "<a href=\"org-protocol://media-link?video=%s\">%s</a>" path desc))

(org-link-set-parameters "video" :export 'media-link-export)
#+end_src

=videocite:= link exporter
#+begin_src elisp

;; this one runs when the backend is equal to html
(cl-defmethod media-link-export ((path t) (desc t) (backend (eql html)))
 (format "<a href=\"org-protocol://media-link?video=%s\">%s</a>" path desc))

(org-link-set-parameters "video" :export 'media-link-export)

;; for videocite links
(cl-defgeneric videocite-link-export (path desc backend)
 "Generic function to export a brain link."
 path)

;; this one runs when the backend is equal to html
(cl-defmethod videocite-link-export ((path t) (desc t) (backend (eql html)))
 (format "<a href=\"org-protocol://media-link?videocite=%s\">%s</a>" path desc))

(org-link-set-parameters "videocite" :export 'videocite-link-export)
#+end_src

cite:key reference exporter

#+begin_src elisp
(cl-defgeneric cite-link-export (path desc backend)
 "Generic function to export a brain link."
 path)

;; this one runs when the backend is equal to html
(cl-defmethod cite-link-export ((path t) (desc t) (backend (eql html)))
  (format "<a href=\"%s\">%s:%s</a>" path path desc))

(org-link-set-parameters "cite" :export 'cite-link-export)
#+end_src

Ideally targeting the ~:ID:~ property, extracting the =org-id= and generating the org-protocol link:
https://emacs.stackexchange.com/questions/156/emacs-function-to-convert-an-arbitrary-org-property-into-an-arbitrary-string-na

Modified =org-html-headline= from [[file:~/.emacs.d/.local/straight/repos/org-mode/lisp/ox-html.el::defun org-html-headline (headline contents info][ox-html.el]] :
#+begin_src elisp
(after! org
  (setq org-html-self-link-headlines t)

  (defun org-html-headline (headline contents info)
    "Transcode a HEADLINE element from Org to HTML.
    CONTENTS holds the contents of the headline.  INFO is a plist
    holding contextual information."
    (unless (org-element-property :footnote-section-p headline)
      (let* ((numberedp (org-export-numbered-headline-p headline info))
             (numbers (org-export-get-headline-number headline info))
             (level (+ (org-export-get-relative-level headline info)
                       (1- (plist-get info :html-toplevel-hlevel))))
             (todo (and (plist-get info :with-todo-keywords)
                        (let ((todo (org-element-property :todo-keyword headline)))
                          (and todo (org-export-data todo info)))))
             (todo-type (and todo (org-element-property :todo-type headline)))
             (priority (and (plist-get info :with-priority)
                            (org-element-property :priority headline)))
             (text (org-export-data (org-element-property :title headline) info))
             (tags (and (plist-get info :with-tags)
                        (org-export-get-tags headline info)))
             (full-text (funcall (plist-get info :html-format-headline-function)
                                 todo todo-type priority text tags info))
             (contents (or contents ""))
             (id (org-html--reference headline info))
             (brain-id (org-element-property :ID headline))
             (formatted-text
              ;; (if (plist-get info :html-self-link-headlines)
              ;;     (format "<a href=\"#%s\">%s</a>" id full-text)
              ;;   full-text)))
              (if (plist-get info :html-self-link-headlines)
                  (format "<a href=\"org-protocol://brain-id?id=%s\">%s</a>" brain-id full-text)
                full-text)))
        (if (org-export-low-level-p headline info)
            ;; This is a deep sub-tree: export it as a list item.
            (let* ((html-type (if numberedp "ol" "ul")))
              (concat
               (and (org-export-first-sibling-p headline info)
                    (apply #'format "<%s class=\"org-%s\">\n"
                           (make-list 2 html-type)))
               (org-html-format-list-item
                contents (if numberedp 'ordered 'unordered)
                nil info nil
                (concat (org-html--anchor id nil nil info) formatted-text)) "\n"
               (and (org-export-last-sibling-p headline info)
                    (format "</%s>\n" html-type))))
          ;; Standard headline.  Export it as a section.
          (let ((extra-class
                 (org-element-property :HTML_CONTAINER_CLASS headline))
                (headline-class
                 (org-element-property :HTML_HEADLINE_CLASS headline))
                (first-content (car (org-element-contents headline))))
            (format "<%s id=\"%s\" class=\"%s\">%s%s</%s>\n"
                    (org-html--container headline info)
                    (format "outline-container-%s" id)
                    (concat (format "outline-%d" level)
                            (and extra-class " ")
                            extra-class)
                    (format "\n<h%d id=\"%s\"%s>%s</h%d>\n"
                            level
                            id
                            (if (not headline-class) ""
                              (format " class=\"%s\"" headline-class))
                            (concat
                             (and numberedp
                                  (format
                                   "<span class=\"section-number-%d\">%s</span> "
                                   level
                                   (mapconcat #'number-to-string numbers ".")))
                             formatted-text)
                            level)
                    ;; When there is no section, pretend there is an
                    ;; empty one to get the correct <div
                    ;; class="outline-...> which is needed by
                    ;; `org-info.js'.
                    (if (eq (org-element-type first-content) 'section) contents
                      (concat (org-html-section first-content "" info) contents))
                    (org-html--container headline info)))))))
  )

#+end_src

* SM (linux) mpv prototyping                                           :ATTACH:
:PROPERTIES:
:CREATED:  [2021-01-14 Thu 20:03]
:ID:       d3b44770-6bb2-4675-b451-3f388e0cb6da
:END:

An alternative to scripting with =lua= would be using the =fennel= language.

** TODO Embed fennel in mpv lua module
:PROPERTIES:
:CREATED:  [2021-08-14 Sat 12:34]
:ID:       34ae3659-6881-476b-a132-0a3863ad8064
:END:

https://gitlab.com/technomancy/fennel-mode/-/blob/master/Readme.md
https://fennel-lang.org/setup#embedding-fennel

** mpv input.conf
:PROPERTIES:
:CREATED:  [2021-01-31 Sun 11:17]
:ID:       8c4df6c5-9b2b-4352-a1bc-31a11e4fd1b9
:END:
#+begin_src lua :tangle ~/.config/mpv/input.conf
# mpv keybindings
#
# Location of user-defined bindings: ~/.config/mpv/input.conf
#
# Lines starting with # are comments. Use SHARP to assign the # key.
# Copy this file and uncomment and edit the bindings you want to change.
#
# List of commands and further details: DOCS/man/input.rst
# List of special keys: --input-keylist
# Keybindings testing mode: mpv --input-test --force-window --idle
#
# Use 'ignore' to unbind a key fully (e.g. 'ctrl+a ignore').
#
# Strings need to be quoted and escaped:
#   KEY show-text "This is a single backslash: \\ and a quote: \" !"
#
# You can use modifier-key combinations like Shift+Left or Ctrl+Alt+x with
# the modifiers Shift, Ctrl, Alt and Meta (may not work on the terminal).
#
# The default keybindings are hardcoded into the mpv binary.
# You can disable them completely with: --no-input-default-bindings

# Developer note:
# On compilation, this file is baked into the mpv binary, and all lines are
# uncommented (unless '#' is followed by a space) - thus this file defines the
# default key bindings.

# If this is enabled, treat all the following bindings as default.
#default-bindings start

#MBTN_LEFT     ignore              # don't do anything
#MBTN_LEFT_DBL cycle fullscreen    # toggle fullscreen on/off
#MBTN_RIGHT    cycle pause         # toggle pause on/off
#MBTN_BACK     playlist-prev
#MBTN_FORWARD  playlist-next

# Mouse wheels, touchpad or other input devices that have axes
# if the input devices supports precise scrolling it will also scale the
# numeric value accordingly
#WHEEL_UP      seek 10
#WHEEL_DOWN    seek -10
#WHEEL_LEFT    add volume -2
#WHEEL_RIGHT   add volume 2

## Seek units are in seconds, but note that these are limited by keyframes
RIGHT seek  5
LEFT  seek -5
UP    seek  60
DOWN  seek -60
# Do smaller, always exact (non-keyframe-limited), seeks with shift.
# Don't show them on the OSD (no-osd).
Shift+RIGHT no-osd seek  1 exact
Shift+LEFT  no-osd seek -1 exact
Shift+UP    no-osd seek  5 exact
Shift+DOWN  no-osd seek -5 exact
# Skip to previous/next subtitle (subject to some restrictions; see manpage)
Ctrl+LEFT   no-osd sub-seek -1
Ctrl+RIGHT  no-osd sub-seek  1
# Adjust timing to previous/next subtitle
Ctrl+Shift+LEFT sub-step -1
Ctrl+Shift+RIGHT sub-step 1
# Move video rectangle
Alt+left  add video-pan-x  0.1
Alt+right add video-pan-x -0.1
Alt+up    add video-pan-y  0.1
Alt+down  add video-pan-y -0.1
# Zoom/unzoom video
Alt++     add video-zoom   0.1
Alt+-     add video-zoom  -0.1
# Reset video zoom/pan settings
#Alt+BS set video-zoom 0 ; set video-pan-x 0 ; set video-pan-y 0
PGUP add chapter 1                     # skip to next chapter
PGDWN add chapter -1                   # skip to previous chapter
#Shift+PGUP seek 600
#Shift+PGDWN seek -600
[ multiply speed 1/1.1                 # scale playback speed
] multiply speed 1.1
{ multiply speed 0.5
} multiply speed 2.0
BS set speed 1.0                       # reset speed to normal
Shift+BS revert-seek                   # undo previous (or marked) seek
Shift+Ctrl+BS revert-seek mark         # mark position for revert-seek
q quit
#Q quit-watch-later
#q {encode} quit 4
ESC set fullscreen no
#ESC {encode} quit 4
#p cycle pause                          # toggle pause/playback mode
. frame-step                           # advance one frame and pause
, frame-back-step                      # go back by one frame and pause
SPACE cycle pause
#> playlist-next                        # skip to next file
#ENTER playlist-next                    # skip to next file
#< playlist-prev                        # skip to previous file
O no-osd cycle-values osd-level 3 1    # cycle through OSD mode
o show-progress
P show-progress
i script-binding stats/display-stats
I script-binding stats/display-stats-toggle
` script-binding console/enable
z add sub-delay -0.1                   # subtract 100 ms delay from subs
Z add sub-delay +0.1                   # add
x add sub-delay +0.1                   # same as previous binding (discouraged)
#ctrl++ add audio-delay 0.100           # this changes audio/video sync
#ctrl+- add audio-delay -0.100
m cycle mute
1 add contrast -1
2 add contrast 1
3 add brightness -1
4 add brightness 1
5 add gamma -1
6 add gamma 1
7 add saturation -1
8 add saturation 1
Alt+0 set window-scale 0.5
Alt+1 set window-scale 1.0
Alt+2 set window-scale 2.0
# toggle deinterlacer (automatically inserts or removes required filter)
d cycle deinterlace
r add sub-pos -1                       # move subtitles up
R add sub-pos +1                       #                down
t add sub-pos +1                       # same as previous binding (discouraged)
v cycle sub-visibility
# stretch SSA/ASS subtitles with anamorphic videos to match historical
V cycle sub-ass-vsfilter-aspect-compat
# switch between applying no style overrides to SSA/ASS subtitles, and
# overriding them almost completely with the normal subtitle style
u cycle-values sub-ass-override "force" "no"
j cycle sub                            # cycle through subtitles
J cycle sub down                       # ...backwards
#SHARP cycle audio                      # switch audio streams
#_ cycle video
#T cycle ontop                          # toggle video window ontop of other windows
f cycle fullscreen                     # toggle fullscreen
s screenshot                           # take a screenshot
S screenshot video                     # ...without subtitles
Ctrl+s screenshot window               # ...with subtitles and OSD, and scaled
Alt+s screenshot each-frame            # automatically screenshot every frame
w add panscan -0.1                     # zoom out with -panscan 0 -fs
W add panscan +0.1                     #      in
e add panscan +0.1                     # same as previous binding (discouraged)
# cycle video aspect ratios; "-1" is the container aspect
A cycle-values video-aspect-override "16:9" "4:3" "2.35:1" "-1"
#POWER quit
#PLAY cycle pause
#PAUSE cycle pause
#PLAYPAUSE cycle pause
#PLAYONLY set pause no
#PAUSEONLY set pause yes
#STOP quit
#FORWARD seek 60
#REWIND seek -60
#NEXT playlist-next
#PREV playlist-prev
#VOLUME_UP add volume 2
#VOLUME_DOWN add volume -2
#MUTE cycle mute
#CLOSE_WIN quit
#CLOSE_WIN {encode} quit 4
#E cycle edition                        # next edition
l ab-loop                              # Set/clear A-B loop points
L cycle-values loop-file "inf" "no"    # toggle infinite looping
#ctrl+c quit 4
DEL script-binding osc/visibility      # cycle OSC display
#ctrl+h cycle-values hwdec "auto" "no"  # cycle hardware decoding
F8 show_text ${playlist}               # show playlist
F9 show_text ${track-list}             # show list of audio/sub streams

#
# Legacy bindings (may or may not be removed in the future)
#
#! add chapter -1                       # skip to previous chapter
#@ add chapter 1                        #         next

#
# Not assigned by default
# (not an exhaustive list of unbound commands)
#

# ? add sub-scale +0.1                  # increase subtitle font size
# ? add sub-scale -0.1                  # decrease subtitle font size
# ? cycle angle                         # switch DVD/Bluray angle
# ? cycle sub-forced-only               # toggle DVD forced subs
# ? cycle program                       # cycle transport stream programs
# ? stop                                # stop playback (quit or enter idle mode)

CTRL+SHIFT+p script-message chapterlist

# g run "home/volk/.config/mpv/scripts/giffer" "${path}" "/home/volk/Videos/${filename/no-ext} ${=ab-loop-a}.gif" "${=ab-loop-a}" "${=ab-loop-b}"
# h run "home/volk/.config/mpv/scripts/giffer" "${path}" "/home/volk/Videos" "${=ab-loop-a}" "${=ab-loop-b}"

#+end_src

* org-brain integration
:PROPERTIES:
:CREATED:  [2021-01-15 Fri 19:51]
:ID:       c53811c9-1ada-4958-9389-5b823a811479
:END:

#+begin_src elisp
(org-brain-open-resource (org-brain-entry-at-pt t))
#+end_src

* org-noter integration
:PROPERTIES:
:CREATED:  [2021-01-19 Tue 16:27]
:ID:       6f30757e-e54b-4e7b-a43f-1443c1090730
:END:

#+begin_src elisp
;;; lang/org-private/+ir.el -*- lexical-binding: t; -*-
#+end_src

This should be a minor mode as is done with [[file:~/.emacs.d/.local/straight/repos/org-noter/org-noter.el::(define-minor-mode org-noter-notes-mode][org-noter]] (note that there are /2/ minor modes).
#+begin_src elisp
;; Key binds etc
(use-package! major-mode-hydra
  :config
  (major-mode-hydra-define pdf-view-mode
    (:title "Incremental Reading Options")
    ("Reading qeue"
     ;; There should a hydra that moves to the next item in the reading que
     (("n" evil-collection-pdf-view-next-line-or-next-page "next")
      ("p" evil-collection-pdf-view-previous-line-or-previous-page "previous"))
     "Test"
     (("s" isearch-forward "search"))
     ;; "Priority"
     ;; Priority setting options
     ;;TODO Should define some functions
     "Drill"
     (("d" nanjigen/org-drill-in-ir-dir "org-drill items")
      ("D" org-drill-resume "Resume last org-drill"))
     )))

  (pretty-hydra-define ir-hydra
    (:color blue :title "Incremental Reading")
    ("Reading que"
     ;; There should a hydra that moves to the next item in the reading que
     (("n" evil-collection-pdf-view-next-line-or-next-page "next")
      ("p" evil-collection-pdf-view-previous-line-or-previous-page "previous"))
     "org-noter"
     (("o" follow-noter-page-link "follow org-pdftools link")
      ;; Should this be a function in a specific workspace?
      ("N" org-noter "Start org-noter session")
      ("S" org-noter-pdftools-create-skeleton "Create org-noter outline"))
     ;; "Priority"
     ;; Priority setting options
     ;;TODO Should define some functions
     "Drill"
     (("d" nanjigen/org-drill-in-ir-dir "org-drill items")
      ("D" org-drill-resume "Resume last org-drill"))
     ))


(map! :localleader
      :map pdf-view-mode-map
          :desc "Insert to Org" "h" 'nanjigen/org-noter-highlight-drill)

#+end_src

The below function is an addition to [[file:~/.emacs.d/.local/straight/repos/org-noter/org-noter.el::defun org-noter-insert-note-toggle-no-questions (][org-noter-insert-note-no-questions]], possibly to insure that the ~org-pdftools~ link gets inserted correctly.
#+begin_src elisp
  ;; Add a function to ensure precise note is inserted
  (defun org-noter-pdftools-insert-precise-note (&optional toggle-no-questions)
    (interactive "P")
    (org-noter--with-valid-session
     (let ((org-noter-insert-note-no-questions (if toggle-no-questions
                                                   (not org-noter-insert-note-no-questions)
                                                 org-noter-insert-note-no-questions))
           (org-pdftools-use-isearch-link t)
           (org-pdftools-use-freestyle-annot t))
       (org-noter-insert-note (org-noter--get-precise-info)))))

#+end_src

We want items inserted with the following syntax:
#+begin_example org-mode
,** [[cite:laufer2001][10]] annot-2-0 | descriptive text                  :extract:
#+end_example

The =:extract:= tag will allow us to target those inserted headers with ~elisp~ code, and differentiate extraction headers from skeleton entries. The =cite:= syntax activates ~org-ref~ functions which may be used programmatically down the line. The "annot-2-0" is a reference to the ~org-pdftools~ link syntax -
(:NOTER_PAGE: [[pdf:~/Documents/PDF/laufer2001.pdf::2++0.00;;annot-2-0]] in this case).
The first numeral, 2, is a reference to the internal page number of the source pdf. With some text-munging we can procure the page number of the pdf for the given extract and potentially insert that into an org-buffer when writing to aid with citing: [[cite:laufer2001][2]].

#+begin_src elisp
(org-ref-insert-link nil)
(funcall org-ref-insert-cite-function)
(defun nanjigen/org-pdftools-annot-id ()
  "get 'annot' id from 'NOTER_PAGE' property"
  (interactive)
  (let* ((id (car (last (s-split ";;" (org-entry-get nil "NOTER_PAGE")))))
         (id-clean (s-chop-suffix "]]" id)))
    (insert (format "%s" id-clean))))

(org-toggle-tag "extract")
#+end_src

#+begin_src elisp
(when (and org-noter-insert-selected-text-inside-note selected-text) (insert (concat "#+begin_quote\n" selected-text "\n#+end_quote")))

(defun org-noter-insert-note-content ()
  (interactive)
  (progn (setq currenb (buffer-name))
         (set-buffer currenb)
         (org-noter-insert-note)
         ;; (org-noter-quote)
))

(fset 'org-noter-quote
      (kmacro-lambda-form [?  ?: ?j ?o ?i ?n ?e ?  backspace backspace return ?V ?  ?i ?s ?q ?u ?o ?t ?e return escape ?\{ ?\{ ?d ?d] 0 "%d"))

(setq org-noter-default-heading-title )
#+end_src

#+begin_src elisp
(defun org-noter-insert-selected-text-as-content (&optional precise-info)
  "Insert note associated with the current location.

This command will prompt for a title of the note and then insert
it in the notes buffer. When the input is empty, a title based on
`org-noter-default-heading-title' will be generated.

If there are other notes related to the current location, the
prompt will also suggest them. Depending on the value of the
variable `org-noter-closest-tipping-point', it may also
suggest the closest previous note.

PRECISE-INFO makes the new note associated with a more
specific location (see `org-noter-insert-precise-note' for more
info).

When you insert into an existing note and have text selected on
the document buffer, the variable `org-noter-insert-selected-text-inside-note'
defines if the text should be inserted inside the note."
  (interactive)
  (org-noter--with-valid-session
   (let* ((ast (org-noter--parse-root)) (contents (org-element-contents ast))
          (window (org-noter--get-notes-window 'force))
          (selected-text
           (cond
            ((eq (org-noter--session-doc-mode session) 'pdf-view-mode)
             (when (pdf-view-active-region-p)
               (mapconcat 'identity (pdf-view-active-region-text) ? )))

            ((eq (org-noter--session-doc-mode session) 'nov-mode)
             (when (region-active-p)
               (buffer-substring-no-properties (mark) (point))))))
          force-new
          (location (org-noter--doc-approx-location (or precise-info 'interactive) (gv-ref force-new)))
          (view-info (org-noter--get-view-info (org-noter--get-current-view) location)))

     (let ((inhibit-quit t))
       (with-local-quit
         (select-frame-set-input-focus (window-frame window))
         (select-window window)

         ;; IMPORTANT(nox): Need to be careful changing the next part, it is a bit
         ;; complicated to get it right...

         (let ((point (point))
               (minibuffer-local-completion-map org-noter--completing-read-keymap)
               collection default default-begin title selection
               (empty-lines-number (if org-noter-separate-notes-from-heading 2 1)))

           (cond
            ;; NOTE(nox): Both precise and without questions will create new notes
            ((or precise-info force-new)
             (setq default (and selected-text (replace-regexp-in-string "\n" " " selected-text))))
            (org-noter-insert-note-no-questions)
            (t
             (dolist (note-cons (org-noter--view-info-notes view-info))
               (let ((display (org-element-property :raw-value (car note-cons)))
                     (begin (org-element-property :begin (car note-cons))))
                 (push (cons display note-cons) collection)
                 (when (and (>= point begin) (> begin (or default-begin 0)))
                   (setq default display
                         default-begin begin))))))

           (setq collection (nreverse collection)
                 title (if org-noter-insert-note-no-questions
                           default
                         (completing-read "Note: " collection nil nil nil nil default))
                 selection (unless org-noter-insert-note-no-questions (cdr (assoc title collection))))


             ;; NOTE(nox): Inserting a new note
             (let ((reference-element-cons (org-noter--view-info-reference-for-insertion view-info))
                   level)
                 (setq title "test")
                 ;; (setq title (replace-regexp-in-string (regexp-quote "$p$") (number-to-string (car location))
                 ;;                                       org-noter-default-heading-title))

           (org-show-set-visibility t)
           (org-cycle-hide-drawers 'all)
           (org-cycle-show-empty-lines t)))
       (when quit-flag
         ;; NOTE(nox): If this runs, it means the user quitted while creating a note, so
         ;; revert to the previous window.
         (select-frame-set-input-focus (org-noter--session-frame session))
         (select-window (get-buffer-window (org-noter--session-doc-buffer session)))))))))
#+end_src

#+name: selected text to content
#+begin_src elisp
(defun org-noter-insert-selected-text-as-content (&optional precise-info)
  "Insert note associated with the current location.

This command will prompt for a title of the note and then insert
it in the notes buffer. When the input is empty, a title based on
`org-noter-default-heading-title' will be generated.

If there are other notes related to the current location, the
prompt will also suggest them. Depending on the value of the
variable `org-noter-closest-tipping-point', it may also
suggest the closest previous note.

PRECISE-INFO makes the new note associated with a more
specific location (see `org-noter-insert-precise-note' for more
info).

When you insert into an existing note and have text selected on
the document buffer, the variable `org-noter-insert-selected-text-inside-note'
defines if the text should be inserted inside the note."
  (interactive)
  (org-noter--with-valid-session
   (let* ((ast (org-noter--parse-root)) (contents (org-element-contents ast))
          (window (org-noter--get-notes-window 'force))
          (selected-text
           (cond
            ((eq (org-noter--session-doc-mode session) 'pdf-view-mode)
             (when (pdf-view-active-region-p)
               (mapconcat 'identity (pdf-view-active-region-text) ? )))

            ((eq (org-noter--session-doc-mode session) 'nov-mode)
             (when (region-active-p)
               (buffer-substring-no-properties (mark) (point))))))
          force-new
          (location (org-noter--doc-approx-location (or precise-info 'interactive) (gv-ref force-new)))
          (view-info (org-noter--get-view-info (org-noter--get-current-view) location)))

     (let ((inhibit-quit t))
       (with-local-quit
         (select-frame-set-input-focus (window-frame window))
         (select-window window)

         ;; IMPORTANT(nox): Need to be careful changing the next part, it is a bit
         ;; complicated to get it right...

         (let ((point (point))
               (minibuffer-local-completion-map org-noter--completing-read-keymap)
               collection default default-begin title selection
               (empty-lines-number (if org-noter-separate-notes-from-heading 2 1)))

           (cond
            ;; NOTE(nox): Both precise and without questions will create new notes
            ((or precise-info force-new)
             (setq default (and selected-text (replace-regexp-in-string "\n" " " selected-text))))
            (org-noter-insert-note-no-questions)
            (t
             (dolist (note-cons (org-noter--view-info-notes view-info))
               (let ((display (org-element-property :raw-value (car note-cons)))
                     (begin (org-element-property :begin (car note-cons))))
                 (push (cons display note-cons) collection)
                 (when (and (>= point begin) (> begin (or default-begin 0)))
                   (setq default display
                         default-begin begin))))))

           (setq collection (nreverse collection)
                 title (if org-noter-insert-note-no-questions
                           default
                         (completing-read "Note: " collection nil nil nil nil default))
                 selection (unless org-noter-insert-note-no-questions (cdr (assoc title collection))))

           (if selection
               ;; NOTE(nox): Inserting on an existing note

               (let* ((note (car selection))
                      (insert-before-element (cdr selection))
                      (has-content
                       (eq (org-element-map (org-element-contents note) org-element-all-elements
                             (lambda (element)
                               (if (org-noter--check-location-property element)
                                   'stop
                                 (not (memq (org-element-type element) '(section property-drawer)))))
                             nil t)
                           t)))
                 (when has-content (setq empty-lines-number 2))
                 (if insert-before-element
                     (goto-char (org-element-property :begin insert-before-element))
                   (goto-char (org-element-property :end note)))


                 (if (org-at-heading-p)
                     (progn
                       (org-N-empty-lines-before-current empty-lines-number)
                       (forward-line -1))
                   (unless (bolp) (insert "\n"))
                   (org-N-empty-lines-before-current (1- empty-lines-number)))

                 (when (and org-noter-insert-selected-text-inside-note selected-text) (insert selected-text)))
                 ;; (insert selected-text))

             ;; NOTE(nox): Inserting a new note
             (let ((reference-element-cons (org-noter--view-info-reference-for-insertion view-info))
                   level)
               (when (zerop (length title))
                 (setq title (replace-regexp-in-string (regexp-quote "$p$") (number-to-string (car location))
                                                       org-noter-default-heading-title)))

               (if reference-element-cons
                   (progn
                     (cond
                      ((eq (car reference-element-cons) 'before)
                       (goto-char (org-element-property :begin (cdr reference-element-cons))))
                      ((eq (car reference-element-cons) 'after)
                       (goto-char (org-element-property :end (cdr reference-element-cons)))))

                     ;; NOTE(nox): This is here to make the automatic "should insert blank" work better.
                     (when (org-at-heading-p) (backward-char))

                     (setq level (org-element-property :level (cdr reference-element-cons))))

                 (goto-char (org-element-map contents 'section
                              (lambda (section) (org-element-property :end section))
                              nil t org-element-all-elements))
                 (setq level (1+ (org-element-property :level ast))))

               ;; NOTE(nox): This is needed to insert in the right place
               (outline-show-entry)
               (org-noter--insert-heading level title empty-lines-number location)
               (when (org-noter--session-hide-other session) (org-overview))

               (setf (org-noter--session-num-notes-in-view session)
                     (1+ (org-noter--session-num-notes-in-view session)))))

           (org-show-set-visibility t)
           (org-cycle-hide-drawers 'all)
           (org-cycle-show-empty-lines t)))
       (when quit-flag
         ;; NOTE(nox): If this runs, it means the user quitted while creating a note, so
         ;; revert to the previous windo.
         (select-frame-set-input-focus (org-noter--session-frame session))
         (select-window (get-buffer-window (org-noter--session-doc-buffer session))))))))
#+end_src

** old org-noter code                                                :extract:
:PROPERTIES:
:CREATED:  [2021-01-19 Tue 17:18]
:ID:       52a04c78-0f21-46af-80af-18a43cbea9f4
:header-args: :tangle ~/.doom.d/modules/lang/org-private/+ir.el :noweb yes
:END:

#+begin_src elisp
;;; lang/org-private/+ir.el -*- lexical-binding: t; -*-
#+end_src

The actual function to extract to point
#+begin_src elisp
(defun nanjigen/org-noter-extract ()
  "Extract highlighted text into org-noter buffer as org-drill item"
  (interactive)
  ;; (org-back-to-heading)
  (save-window-excursion
  ;; Now I need to move the header text (which is the extracted pdf text) into the body
    (progn
      (nanjigen/move-headline-to-contents)
      (org-toggle-tag "extract"))))
#+end_src

#+begin_src elisp
(defun nanjigen/open-link-clipboard ()
  (interactive)
  (let ((link (substring-no-properties (x-get-selection 'CLIPBOARD 'STRING))))
    (org-link-open-from-string link)))

;; (org-noter "[[pdf:/home/vrika/Documents/PDF/books/wickedcoolshellscripts.pdf::1]]")
;; (org-brain-open-org-noter "3f0bea0e-07dd-4e48-9df7-aaeb8f1d3b8d")
#+end_src

#+RESULTS:
: nanjigen/open-link-clipboard

This is a fairly ugly hack. My ultimate intention is to use modified org-noter code.
#+begin_src elisp
(defun nanjigen/move-headline-to-contents ()
  "Move extracted PDF text to body of subtree"
  (interactive)
  ;; (let ((origin-element-type (org-element-type (org-element-at-point))))
  ;;   (if (string-equal "property-drawer" origin-element-type)
  ;;       (evil-insert-newline-below)))
  (progn
    ;; (with-selected-window (org-noter--get-notes-window)
    ;;   (evil-insert-newline-below))
    (org-noter-insert-note-toggle-no-questions)
    (org-back-to-heading)
    (org-toggle-tag "extract")
    (let* ((parent
            (save-excursion
              (org-backward-element)
              (org-element-property :title (org-element-at-point))))
           (headline (org-element-at-point))
           (title (org-element-property :title headline))
           (property-end (org-element-property :contents-end headline))
           ;; (property (org-element-at-point (goto-char property-pos)))
           (indent (org-element-property :level headline))
           (title-start (+ indent (org-element-property :begin headline)))
           (title-end (- (org-element-property :contents-begin headline) 1))
           (annot-id (car (last (s-split ";;" (org-entry-get nil "NOTER_PAGE")))))
           (annot-id-clean (s-chop-suffix "]]" annot-id))
           (org-uuid (org-entry-get nil "ID"))
           (annot-link (format "[[brain:%s][%s]]" org-uuid annot-id-clean))
           (cite-page (with-selected-window (org-noter--get-doc-window)
                        (format "%s"
                                (eval '(nth (1- (pdf-view-current-page))
                                            (pdf-cache-pagelabels))))))
           (cite (file-name-sans-extension (file-name-nondirectory (buffer-file-name)))))
      ;; (when (eq 'property-drawer (car property))
      ;; (goto-char (org-element-property :end property)))
      (goto-char property-end)
      (insert title)
      (delete-region title-start title-end)
      (goto-char title-start)
      ;;HACK use logic to identify if parent is an org-noter-outline headline
      ;; and then indent with org-mode code, not a hacky *!
      (insert (format " [[cite:%s][p%s]] %s" cite cite-page annot-link))
      ;; (save-excursion
        ;; (if (not (string-prefix-p "cite" parent))
        ;;     ;; (nanjigen/org-move-to-sibling)
        ;;     (nanjigen/org-move-to-extreme)
        ;;   )
      ;;
      ;;     (insert (format " cite:%s %s" cite id-clean))
      ;;   (insert (format "* cite:%s %s" cite id-clean)))
      (org-back-to-heading))))
#+end_src

#+RESULTS:
: nanjigen/move-headline-to-contents

Attempting to move to max point in tree from https://emacs.stackexchange.com/questions/43651/moving-a-subtree-to-the-top-or-bottom-of-its-parent/43662#43662
#+begin_src elisp
(defun nanjigen/org-move-to-extreme ()
  "Move current org subtree to the start of its parent."
  (interactive)
  (condition-case err
      (while t
        (funcall 'org-move-subtree-up)))
    (user-error
     (let ((err-msg (cadr err)))
       (unless (string-match "Cannot move past superior level or buffer limit" err-msg)
         (signal 'user-error (list err-msg))))))
#+end_src

#+begin_src elisp
(defun nanjigen/org-move-to-sibling ()
  "Move extracted org subtree under its 'cite:' sibling."
  (interactive)
  (setq parent (nanjigen/org-get-above-headline))
  (while (not (string-prefix-p "cite" parent))
     (funcall 'org-move-subtree-up)
     (setq parent (nanjigen/org-get-above-headline))))
#+end_src

#+begin_src elisp
(defun nanjigen/org-get-above-headline ()
"Get the headline entry of above parent/sibling as text"
(save-excursion
  (org-backward-element)
  (org-element-property :title (org-element-at-point))))
#+end_src

#+RESULTS:
: JK-org-move-to-extreme

#+begin_src elisp
(defun nanjigen/chopper ()
  "get 'annot' id from 'NOTER_PAGE' property"
  (interactive)
  (let* ((id (car (last (s-split ";;" (org-entry-get nil "NOTER_PAGE")))))
         (id-clean (s-chop-suffix "]]" id)))
    (insert (format "%s" id-clean))))

(defun nanjigen/delete-headline ()
  "delete the original title of text extracted with
(org-noter-insert-note-toggle-no-questions)"
  (interactive)
  (let* ((headline (org-element-at-point))
         (title-start (org-element-property :contents-begin headline))
         (title-end (org-element-property :end headline)))
    (delete-region title-start title-end)))

;; Functions for capturing from org noter
  (defun nanjigen/get-noter-link ()
    "return PROPERTY value of pdftools link"
    (interactive)
    (let ((linkStr (org-entry-get nil "NOTER_PAGE")))
      (insert linkStr)))

  ;;https://emacs.stackexchange.com/questions/32283/how-to-capture-and-link-code-comments-as-org-agenda-items
  (defun capture-noter-link ()
    "insert PROPERTY value of pdftools link"
    (interactive)
    (let ((linkStr
            (save-excursion
              (save-window-excursion
                (switch-to-buffer (plist-get org-capture-plist :original-buffer))
                (car (org-get-outline-path)))
              )))
      ))


  (defun insert-key (&optional p)
    "insert header as key value of org-brain header"
    ;; (unless p (setq p "NOTER_PAGE"))
    ;; (message "property passed is: %s" p)
    (interactive)
    (let ((pvalue
            (save-window-excursion
              (message "%s" (org-capture-get :original-buffer))
              (switch-to-buffer (org-capture-get :original-buffer))
              (message "retrieved header (key) is: %s" (car (org-get-outline-path (point) p)))
              (car (org-get-outline-path (point) p))
              )))
      pvalue))


  (defun key-to-header (&optional p)
    "insert header in org-capture target file as key value of org-brain header"
    ;; (unless p (setq p "NOTER_PAGE"))
    ;; (message "property passed is: %s" p)
    (interactive)
    (let ((heading
            (save-window-excursion
              (message "%s" (org-capture-get :original-buffer))
              (switch-to-buffer (org-capture-get :original-buffer))
              (message "retrieved header (key) is: %s" (car (org-get-outline-path (point) p)))
              (car (org-get-outline-path (point) p))
              )))
      (goto-char (org-find-exact-headline-in-buffer "IR Cards"))
      (unless (search-forward (format "** %s" heading) nil t)
        (org-end-of-subtree)
        (insert (format "\n** %s" heading))
        )))

  (defun insert-property (&optional p)
    "insert PROPERTY value of pdftools link"
    (interactive)
    (unless p (setq p "NOTER_PAGE"))
    (message "property passed is: %s" p)
    (let ((pvalue
            (save-window-excursion
              (message "%s" (org-capture-get :original-buffer))
              (switch-to-buffer (org-capture-get :original-buffer))
              (message "retrieved property is: %s" (org-entry-get (point) p))
              (org-entry-get (point) p)
              )))
      pvalue))

  (defun follow-noter-page-link ()
    "return PROPERTY value of pdftools link and follow in other-window"
    (interactive)
    ;; (run-with-timer 3 nil (lambda ()
      ;; TODO switch-to-buffer?
    (let ((linkStr (org-entry-get nil "NOTER_PAGE")))
      (if (> (length (window-list)) 1)
          (other-window 1)
        ;; (balance-windows)
          ;; (switch-to-buffer-other-window)
        (split-window-right))
      (org-link-open-from-string linkStr)))
;;
#+end_src

** TODO Automatic screenshots in org-noter with Flameshot
:PROPERTIES:
:CREATED:  [2021-06-02 Wed 17:04]
:ID:       1b6ec7b5-1957-4b53-ad71-1f58f2b99fac
:END:

#+begin_src elisp
(use-package! org-download
  :config
  (setq org-download-method 'attach))

(defun org-noter-insert-image-slice-note ()
  (interactive)
  (async-start (shell-command "flameshot gui")
               (progn
                 (switch-to-buffer-other-window
                  (window-buffer (org-noter--get-notes-window)))
                 ;; (defmacro org-noter--with-selected-notes-window ...)
                 (async-start (org-noter-insert-note)
                              (org-download-clipboard)))))

(define-key org-noter-doc-mode-map (kbd "Y") 'org-noter-insert-image-slice-note)
#+end_src

** old org-drill code
:PROPERTIES:
:CREATED:  [2021-01-20 Wed 13:58]
:ID:       7a12e649-f742-443e-bf42-6de953eb9752
:END:
#+begin_src elisp
;; This is to initiate drill from anywhere
;; Have next PDF fire off instead if all done?
(defun nanjigen/org-drill-in-ir-dir ()
  (interactive)
  (with-current-buffer (find-file-noselect "~/org/article-notes/article-index.org")
    (org-drill)))


;; (advice-add 'org-drill-reschedule :after-until #'follow-noter-page-link)
;; (advice-add 'org-drill-entry-p :after #'follow-noter-page-link)
;; (advice-add '(org-drill-entries (session-done)) :after #'follow-noter-page-link)
;; (advice-add 'org-drill-goto-entry :after #'follow-noter-page-link)
;; (advice-add 'org-drill-present-simple-card :after #'follow-noter-page-link)
;; (advice-add 'org-drill-present-default-answer :after #'follow-noter-page-link)
;; (advice-add 'org-drill-present-two-sided-card :after #'follow-noter-page-link)
;; (advice-add 'org-drill--edit-key :after #'follow-noter-page-link)
;; (advice-add 'org-drill-response-complete-rtn :after #'follow-noter-page-link)
;; (advice-add 'org-drill-response-complete :after #'follow-noter-page-link)
;; (advice-add 'org-drill-response-quit  :after #'follow-noter-page-link)
;; (add-function :after ('org-drill-response-edit) #'follow-noter-page-link)
;; (advice-add 'org-drill-response-complete :after #'follow-noter-page-link)
(advice-add 'org-drill-response-edit :after #'follow-noter-page-link)
(advice-add 'org-drill-response-edit :after-while #'follow-noter-page-link)
(advice-add 'org-drill-response-quit  :after #'follow-noter-page-link)
;; (advice-add 'org-drill--edit-key :after #'follow-noter-page-link)


;; This triggers the function but not at the right time
;; (add-hook 'org-drill-display-answer-hook #'follow-noter-page-link)
#+end_src
